# Chapter 11.1: Password Hashing

Secure password storage is fundamental to authentication. In this chapter, we'll explore password hashing algorithms and their implementation.

## Why Hash Passwords?

If passwords are stored in plaintext:

```
Database breach → All passwords exposed → Users compromised everywhere
```

With proper hashing:

```
Database breach → Only hashes exposed → Passwords still protected
```

## Hashing vs Encryption

| | Hashing | Encryption |
|--|---------|------------|
| Direction | One-way | Two-way |
| Reversible | No | Yes (with key) |
| Purpose | Verification | Data protection |
| For passwords | ✅ Yes | ❌ No |

## Recommended Algorithms

### Argon2 (Recommended)

```elixir
# Add to mix.exs
{:argon2_elixir, "~> 3.0"}
```

```elixir
# Hash a password
hash = Argon2.hash_pwd_salt("password123")
# => "$argon2id$v=19$m=65536,t=3,p=4$..."

# Verify a password
Argon2.verify_pass("password123", hash)
# => true

Argon2.verify_pass("wrong", hash)
# => false
```

### Bcrypt (Alternative)

```elixir
# Add to mix.exs
{:bcrypt_elixir, "~> 3.0"}
```

```elixir
# Hash a password
hash = Bcrypt.hash_pwd_salt("password123")
# => "$2b$12$..."

# Verify a password
Bcrypt.verify_pass("password123", hash)
# => true
```

## User Schema

```elixir
# File: lib/snippetbox/accounts/user.ex

defmodule Snippetbox.Accounts.User do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :email, :string
    field :name, :string
    field :password, :string, virtual: true, redact: true
    field :hashed_password, :string, redact: true

    timestamps()
  end

  @doc """
  Changeset for user registration.
  """
  def registration_changeset(user, attrs, opts \\ []) do
    user
    |> cast(attrs, [:email, :name, :password])
    |> validate_email()
    |> validate_password(opts)
  end

  defp validate_email(changeset) do
    changeset
    |> validate_required([:email])
    |> validate_format(:email, ~r/^[^\s]+@[^\s]+$/, message: "must be a valid email")
    |> validate_length(:email, max: 160)
    |> unsafe_validate_unique(:email, Snippetbox.Repo)
    |> unique_constraint(:email)
  end

  defp validate_password(changeset, opts) do
    changeset
    |> validate_required([:password])
    |> validate_length(:password, min: 12, max: 72)
    |> validate_password_strength()
    |> maybe_hash_password(opts)
  end

  defp validate_password_strength(changeset) do
    validate_change(changeset, :password, fn :password, password ->
      cond do
        not String.match?(password, ~r/[a-z]/) ->
          [password: "must contain a lowercase letter"]
        not String.match?(password, ~r/[A-Z]/) ->
          [password: "must contain an uppercase letter"]
        not String.match?(password, ~r/[0-9]/) ->
          [password: "must contain a number"]
        true ->
          []
      end
    end)
  end

  defp maybe_hash_password(changeset, opts) do
    hash_password? = Keyword.get(opts, :hash_password, true)
    password = get_change(changeset, :password)

    if hash_password? && password && changeset.valid? do
      changeset
      |> validate_length(:password, max: 72, count: :bytes)
      |> put_change(:hashed_password, Argon2.hash_pwd_salt(password))
      |> delete_change(:password)
    else
      changeset
    end
  end

  @doc """
  Verifies the password against the hashed password.
  """
  def valid_password?(%__MODULE__{hashed_password: hashed_password}, password)
      when is_binary(hashed_password) and byte_size(password) > 0 do
    Argon2.verify_pass(password, hashed_password)
  end

  def valid_password?(_, _) do
    # Prevent timing attacks by always running hash
    Argon2.no_user_verify()
    false
  end
end
```

## Migration

```elixir
# File: priv/repo/migrations/YYYYMMDDHHMMSS_create_users.exs

defmodule Snippetbox.Repo.Migrations.CreateUsers do
  use Ecto.Migration

  def change do
    create table(:users) do
      add :email, :citext, null: false
      add :name, :string, null: false
      add :hashed_password, :string, null: false

      timestamps()
    end

    create unique_index(:users, [:email])
  end
end
```

Enable citext extension:

```elixir
# File: priv/repo/migrations/YYYYMMDDHHMMSS_enable_citext.exs

defmodule Snippetbox.Repo.Migrations.EnableCitext do
  use Ecto.Migration

  def change do
    execute "CREATE EXTENSION IF NOT EXISTS citext", ""
  end
end
```

## Password Hashing Options

### Argon2 Configuration

```elixir
# config/config.exs
config :argon2_elixir,
  t_cost: 3,        # Time cost (iterations)
  m_cost: 16,       # Memory cost (2^16 = 64MB)
  parallelism: 4    # Parallel threads
```

### Bcrypt Configuration

```elixir
# config/config.exs
config :bcrypt_elixir,
  log_rounds: 12    # 2^12 iterations
```

### Development vs Production

```elixir
# config/test.exs - Faster for tests
config :argon2_elixir,
  t_cost: 1,
  m_cost: 8

# config/prod.exs - Stronger for production
config :argon2_elixir,
  t_cost: 4,
  m_cost: 17,
  parallelism: 4
```

## Timing Attack Prevention

### The Problem

```elixir
# VULNERABLE - timing leak
def authenticate(email, password) do
  user = Repo.get_by(User, email: email)

  if user && Argon2.verify_pass(password, user.hashed_password) do
    {:ok, user}
  else
    {:error, :invalid_credentials}
  end
end
# If no user exists, returns immediately
# Attacker can detect which emails exist
```

### The Solution

```elixir
# SECURE - constant time
def authenticate(email, password) do
  user = Repo.get_by(User, email: email)

  if user do
    if Argon2.verify_pass(password, user.hashed_password) do
      {:ok, user}
    else
      {:error, :invalid_credentials}
    end
  else
    # Run hash anyway to prevent timing attack
    Argon2.no_user_verify()
    {:error, :invalid_credentials}
  end
end
```

## Password Change

```elixir
# File: lib/snippetbox/accounts/user.ex

def password_changeset(user, attrs, opts \\ []) do
  user
  |> cast(attrs, [:password])
  |> validate_required([:password])
  |> validate_length(:password, min: 12, max: 72)
  |> validate_password_strength()
  |> maybe_hash_password(opts)
end

def validate_current_password(changeset, current_password) do
  if valid_password?(changeset.data, current_password) do
    changeset
  else
    add_error(changeset, :current_password, "is not valid")
  end
end
```

## Context Functions

```elixir
# File: lib/snippetbox/accounts.ex

defmodule Snippetbox.Accounts do
  alias Snippetbox.Repo
  alias Snippetbox.Accounts.User

  @doc """
  Creates a new user.
  """
  def register_user(attrs) do
    %User{}
    |> User.registration_changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Authenticates a user by email and password.
  """
  def authenticate_by_email_and_password(email, password) do
    user = Repo.get_by(User, email: email)

    cond do
      user && User.valid_password?(user, password) ->
        {:ok, user}
      user ->
        {:error, :invalid_password}
      true ->
        Argon2.no_user_verify()
        {:error, :user_not_found}
    end
  end

  @doc """
  Changes user password.
  """
  def update_user_password(user, current_password, attrs) do
    changeset =
      user
      |> User.password_changeset(attrs)
      |> User.validate_current_password(current_password)

    Repo.update(changeset)
  end
end
```

## Testing Password Hashing

```elixir
# File: test/snippetbox/accounts/user_test.exs

defmodule Snippetbox.Accounts.UserTest do
  use Snippetbox.DataCase

  alias Snippetbox.Accounts.User

  describe "registration_changeset/2" do
    test "hashes password" do
      changeset = User.registration_changeset(%User{}, %{
        email: "test@example.com",
        name: "Test",
        password: "ValidPass123!"
      })

      assert changeset.valid?
      assert changeset.changes.hashed_password
      refute Map.has_key?(changeset.changes, :password)
    end

    test "requires minimum password length" do
      changeset = User.registration_changeset(%User{}, %{
        email: "test@example.com",
        password: "short"
      })

      refute changeset.valid?
      assert "should be at least 12 character(s)" in errors_on(changeset).password
    end
  end

  describe "valid_password?/2" do
    test "validates correct password" do
      user = user_fixture()
      assert User.valid_password?(user, "ValidPass123!")
    end

    test "rejects incorrect password" do
      user = user_fixture()
      refute User.valid_password?(user, "wrong")
    end

    test "rejects empty password" do
      user = user_fixture()
      refute User.valid_password?(user, "")
    end
  end
end
```

> **FP Concept: Pure Password Verification**
>
> Password verification is a pure function:
>
> ```elixir
> valid_password?(user, password) :: boolean()
>
> # Same inputs → same output
> # No side effects
> # Easy to test
> ```
>
> The hashing is done at write time; verification is a simple comparison.

## Summary

In this chapter, we learned:

- Why passwords must be hashed
- Argon2 vs Bcrypt algorithms
- Implementing password hashing in schemas
- Password validation rules
- Timing attack prevention
- Password change functionality
- Testing password hashing

In the next chapter, we'll implement user registration.
