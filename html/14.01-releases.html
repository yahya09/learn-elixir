<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Elixir Releases &mdash; Let's Build with Elixir and Phoenix</title>
    <link rel="stylesheet" type="text/css" href="assets/css/main.css">
</head>
<body>
    <header>
        <div class="wrapper">
            <div>
                <a href="index.html">Let's Build with Elixir and Phoenix</a>
                <span class="crumbs">&rsaquo; Elixir Releases</span>
            </div>
            <div>
                &lsaquo; <a href="14.00-deployment.html">Previous</a> &middot;
                <a href="00.01-contents.html">Contents</a>
                &middot; <a href="14.02-docker.html">Next</a> &rsaquo;
            </div>
        </div>
    </header>
    <main class="wrapper text">
        <div class="chapter">Chapter 14.1</div>
        <h1>Chapter 14.1: Elixir Releases</h1>

<p>Releases are self-contained packages that include your application, its dependencies, and the Erlang runtime. In this chapter, we'll explore building and configuring releases.</p>

<h2>What is a Release?</h2>

<p>A release is a deployable artifact containing:</p>

<ul>
<li>Your compiled application</li>
<li>All dependencies</li>
<li>Erlang/OTP runtime (ERTS)</li>
<li>Boot scripts and configuration</li>
</ul>

<figure class="code"><pre><code>_build/prod/rel/snippetbox/
<p>├── bin/</p>
<p>│   └── snippetbox         # CLI entry point</p>
<p>├── lib/</p>
<p>│   ├── snippetbox-0.1.0/  # Your app</p>
<p>│   ├── phoenix-1.7.x/     # Phoenix</p>
<p>│   └── ecto-3.x/          # Dependencies</p>
<p>├── releases/</p>
<p>│   └── 0.1.0/</p>
<p>│       ├── elixir         # Elixir version</p>
<p>│       ├── env.sh         # Environment script</p>
<p>│       ├── remote.sh      # Remote console script</p>
<p>│       └── vm.args        # BEAM VM arguments</p>
<p>└── erts-14.0/             # Erlang runtime</p>
</code></pre></figure>

<h2>Building a Release</h2>

<h3>Basic Release</h3>

<figure class="code"><pre><code># Build production release
<p>MIX_ENV=prod mix release</p>

<h1>Output</h1>
<ul>
<li>Release created at _build/prod/rel/snippetbox</li>
</ul>
</code></pre></figure>

<h3>Release Configuration</h3>

<figure class="code"><figcaption>File: mix.exs</figcaption><pre><code class="language-elixir">
<p>def project do</p>
<p>  [</p>
<p>    app: :snippetbox,</p>
<p>    version: "0.1.0",</p>
<p>    elixir: "~> 1.16",</p>
<p>    releases: [</p>
<p>      snippetbox: [</p>
<p>        include_executables_for: [:unix],</p>
<p>        applications: [runtime_tools: :permanent]</p>
<p>      ]</p>
<p>    ]</p>
<p>  ]</p>
<p>end</p>
</code></pre></figure>

<h3>Custom Release Options</h3>

<figure class="code"><figcaption>File: mix.exs</figcaption><pre><code class="language-elixir">
<p>releases: [</p>
<p>  snippetbox: [</p>
<p>    version: {:from_app, :snippetbox},</p>
<p>    include_executables_for: [:unix, :windows],</p>
<p>    include_erts: true,</p>
<p>    strip_beams: true,</p>
<p>    cookie: "super_secret_cookie",</p>
<p>    steps: [:assemble, :tar]</p>
<p>  ]</p>
<p>]</p>
</code></pre></figure>

<h2>Runtime Configuration</h2>

<h3>config/runtime.exs</h3>

<figure class="code"><figcaption>File: config/runtime.exs</figcaption><pre><code class="language-elixir">
<p>import Config</p>

<p>if config_env() == :prod do</p>
<p>  database_url =</p>
<p>    System.get_env("DATABASE_URL") ||</p>
<p>      raise """</p>
<p>      environment variable DATABASE_URL is missing.</p>
<p>      For example: ecto://USER:PASS@HOST/DATABASE</p>
<p>      """</p>

<p>  config :snippetbox, Snippetbox.Repo,</p>
<p>    url: database_url,</p>
<p>    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),</p>
<p>    ssl: true,</p>
<p>    ssl_opts: [</p>
<p>      verify: :verify_peer,</p>
<p>      cacerts: :public_key.cacerts_get(),</p>
<p>      server_name_indication: String.to_charlist(System.get_env("DATABASE_HOST")),</p>
<p>      customize_hostname_check: [</p>
<p>        match_fun: :public_key.pkix_verify_hostname_match_fun(:https)</p>
<p>      ]</p>
<p>    ]</p>

<p>  secret_key_base =</p>
<p>    System.get_env("SECRET_KEY_BASE") ||</p>
<p>      raise """</p>
<p>      environment variable SECRET_KEY_BASE is missing.</p>
<p>      You can generate one by calling: mix phx.gen.secret</p>
<p>      """</p>

<p>  host = System.get_env("PHX_HOST") || "example.com"</p>
<p>  port = String.to_integer(System.get_env("PORT") || "4000")</p>

<p>  config :snippetbox, SnippetboxWeb.Endpoint,</p>
<p>    url: [host: host, port: 443, scheme: "https"],</p>
<p>    http: [</p>
<p>      ip: {0, 0, 0, 0, 0, 0, 0, 0},</p>
<p>      port: port</p>
<p>    ],</p>
<p>    secret_key_base: secret_key_base,</p>
<p>    server: true</p>

<p>  # Email configuration</p>
<p>  config :snippetbox, Snippetbox.Mailer,</p>
<p>    adapter: Swoosh.Adapters.Postmark,</p>
<p>    api_key: System.get_env("POSTMARK_API_KEY")</p>
<p>end</p>
</code></pre></figure>

<h2>Release Commands</h2>

<h3>Running the Application</h3>

<figure class="code"><pre><code># Start in foreground
<p>bin/snippetbox start</p>

<h1>Start in background (daemon)</h1>
<p>bin/snippetbox daemon</p>

<h1>Start with interactive console</h1>
<p>bin/snippetbox start_iex</p>

<h1>Stop daemon</h1>
<p>bin/snippetbox stop</p>

<h1>Restart daemon</h1>
<p>bin/snippetbox restart</p>

<h1>Check if running</h1>
<p>bin/snippetbox pid</p>
</code></pre></figure>

<h3>Remote Console</h3>

<figure class="code"><pre><code># Connect to running application
<p>bin/snippetbox remote</p>

<h1>In the console</h1>
<p>iex> Snippetbox.Repo.all(Snippetbox.Snippets.Snippet)</p>
<p>iex> :observer.start()  # Start Observer GUI</p>
</code></pre></figure>

<h3>Running Migrations</h3>

<figure class="code"><figcaption>File: lib/snippetbox/release.ex</figcaption><pre><code class="language-elixir">
<p>defmodule Snippetbox.Release do</p>
<p>  @moduledoc """</p>
<p>  Release tasks for running migrations and seeds.</p>
<p>  """</p>

<p>  @app :snippetbox</p>

<p>  def migrate do</p>
<p>    load_app()</p>

<p>    for repo <- repos() do</p>
<p>      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, all: true))</p>
<p>    end</p>
<p>  end</p>

<p>  def rollback(repo, version) do</p>
<p>    load_app()</p>
<p>    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :down, to: version))</p>
<p>  end</p>

<p>  def seed do</p>
<p>    load_app()</p>

<p>    for repo <- repos() do</p>
<p>      {:ok, _, _} = Ecto.Migrator.with_repo(repo, fn _ -></p>
<p>        Code.eval_file(Path.join([:code.priv_dir(@app), "repo", "seeds.exs"]))</p>
<p>      end)</p>
<p>    end</p>
<p>  end</p>

<p>  defp repos do</p>
<p>    Application.fetch_env!(@app, :ecto_repos)</p>
<p>  end</p>

<p>  defp load_app do</p>
<p>    Application.load(@app)</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<figure class="code"><pre><code># Run migrations
<p>bin/snippetbox eval "Snippetbox.Release.migrate()"</p>

<h1>Run seeds</h1>
<p>bin/snippetbox eval "Snippetbox.Release.seed()"</p>

<h1>Rollback to version</h1>
<p>bin/snippetbox eval "Snippetbox.Release.rollback(Snippetbox.Repo, 20240101000000)"</p>
</code></pre></figure>

<h2>Environment Scripts</h2>

<h3>rel/env.sh.eex</h3>

<figure class="code"><pre><code>#!/bin/sh

<h1>Custom environment setup</h1>
<p>export RELEASE_DISTRIBUTION=name</p>
<p>export RELEASE_NODE=snippetbox@127.0.0.1</p>

<h1>Load secrets from file if present</h1>
<p>if [ -f /run/secrets/env ]; then</p>
<p>  export $(cat /run/secrets/env | xargs)</p>
<p>fi</p>

<h1>Set ERL_AFLAGS for better observability</h1>
<p>export ERL_AFLAGS="-kernel shell_history enabled"</p>
</code></pre></figure>

<h3>rel/vm.args.eex</h3>

<figure class="code"><pre><code>## VM options

<h2>Name of the node</h2>
<p>-name <%= @release.name %>@127.0.0.1</p>

<h2>Cookie for distributed Erlang</h2>
<p>-setcookie <%= @release.cookie %></p>

<h2>Heartbeat monitoring</h2>
<p>-heart</p>

<h2>Maximum number of processes</h2>
<p>+P 1000000</p>

<h2>Maximum number of ports</h2>
<p>+Q 65536</p>

<h2>Scheduler settings</h2>
<p>+K true</p>
<p>+A 32</p>
<p>+SDio 32</p>

<h2>Memory</h2>
<p>+MBas aobf</p>
<p>+MBlmbcs 512</p>

<h2>Garbage collection settings</h2>
<p>+sbwt very_long</p>
<p>+swt very_low</p>
</code></pre></figure>

<h2>Asset Compilation</h2>

<figure class="code"><pre><code># Compile assets before building release
<p>MIX_ENV=prod mix assets.deploy</p>

<h1>This runs:</h1>
<h1>1. esbuild for JavaScript</h1>
<h1>2. tailwind for CSS</h1>
<h1>3. phx.digest for cache manifests</h1>
</code></pre></figure>

<h3>Asset Pipeline Configuration</h3>

<figure class="code"><figcaption>File: config/config.exs</figcaption><pre><code class="language-elixir">
<p>config :esbuild,</p>
<p>  version: "0.17.11",</p>
<p>  default: [</p>
<p>    args: ~w(js/app.js --bundle --target=es2017 --outdir=../priv/static/assets --external:/fonts/<em> --external:/images/</em>),</p>
<p>    cd: Path.expand("../assets", __DIR__),</p>
<p>    env: %{"NODE_PATH" => Path.expand("../deps", __DIR__)}</p>
<p>  ]</p>

<p>config :tailwind,</p>
<p>  version: "3.4.0",</p>
<p>  default: [</p>
<p>    args: ~w(--config=tailwind.config.js --input=css/app.css --output=../priv/static/assets/app.css),</p>
<p>    cd: Path.expand("../assets", __DIR__)</p>
<p>  ]</p>
</code></pre></figure>

<h2>Overlays</h2>

<p>Add extra files to releases:</p>

<figure class="code"><figcaption>File: mix.exs</figcaption><pre><code class="language-elixir">
<p>releases: [</p>
<p>  snippetbox: [</p>
<p>    overlays: ["rel/overlays"]</p>
<p>  ]</p>
<p>]</p>
</code></pre></figure>

<figure class="code"><pre><code># rel/overlays/
<h1>Files here are copied to release root</h1>

<p>rel/overlays/</p>
<p>├── bin/</p>
<p>│   └── migrate     # Custom migration script</p>
<p>└── etc/</p>
<p>    └── nginx.conf  # Nginx config template</p>
</code></pre></figure>

<h2>Building for Different Targets</h2>

<h3>Cross-Compilation with Burrito</h3>

<figure class="code"><pre><code># For native executables
<p>{:burrito, "~> 1.0"}</p>
</code></pre></figure>

<h3>Multi-Platform Docker</h3>

<figure class="code"><pre><code># Build for multiple platforms
<p>docker buildx build --platform linux/amd64,linux/arm64 -t myapp .</p>
</code></pre></figure>

<h2>Deploying a Release</h2>

<h3>Basic Deploy Script</h3>

<figure class="code"><pre><code>#!/bin/bash
<h1>deploy.sh</h1>

<p>set -e</p>

<p>SERVER="deploy@production-server"</p>
<p>APP_DIR="/opt/snippetbox"</p>
<p>RELEASE_DIR="_build/prod/rel/snippetbox"</p>

<p>echo "Building release..."</p>
<p>MIX_ENV=prod mix deps.get --only prod</p>
<p>MIX_ENV=prod mix assets.deploy</p>
<p>MIX_ENV=prod mix release --overwrite</p>

<p>echo "Deploying to server..."</p>
<p>rsync -avz --delete $RELEASE_DIR/ $SERVER:$APP_DIR/</p>

<p>echo "Running migrations..."</p>
<p>ssh $SERVER "$APP_DIR/bin/snippetbox eval 'Snippetbox.Release.migrate()'"</p>

<p>echo "Restarting application..."</p>
<p>ssh $SERVER "sudo systemctl restart snippetbox"</p>

<p>echo "Deploy complete!"</p>
</code></pre></figure>

<h3>Systemd Service</h3>

<figure class="code"><pre><code># /etc/systemd/system/snippetbox.service

<p>[Unit]</p>
<p>Description=Snippetbox Phoenix Application</p>
<p>After=network.target postgresql.service</p>

<p>[Service]</p>
<p>Type=exec</p>
<p>User=deploy</p>
<p>Group=deploy</p>
<p>WorkingDirectory=/opt/snippetbox</p>
<p>Environment=MIX_ENV=prod</p>
<p>Environment=PORT=4000</p>
<p>EnvironmentFile=/opt/snippetbox/.env</p>
<p>ExecStart=/opt/snippetbox/bin/snippetbox start</p>
<p>ExecStop=/opt/snippetbox/bin/snippetbox stop</p>
<p>Restart=on-failure</p>
<p>RestartSec=5</p>

<p>[Install]</p>
<p>WantedBy=multi-user.target</p>
</code></pre></figure>

<figure class="code"><pre><code># Enable and start
<p>sudo systemctl enable snippetbox</p>
<p>sudo systemctl start snippetbox</p>
<p>sudo systemctl status snippetbox</p>
</code></pre></figure>

<blockquote class="fp-concept">
<strong>FP Concept: Immutable Releases</strong>
</blockquote>
<p>></p>
<blockquote>
<p>Releases are immutable artifacts:</p>
</blockquote>
<p>></p>
<blockquote>
<figure class="code"><pre><code>> # Each release is a complete snapshot
<p># No shared state between releases</p>
<p># Rollback = deploy previous release</p>
</blockquote>
<p>></p>
<blockquote>
<p>releases/</p>
<p>├── 0.1.0/  # Version 1</p>
<p>├── 0.2.0/  # Version 2</p>
<p>└── 0.3.0/  # Current</p>
</blockquote>
<p>></p>
<blockquote>
<p># To rollback: symlink or deploy 0.2.0</p>
</code></pre></figure>
</blockquote>
<p>></p>
<blockquote>
<p>This aligns with functional principles of immutability.</p>
</blockquote>

<h2>Summary</h2>

<p>In this chapter, we learned:</p>

<ul>
<li>What releases are and why to use them</li>
<li>Building releases with Mix</li>
<li>Runtime configuration</li>
<li>Release commands (start, migrate, remote)</li>
<li>Environment and VM configuration</li>
<li>Asset compilation</li>
<li>Deployment strategies</li>
</ul>

<p>In the next chapter, we'll explore Docker containerization.</p>

    </main>
    <footer>
        <div class="wrapper">
            <div>
                &lsaquo; <a href="14.00-deployment.html">Previous</a>
            </div>
            <div>
                <a href="00.01-contents.html">Contents</a>
            </div>
            <div>
                <a href="14.02-docker.html">Next</a> &rsaquo;
            </div>
        </div>
    </footer>
</body>
</html>
