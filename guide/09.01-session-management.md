# Chapter 9.1: Session Management

Sessions allow you to persist data across requests for individual users. In this chapter, we'll explore Phoenix's session management system.

## How Sessions Work

```
Browser                          Server
   │                               │
   │  Request (no cookie)          │
   │──────────────────────────────>│
   │                               │
   │  Response                     │
   │  Set-Cookie: _session=abc123  │
   │<──────────────────────────────│
   │                               │
   │  Request                      │
   │  Cookie: _session=abc123      │
   │──────────────────────────────>│
   │                               │
   │  Server decodes session       │
   │  %{user_id: 42, ...}          │
   │                               │
```

## Session Configuration

### Endpoint Configuration

```elixir
# File: lib/snippetbox_web/endpoint.ex

defmodule SnippetboxWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :snippetbox

  # Session configuration
  @session_options [
    store: :cookie,
    key: "_snippetbox_key",
    signing_salt: "abc123xyz",
    encryption_salt: "encrypted_cookie_salt",
    same_site: "Lax"
  ]

  plug Plug.Session, @session_options

  # ...
end
```

### Configuration Options

| Option | Description | Default |
|--------|-------------|---------|
| `:store` | Storage backend (`:cookie` or `:ets`) | `:cookie` |
| `:key` | Cookie name | Required |
| `:signing_salt` | Salt for signing | Required |
| `:encryption_salt` | Salt for encryption | Optional |
| `:max_age` | Session lifetime in seconds | Session cookie |
| `:same_site` | SameSite cookie attribute | `"Lax"` |
| `:secure` | HTTPS only | `false` |
| `:http_only` | Not accessible via JS | `true` |
| `:domain` | Cookie domain | Current domain |

### Environment-Specific Configuration

```elixir
# File: config/config.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  # Base configuration

# File: config/prod.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  secret_key_base: System.get_env("SECRET_KEY_BASE")

# Session options can reference this
@session_options [
  store: :cookie,
  key: "_snippetbox_key",
  signing_salt: "production_signing_salt",
  encryption_salt: "production_encryption_salt",
  same_site: "Lax",
  secure: true,  # HTTPS in production
  max_age: 60 * 60 * 24 * 60  # 60 days
]
```

## Using Sessions

### Pipeline Setup

```elixir
# File: lib/snippetbox_web/router.ex

pipeline :browser do
  plug :accepts, ["html"]
  plug :fetch_session       # ← Load session data
  plug :fetch_live_flash
  plug :put_root_layout, html: {SnippetboxWeb.Layouts, :root}
  plug :protect_from_forgery
  plug :put_secure_browser_headers
end
```

### Reading Session Data

```elixir
# File: lib/snippetbox_web/controllers/page_controller.ex

def home(conn, _params) do
  # Get single value
  user_id = get_session(conn, :user_id)

  # Get with default
  theme = get_session(conn, :theme) || "light"

  # Get all session data (for debugging)
  all_session = conn.private.plug_session

  render(conn, :home, user_id: user_id, theme: theme)
end
```

### Writing Session Data

```elixir
def login(conn, %{"user" => user_params}) do
  case Accounts.authenticate(user_params) do
    {:ok, user} ->
      conn
      |> put_session(:user_id, user.id)
      |> put_session(:logged_in_at, DateTime.utc_now())
      |> configure_session(renew: true)  # New session ID (security)
      |> redirect(to: ~p"/")

    {:error, _reason} ->
      render(conn, :new, error: "Invalid credentials")
  end
end
```

### Deleting Session Data

```elixir
def logout(conn, _params) do
  conn
  |> clear_session()  # Remove all session data
  |> redirect(to: ~p"/")
end

# Or delete specific keys
def clear_preferences(conn, _params) do
  conn
  |> delete_session(:theme)
  |> delete_session(:language)
  |> redirect(to: ~p"/settings")
end
```

### Session Configuration at Runtime

```elixir
# Renew session ID (after login for security)
configure_session(conn, renew: true)

# Drop the session entirely
configure_session(conn, drop: true)

# Ignore changes made to session
configure_session(conn, ignore: true)
```

## Session Storage Backends

### Cookie Store (Default)

Stores session data in signed/encrypted cookie:

```elixir
@session_options [
  store: :cookie,
  key: "_snippetbox_key",
  signing_salt: "...",
  encryption_salt: "..."
]
```

Pros:
- No server-side storage needed
- Scales horizontally easily
- Fast (no database lookup)

Cons:
- Limited to ~4KB
- Data sent with every request
- Cannot invalidate from server

### ETS Store

Stores session data in server memory:

```elixir
# File: lib/snippetbox_web/endpoint.ex

@session_options [
  store: :ets,
  key: "_snippetbox_key",
  table: :session_store
]

# Create ETS table on application start
# File: lib/snippetbox/application.ex

def start(_type, _args) do
  :ets.new(:session_store, [:named_table, :public, read_concurrency: true])

  children = [
    # ...
  ]

  Supervisor.start_link(children, strategy: :one_for_one)
end
```

Pros:
- Can store larger data
- Can invalidate from server
- Less data per request

Cons:
- Lost on server restart
- Doesn't scale horizontally (without distributed ETS)
- More memory usage

### Redis/Database Store (Custom)

For production with multiple servers:

```elixir
# Add dependency
{:plug_session_redis, "~> 0.1"}

# Configuration
@session_options [
  store: PlugSessionRedis,
  key: "_snippetbox_key",
  table: :redis_sessions,
  ttl: 86400  # 24 hours
]
```

## Authentication Pattern

### Storing User in Session

```elixir
# File: lib/snippetbox_web/controllers/session_controller.ex

def create(conn, %{"email" => email, "password" => password}) do
  case Accounts.authenticate_user(email, password) do
    {:ok, user} ->
      conn
      |> put_session(:user_id, user.id)
      |> put_session(:user_token, Accounts.generate_session_token(user))
      |> configure_session(renew: true)
      |> put_flash(:info, "Welcome back!")
      |> redirect(to: ~p"/")

    {:error, :invalid_credentials} ->
      conn
      |> put_flash(:error, "Invalid email or password")
      |> render(:new)
  end
end
```

### Loading User from Session

```elixir
# File: lib/snippetbox_web/plugs/auth.ex

defmodule SnippetboxWeb.Plugs.Auth do
  import Plug.Conn
  alias Snippetbox.Accounts

  def fetch_current_user(conn, _opts) do
    user_token = get_session(conn, :user_token)
    user = user_token && Accounts.get_user_by_session_token(user_token)
    assign(conn, :current_user, user)
  end

  def require_authenticated_user(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
    else
      conn
      |> Phoenix.Controller.put_flash(:error, "You must log in to access this page.")
      |> Phoenix.Controller.redirect(to: "/login")
      |> halt()
    end
  end
end
```

### Router Setup

```elixir
# File: lib/snippetbox_web/router.ex

pipeline :browser do
  # ... standard plugs ...
  plug :fetch_current_user
end

pipeline :require_authenticated_user do
  plug :require_authenticated_user
end

scope "/", SnippetboxWeb do
  pipe_through [:browser, :require_authenticated_user]

  resources "/snippets", SnippetController
end
```

## Session Security

### Token-Based Sessions

Store a token instead of user ID for better security:

```elixir
# File: lib/snippetbox/accounts.ex

def generate_session_token(user) do
  token = :crypto.strong_rand_bytes(32) |> Base.url_encode64()

  # Store token in database
  Repo.insert!(%UserToken{
    token: token,
    user_id: user.id,
    context: "session",
    inserted_at: NaiveDateTime.utc_now()
  })

  token
end

def get_user_by_session_token(token) do
  query =
    from t in UserToken,
      where: t.token == ^token and t.context == "session",
      where: t.inserted_at > ago(60, "day"),
      join: u in assoc(t, :user),
      select: u

  Repo.one(query)
end

def delete_session_token(token) do
  Repo.delete_all(from t in UserToken, where: t.token == ^token)
end
```

### Session Expiry

```elixir
# Check session age
def validate_session_age(conn, _opts) do
  logged_in_at = get_session(conn, :logged_in_at)

  if logged_in_at && session_expired?(logged_in_at) do
    conn
    |> clear_session()
    |> put_flash(:info, "Your session has expired. Please log in again.")
    |> redirect(to: ~p"/login")
    |> halt()
  else
    conn
  end
end

defp session_expired?(logged_in_at) do
  max_age = 60 * 60 * 24 * 7  # 7 days
  DateTime.diff(DateTime.utc_now(), logged_in_at) > max_age
end
```

### Session Fixation Prevention

Always renew session after authentication:

```elixir
def login(conn, params) do
  # After successful authentication
  conn
  |> configure_session(renew: true)  # ← Prevents session fixation
  |> put_session(:user_id, user.id)
end
```

> **FP Concept: Immutable Session**
>
> In Phoenix, `conn` is immutable. Session operations return a new conn:
>
> ```elixir
> # Each operation returns a new conn
> conn
> |> put_session(:key, "value")    # Returns new conn
> |> delete_session(:other_key)    # Returns new conn
> |> configure_session(renew: true) # Returns new conn
> ```
>
> This makes session manipulation predictable and thread-safe.

## Summary

In this chapter, we learned:

- How sessions work in Phoenix
- Session configuration options
- Reading, writing, and deleting session data
- Different storage backends
- Authentication patterns with sessions
- Session security best practices

In the next chapter, we'll explore flash messages.
