# Chapter 6.4: Common Plug Patterns

This chapter covers common plug patterns you'll encounter in Phoenix applications - authentication, authorization, request transformation, and more.

## Authentication Plugs

### Session-Based Authentication

```elixir
# File: lib/snippetbox_web/plugs/auth.ex

defmodule SnippetboxWeb.Plugs.Auth do
  import Plug.Conn
  import Phoenix.Controller

  alias Snippetbox.Accounts

  @doc """
  Loads the current user from session into assigns.
  Always runs, assigns nil if not logged in.
  """
  def fetch_current_user(conn, _opts) do
    user_id = get_session(conn, :user_id)
    user = user_id && Accounts.get_user(user_id)
    assign(conn, :current_user, user)
  end

  @doc """
  Requires a logged-in user.
  Redirects to login if not authenticated.
  """
  def require_authenticated_user(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
    else
      conn
      |> put_flash(:error, "You must log in to access this page.")
      |> maybe_store_return_to()
      |> redirect(to: "/login")
      |> halt()
    end
  end

  @doc """
  Redirects authenticated users away from auth pages.
  """
  def redirect_if_authenticated(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
      |> redirect(to: "/")
      |> halt()
    else
      conn
    end
  end

  defp maybe_store_return_to(conn) do
    if conn.method == "GET" do
      put_session(conn, :return_to, conn.request_path)
    else
      conn
    end
  end

  @doc """
  Gets stored return path or default.
  """
  def get_return_to(conn, default \\ "/") do
    get_session(conn, :return_to) || default
  end
end
```

### Token-Based Authentication (API)

```elixir
# File: lib/snippetbox_web/plugs/api_auth.ex

defmodule SnippetboxWeb.Plugs.APIAuth do
  import Plug.Conn
  import Phoenix.Controller

  alias Snippetbox.Accounts

  def fetch_api_user(conn, _opts) do
    with ["Bearer " <> token] <- get_req_header(conn, "authorization"),
         {:ok, claims} <- verify_token(token),
         user when not is_nil(user) <- Accounts.get_user(claims["sub"]) do
      assign(conn, :current_user, user)
    else
      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{error: %{message: "Invalid or missing authentication token"}})
        |> halt()
    end
  end

  defp verify_token(token) do
    # Use your JWT library
    SnippetboxWeb.Token.verify(token)
  end
end
```

## Authorization Plugs

### Role-Based Access

```elixir
# File: lib/snippetbox_web/plugs/authorize.ex

defmodule SnippetboxWeb.Plugs.Authorize do
  import Plug.Conn
  import Phoenix.Controller

  @doc """
  Requires user to have specific role.
  """
  def require_role(conn, roles) when is_list(roles) do
    user = conn.assigns[:current_user]

    if user && user.role in roles do
      conn
    else
      conn
      |> put_status(:forbidden)
      |> put_view(SnippetboxWeb.ErrorHTML)
      |> render("403.html")
      |> halt()
    end
  end

  def require_role(conn, role), do: require_role(conn, [role])

  @doc """
  Requires admin role.
  """
  def require_admin(conn, _opts) do
    require_role(conn, [:admin])
  end

  @doc """
  Requires moderator or admin role.
  """
  def require_moderator(conn, _opts) do
    require_role(conn, [:admin, :moderator])
  end
end
```

### Resource-Based Authorization

```elixir
# File: lib/snippetbox_web/plugs/resource_auth.ex

defmodule SnippetboxWeb.Plugs.ResourceAuth do
  import Plug.Conn
  import Phoenix.Controller

  @doc """
  Loads resource and checks ownership.
  """
  def authorize_snippet(conn, _opts) do
    snippet_id = conn.params["id"]
    user = conn.assigns.current_user

    case Snippetbox.Snippets.get_snippet(snippet_id) do
      nil ->
        conn
        |> put_status(:not_found)
        |> put_view(SnippetboxWeb.ErrorHTML)
        |> render("404.html")
        |> halt()

      snippet ->
        if snippet.user_id == user.id || user.role == :admin do
          assign(conn, :snippet, snippet)
        else
          conn
          |> put_status(:forbidden)
          |> put_view(SnippetboxWeb.ErrorHTML)
          |> render("403.html")
          |> halt()
        end
    end
  end
end
```

## Request Transformation Plugs

### JSON Body Parser

```elixir
# Already included in Phoenix, but here's the pattern:
defmodule SnippetboxWeb.Plugs.JSONParser do
  @behaviour Plug
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    case get_req_header(conn, "content-type") do
      ["application/json" <> _] ->
        {:ok, body, conn} = read_body(conn)
        params = Jason.decode!(body)
        %{conn | body_params: params, params: Map.merge(conn.params, params)}

      _ ->
        conn
    end
  end
end
```

### Request ID Propagation

```elixir
defmodule SnippetboxWeb.Plugs.RequestId do
  @behaviour Plug
  import Plug.Conn

  def init(opts), do: Keyword.get(opts, :header, "x-request-id")

  def call(conn, header) do
    request_id = get_req_header(conn, header) |> List.first() || generate_id()

    conn
    |> assign(:request_id, request_id)
    |> put_resp_header(header, request_id)
  end

  defp generate_id do
    :crypto.strong_rand_bytes(16) |> Base.encode16(case: :lower)
  end
end
```

### IP Allowlist

```elixir
defmodule SnippetboxWeb.Plugs.IPAllowlist do
  @behaviour Plug
  import Plug.Conn
  import Phoenix.Controller

  def init(opts) do
    %{
      allowed_ips: Keyword.get(opts, :allowed_ips, []),
      allowed_ranges: Keyword.get(opts, :allowed_ranges, [])
    }
  end

  def call(conn, opts) do
    ip = conn.remote_ip

    if allowed?(ip, opts) do
      conn
    else
      conn
      |> put_status(:forbidden)
      |> json(%{error: "IP address not allowed"})
      |> halt()
    end
  end

  defp allowed?(ip, opts) do
    ip_string = :inet.ntoa(ip) |> to_string()
    ip_string in opts.allowed_ips || in_range?(ip, opts.allowed_ranges)
  end

  defp in_range?(ip, ranges) do
    Enum.any?(ranges, fn {network, mask} ->
      match_network?(ip, network, mask)
    end)
  end

  defp match_network?(ip, network, mask) do
    # Simplified - use proper CIDR matching in production
    false
  end
end
```

## Response Transformation Plugs

### Compression

```elixir
# Phoenix already includes Plug.Compress
plug Plug.Compress
```

### Cache Headers

```elixir
defmodule SnippetboxWeb.Plugs.CacheControl do
  @behaviour Plug
  import Plug.Conn

  def init(opts) do
    %{
      public: Keyword.get(opts, :public, false),
      max_age: Keyword.get(opts, :max_age, 0)
    }
  end

  def call(conn, %{public: public, max_age: max_age}) do
    visibility = if public, do: "public", else: "private"
    value = "#{visibility}, max-age=#{max_age}"

    put_resp_header(conn, "cache-control", value)
  end
end
```

### ETag Support

```elixir
defmodule SnippetboxWeb.Plugs.ETag do
  @behaviour Plug
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    register_before_send(conn, fn conn ->
      if conn.status == 200 && conn.resp_body do
        etag = generate_etag(conn.resp_body)
        conn = put_resp_header(conn, "etag", etag)

        case get_req_header(conn, "if-none-match") do
          [^etag] ->
            conn
            |> put_status(:not_modified)
            |> resp(304, "")

          _ ->
            conn
        end
      else
        conn
      end
    end)
  end

  defp generate_etag(body) do
    hash = :crypto.hash(:md5, body) |> Base.encode16(case: :lower)
    ~s("#{hash}")
  end
end
```

## Error Handling Plugs

### Global Error Handler

```elixir
defmodule SnippetboxWeb.Plugs.ErrorHandler do
  @behaviour Plug
  import Plug.Conn
  import Phoenix.Controller
  require Logger

  def init(opts), do: opts

  def call(conn, _opts) do
    conn
  rescue
    e in Ecto.NoResultsError ->
      Logger.warning("Resource not found: #{inspect(e)}")
      conn
      |> put_status(:not_found)
      |> put_view(SnippetboxWeb.ErrorHTML)
      |> render("404.html")
      |> halt()

    e ->
      Logger.error("Unhandled error: #{Exception.message(e)}")
      Logger.error(Exception.format(:error, e, __STACKTRACE__))
      conn
      |> put_status(:internal_server_error)
      |> put_view(SnippetboxWeb.ErrorHTML)
      |> render("500.html")
      |> halt()
  end
end
```

## Metrics and Monitoring Plugs

### Telemetry Events

```elixir
defmodule SnippetboxWeb.Plugs.Telemetry do
  @behaviour Plug

  def init(opts), do: opts

  def call(conn, _opts) do
    start = System.monotonic_time()

    :telemetry.execute(
      [:snippetbox, :request, :start],
      %{time: System.system_time()},
      %{conn: conn}
    )

    Plug.Conn.register_before_send(conn, fn conn ->
      stop = System.monotonic_time()
      duration = stop - start

      :telemetry.execute(
        [:snippetbox, :request, :stop],
        %{duration: duration},
        %{conn: conn}
      )

      conn
    end)
  end
end
```

> **FP Concept: Composable Middleware**
>
> Each plug pattern above is composable:
>
> ```elixir
> # Combine multiple concerns
> pipeline :protected_api do
>   plug :fetch_api_user
>   plug :require_role, [:admin]
>   plug :rate_limit, max_requests: 100
>   plug :request_logger
> end
> ```
>
> This is the power of functional composition - simple, focused functions that combine to create complex behavior.

## Summary

In this chapter, we covered:

- Session and token authentication
- Role and resource-based authorization
- Request transformation (parsing, validation)
- Response transformation (caching, compression)
- Error handling
- Metrics and telemetry

In the next chapter, we'll learn how to test plugs.
