# Chapter 12.1: LiveView Basics

LiveView processes maintain state and respond to events. In this chapter, we'll explore the LiveView lifecycle and fundamental patterns.

## Creating a LiveView

```elixir
# File: lib/snippetbox_web/live/counter_live.ex

defmodule SnippetboxWeb.CounterLive do
  use SnippetboxWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    {:ok, assign(socket, count: 0)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="text-center">
      <h1 class="text-4xl font-bold"><%= @count %></h1>
      <div class="mt-4 space-x-2">
        <button phx-click="decrement" class="btn">-</button>
        <button phx-click="increment" class="btn">+</button>
      </div>
    </div>
    """
  end

  @impl true
  def handle_event("increment", _params, socket) do
    {:noreply, update(socket, :count, &(&1 + 1))}
  end

  @impl true
  def handle_event("decrement", _params, socket) do
    {:noreply, update(socket, :count, &(&1 - 1))}
  end
end
```

## Router Setup

```elixir
# File: lib/snippetbox_web/router.ex

live_session :default, on_mount: [{SnippetboxWeb.UserAuth, :mount_current_user}] do
  scope "/", SnippetboxWeb do
    pipe_through :browser

    live "/counter", CounterLive
    live "/snippets", SnippetLive.Index, :index
    live "/snippets/new", SnippetLive.Index, :new
    live "/snippets/:id", SnippetLive.Show, :show
    live "/snippets/:id/edit", SnippetLive.Show, :edit
  end
end
```

## LiveView Lifecycle

```
1. HTTP Request → mount/3 (disconnected)
2. WebSocket connects → mount/3 (connected)
3. URL changes → handle_params/3
4. User events → handle_event/3
5. Server messages → handle_info/2
6. Re-render → render/1 (only changed parts)
```

### Mount

```elixir
@impl true
def mount(params, session, socket) do
  # params: URL parameters
  # session: Session data
  # socket: LiveView socket

  if connected?(socket) do
    # Only runs when WebSocket is connected
    Phoenix.PubSub.subscribe(Snippetbox.PubSub, "snippets")
  end

  {:ok, assign(socket, items: [])}
end
```

### Handle Params

```elixir
@impl true
def handle_params(params, _uri, socket) do
  {:noreply, apply_action(socket, socket.assigns.live_action, params)}
end

defp apply_action(socket, :index, _params) do
  socket
  |> assign(:page_title, "All Snippets")
  |> assign(:snippet, nil)
end

defp apply_action(socket, :new, _params) do
  socket
  |> assign(:page_title, "New Snippet")
  |> assign(:snippet, %Snippet{})
end

defp apply_action(socket, :edit, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)

  socket
  |> assign(:page_title, "Edit #{snippet.title}")
  |> assign(:snippet, snippet)
end
```

### Handle Event

```elixir
@impl true
def handle_event("search", %{"query" => query}, socket) do
  snippets = Snippets.search_snippets(query)
  {:noreply, assign(socket, snippets: snippets, query: query)}
end

def handle_event("delete", %{"id" => id}, socket) do
  snippet = Snippets.get_snippet!(id)
  {:ok, _} = Snippets.delete_snippet(snippet)

  {:noreply, stream_delete(socket, :snippets, snippet)}
end

def handle_event("sort", %{"column" => column}, socket) do
  snippets = Snippets.list_snippets(sort_by: column)
  {:noreply, stream(socket, :snippets, snippets, reset: true)}
end
```

### Handle Info

```elixir
@impl true
def handle_info({:snippet_created, snippet}, socket) do
  {:noreply, stream_insert(socket, :snippets, snippet, at: 0)}
end

def handle_info({:snippet_updated, snippet}, socket) do
  {:noreply, stream_insert(socket, :snippets, snippet)}
end

def handle_info({:snippet_deleted, snippet}, socket) do
  {:noreply, stream_delete(socket, :snippets, snippet)}
end
```

## Socket Assigns

### Basic Assigns

```elixir
# Set single assign
socket = assign(socket, :name, "value")

# Set multiple assigns
socket = assign(socket, name: "value", count: 0)

# Update existing assign
socket = update(socket, :count, &(&1 + 1))

# Access assigns
socket.assigns.name
```

### Temporary Assigns

For large lists that don't need to stay in memory:

```elixir
@impl true
def mount(_params, _session, socket) do
  {:ok, assign(socket, items: large_list()), temporary_assigns: [items: []]}
end
```

### Streams

For efficient list updates:

```elixir
@impl true
def mount(_params, _session, socket) do
  {:ok, stream(socket, :snippets, Snippets.list_snippets())}
end

# Insert at beginning
stream_insert(socket, :snippets, snippet, at: 0)

# Insert at end (default)
stream_insert(socket, :snippets, snippet)

# Update existing item
stream_insert(socket, :snippets, updated_snippet)

# Delete item
stream_delete(socket, :snippets, snippet)

# Reset entire stream
stream(socket, :snippets, new_list, reset: true)
```

## Event Bindings

### Click Events

```heex
<button phx-click="action">Click me</button>
<button phx-click="action" phx-value-id={@item.id}>Delete</button>
```

### Form Events

```heex
<form phx-submit="save" phx-change="validate">
  <input name="query" phx-debounce="300" />
</form>
```

### Focus Events

```heex
<input phx-focus="focus" phx-blur="blur" />
```

### Key Events

```heex
<div phx-window-keydown="keydown" phx-key="Escape">
  Press Escape to close
</div>
```

### Debounce and Throttle

```heex
<%# Debounce: wait for pause in typing %>
<input phx-change="search" phx-debounce="300" />

<%# Throttle: fire at most every N ms %>
<div phx-click="scroll" phx-throttle="500">
```

## Navigation

### Live Navigation

```heex
<%# Stay in same LiveView, call handle_params %>
<.link patch={~p"/snippets?page=2"}>Page 2</.link>

<%# Navigate to different LiveView %>
<.link navigate={~p"/settings"}>Settings</.link>

<%# Regular link (full page load) %>
<.link href={~p"/logout"} method="delete">Logout</.link>
```

### Programmatic Navigation

```elixir
# Patch current LiveView
{:noreply, push_patch(socket, to: ~p"/snippets?page=2")}

# Navigate to different LiveView
{:noreply, push_navigate(socket, to: ~p"/settings")}

# Redirect (full page load)
{:noreply, redirect(socket, to: ~p"/login")}
```

## Complete Example: Snippet Index

```elixir
# File: lib/snippetbox_web/live/snippet_live/index.ex

defmodule SnippetboxWeb.SnippetLive.Index do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Snippets
  alias Snippetbox.Snippets.Snippet

  @impl true
  def mount(_params, _session, socket) do
    if connected?(socket) do
      Phoenix.PubSub.subscribe(Snippetbox.PubSub, "snippets")
    end

    {:ok, stream(socket, :snippets, Snippets.list_snippets())}
  end

  @impl true
  def handle_params(params, _url, socket) do
    {:noreply, apply_action(socket, socket.assigns.live_action, params)}
  end

  defp apply_action(socket, :index, _params) do
    socket
    |> assign(:page_title, "Snippets")
    |> assign(:snippet, nil)
  end

  defp apply_action(socket, :new, _params) do
    socket
    |> assign(:page_title, "New Snippet")
    |> assign(:snippet, %Snippet{})
  end

  defp apply_action(socket, :edit, %{"id" => id}) do
    snippet = Snippets.get_snippet!(id)

    socket
    |> assign(:page_title, "Edit #{snippet.title}")
    |> assign(:snippet, snippet)
  end

  @impl true
  def handle_event("delete", %{"id" => id}, socket) do
    snippet = Snippets.get_snippet!(id)
    {:ok, _} = Snippets.delete_snippet(snippet)

    {:noreply, stream_delete(socket, :snippets, snippet)}
  end

  @impl true
  def handle_info({:snippet_created, snippet}, socket) do
    {:noreply, stream_insert(socket, :snippets, snippet, at: 0)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <.header>
      Snippets
      <:actions>
        <.link patch={~p"/snippets/new"}>
          <.button>New Snippet</.button>
        </.link>
      </:actions>
    </.header>

    <.table id="snippets" rows={@streams.snippets} row_click={fn {_id, snippet} -> JS.navigate(~p"/snippets/#{snippet}") end}>
      <:col :let={{_id, snippet}} label="Title"><%= snippet.title %></:col>
      <:col :let={{_id, snippet}} label="Language"><%= snippet.language %></:col>
      <:col :let={{_id, snippet}} label="Created"><%= format_date(snippet.inserted_at) %></:col>
      <:action :let={{_id, snippet}}>
        <.link patch={~p"/snippets/#{snippet}/edit"}>Edit</.link>
      </:action>
      <:action :let={{id, snippet}}>
        <.link
          phx-click={JS.push("delete", value: %{id: snippet.id}) |> hide("##{id}")}
          data-confirm="Are you sure?"
        >
          Delete
        </.link>
      </:action>
    </.table>

    <.modal :if={@live_action in [:new, :edit]} id="snippet-modal" show on_cancel={JS.patch(~p"/snippets")}>
      <.live_component
        module={SnippetboxWeb.SnippetLive.FormComponent}
        id={@snippet.id || :new}
        title={@page_title}
        action={@live_action}
        snippet={@snippet}
        patch={~p"/snippets"}
      />
    </.modal>
    """
  end

  defp format_date(datetime) do
    Calendar.strftime(datetime, "%B %d, %Y")
  end
end
```

> **FP Concept: Stateful Processes**
>
> LiveViews are stateful processes, but state changes are explicit:
>
> ```elixir
> # State is in socket.assigns
> # Changes are explicit transformations
> socket
> |> assign(:count, 0)           # Set initial
> |> update(:count, &(&1 + 1))   # Transform existing
>
> # Each callback returns new socket
> {:noreply, new_socket}
> ```
>
> While stateful, the model is still functional—state changes through explicit transformations.

## Summary

In this chapter, we learned:

- Creating LiveView modules
- Lifecycle callbacks (mount, handle_params, handle_event, handle_info)
- Socket assigns and streams
- Event bindings (click, form, focus, key)
- Navigation (patch, navigate, redirect)
- Complete LiveView index example

In the next chapter, we'll explore LiveView forms.
