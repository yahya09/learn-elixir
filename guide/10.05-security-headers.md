# Chapter 10.5: Security Headers

HTTP security headers provide an additional layer of protection. In this chapter, we'll explore the security headers Phoenix provides and how to configure them.

## Phoenix Default Headers

### put_secure_browser_headers

Phoenix includes security headers by default:

```elixir
# File: lib/snippetbox_web/router.ex

pipeline :browser do
  # ...
  plug :put_secure_browser_headers
end
```

This adds:

```http
x-frame-options: SAMEORIGIN
x-content-type-options: nosniff
x-xss-protection: 1; mode=block
x-download-options: noopen
x-permitted-cross-domain-policies: none
cross-origin-window-policy: deny
```

### Customizing Headers

```elixir
plug :put_secure_browser_headers, %{
  "content-security-policy" => "default-src 'self'",
  "x-frame-options" => "DENY"
}
```

## Essential Security Headers

### Content-Security-Policy (CSP)

Controls which resources can be loaded:

```elixir
# File: lib/snippetbox_web/plugs/security_headers.ex

defmodule SnippetboxWeb.Plugs.SecurityHeaders do
  import Plug.Conn

  @csp [
    "default-src 'self'",
    "script-src 'self'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "font-src 'self'",
    "connect-src 'self' wss://#{Application.compile_env(:snippetbox, :host)}",
    "frame-ancestors 'none'",
    "base-uri 'self'",
    "form-action 'self'"
  ] |> Enum.join("; ")

  def init(opts), do: opts

  def call(conn, _opts) do
    put_resp_header(conn, "content-security-policy", @csp)
  end
end
```

### CSP Directives

| Directive | Purpose |
|-----------|---------|
| `default-src` | Fallback for other directives |
| `script-src` | JavaScript sources |
| `style-src` | CSS sources |
| `img-src` | Image sources |
| `font-src` | Font sources |
| `connect-src` | AJAX, WebSocket, etc. |
| `frame-ancestors` | Who can embed this page |
| `form-action` | Form submission targets |
| `base-uri` | Base URL for relative URLs |
| `upgrade-insecure-requests` | Upgrade HTTP to HTTPS |

### X-Frame-Options

Prevents clickjacking:

```elixir
# Options:
# DENY - Never allow framing
# SAMEORIGIN - Only same origin can frame
# ALLOW-FROM uri - Specific origin (deprecated)

put_resp_header(conn, "x-frame-options", "DENY")
```

### X-Content-Type-Options

Prevents MIME type sniffing:

```elixir
put_resp_header(conn, "x-content-type-options", "nosniff")
```

### Strict-Transport-Security (HSTS)

Forces HTTPS:

```elixir
# Only over HTTPS connections
put_resp_header(conn, "strict-transport-security",
  "max-age=63072000; includeSubDomains; preload")
```

### Referrer-Policy

Controls Referer header:

```elixir
# Options:
# no-referrer - Never send
# same-origin - Only same origin
# strict-origin - HTTPS→HTTPS only
# strict-origin-when-cross-origin - Full URL same-origin, origin only cross-origin

put_resp_header(conn, "referrer-policy", "strict-origin-when-cross-origin")
```

### Permissions-Policy

Controls browser features:

```elixir
put_resp_header(conn, "permissions-policy",
  "geolocation=(), microphone=(), camera=()")
```

## Complete Security Headers Plug

```elixir
# File: lib/snippetbox_web/plugs/security_headers.ex

defmodule SnippetboxWeb.Plugs.SecurityHeaders do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    conn
    |> put_csp_header()
    |> put_resp_header("x-frame-options", "DENY")
    |> put_resp_header("x-content-type-options", "nosniff")
    |> put_resp_header("x-xss-protection", "0")  # Disabled, CSP is better
    |> put_resp_header("referrer-policy", "strict-origin-when-cross-origin")
    |> put_resp_header("permissions-policy", permissions_policy())
    |> maybe_put_hsts(conn)
  end

  defp put_csp_header(conn) do
    csp = build_csp(conn)
    put_resp_header(conn, "content-security-policy", csp)
  end

  defp build_csp(conn) do
    host = conn.host

    [
      "default-src 'self'",
      "script-src 'self'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' https://fonts.gstatic.com",
      "connect-src 'self' wss://#{host}",
      "frame-ancestors 'none'",
      "base-uri 'self'",
      "form-action 'self'",
      "upgrade-insecure-requests"
    ]
    |> Enum.join("; ")
  end

  defp permissions_policy do
    [
      "accelerometer=()",
      "camera=()",
      "geolocation=()",
      "gyroscope=()",
      "magnetometer=()",
      "microphone=()",
      "payment=()",
      "usb=()"
    ]
    |> Enum.join(", ")
  end

  defp maybe_put_hsts(conn, _original_conn) do
    if conn.scheme == :https do
      put_resp_header(conn, "strict-transport-security",
        "max-age=63072000; includeSubDomains")
    else
      conn
    end
  end
end
```

## Environment-Specific Configuration

```elixir
# File: lib/snippetbox_web/plugs/security_headers.ex

defmodule SnippetboxWeb.Plugs.SecurityHeaders do
  import Plug.Conn

  @env Mix.env()

  def init(opts), do: opts

  def call(conn, _opts) do
    conn
    |> put_csp_header()
    |> put_common_headers()
  end

  defp put_csp_header(conn) do
    csp = if @env == :dev, do: dev_csp(), else: prod_csp(conn)
    put_resp_header(conn, "content-security-policy", csp)
  end

  defp dev_csp do
    # More permissive for development
    [
      "default-src 'self' 'unsafe-inline' 'unsafe-eval'",
      "connect-src 'self' ws://localhost:* wss://localhost:*",
      "img-src 'self' data: blob:"
    ]
    |> Enum.join("; ")
  end

  defp prod_csp(conn) do
    [
      "default-src 'self'",
      "script-src 'self'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "connect-src 'self' wss://#{conn.host}",
      "frame-ancestors 'none'",
      "upgrade-insecure-requests"
    ]
    |> Enum.join("; ")
  end

  defp put_common_headers(conn) do
    conn
    |> put_resp_header("x-frame-options", "DENY")
    |> put_resp_header("x-content-type-options", "nosniff")
    |> put_resp_header("referrer-policy", "strict-origin-when-cross-origin")
  end
end
```

## CSP Reporting

### Report-Only Mode

Test CSP without blocking:

```elixir
put_resp_header(conn, "content-security-policy-report-only", csp_policy())
```

### Violation Reporting

```elixir
defp build_csp(conn) do
  base_csp() <> "; report-uri /csp-reports"
end

# Controller to receive reports
defmodule SnippetboxWeb.CSPReportController do
  use SnippetboxWeb, :controller
  require Logger

  def create(conn, %{"csp-report" => report}) do
    Logger.warning("CSP Violation: #{inspect(report)}")

    # Optionally store in database for analysis
    # CSPReports.create_report(report)

    send_resp(conn, 204, "")
  end
end
```

## CORS Headers

For APIs accessed from other origins:

```elixir
# File: lib/snippetbox_web/plugs/cors.ex

defmodule SnippetboxWeb.Plugs.CORS do
  import Plug.Conn

  @allowed_origins Application.compile_env(:snippetbox, :cors_origins, ["*"])

  def init(opts), do: opts

  def call(conn, _opts) do
    origin = get_req_header(conn, "origin") |> List.first()

    if allowed_origin?(origin) do
      conn
      |> put_resp_header("access-control-allow-origin", origin || "*")
      |> put_resp_header("access-control-allow-methods", "GET, POST, PUT, DELETE, OPTIONS")
      |> put_resp_header("access-control-allow-headers", "content-type, authorization")
      |> put_resp_header("access-control-max-age", "86400")
      |> handle_preflight()
    else
      conn
    end
  end

  defp allowed_origin?(nil), do: false
  defp allowed_origin?(origin) do
    "*" in @allowed_origins || origin in @allowed_origins
  end

  defp handle_preflight(%{method: "OPTIONS"} = conn) do
    conn
    |> send_resp(204, "")
    |> halt()
  end
  defp handle_preflight(conn), do: conn
end
```

## Testing Security Headers

```elixir
# File: test/snippetbox_web/plugs/security_headers_test.exs

defmodule SnippetboxWeb.Plugs.SecurityHeadersTest do
  use SnippetboxWeb.ConnCase

  describe "security headers" do
    test "includes Content-Security-Policy", %{conn: conn} do
      conn = get(conn, ~p"/")

      csp = get_resp_header(conn, "content-security-policy") |> List.first()

      assert csp =~ "default-src"
      assert csp =~ "script-src"
      assert csp =~ "frame-ancestors 'none'"
    end

    test "includes X-Frame-Options", %{conn: conn} do
      conn = get(conn, ~p"/")

      assert get_resp_header(conn, "x-frame-options") == ["DENY"]
    end

    test "includes X-Content-Type-Options", %{conn: conn} do
      conn = get(conn, ~p"/")

      assert get_resp_header(conn, "x-content-type-options") == ["nosniff"]
    end

    test "includes Referrer-Policy", %{conn: conn} do
      conn = get(conn, ~p"/")

      policy = get_resp_header(conn, "referrer-policy") |> List.first()
      assert policy =~ "strict-origin"
    end
  end
end
```

## Security Headers Checklist

| Header | Value | Protection |
|--------|-------|------------|
| Content-Security-Policy | Various directives | XSS, injection |
| X-Frame-Options | DENY | Clickjacking |
| X-Content-Type-Options | nosniff | MIME confusion |
| Strict-Transport-Security | max-age=... | Downgrade attacks |
| Referrer-Policy | strict-origin... | Information leak |
| Permissions-Policy | Various | Feature abuse |

> **FP Concept: Headers as Middleware**
>
> Security headers are a perfect fit for the plug/middleware pattern:
>
> ```elixir
> conn
> |> put_csp_header()
> |> put_frame_options()
> |> put_content_type_options()
> # Each transformation is independent and composable
> ```
>
> Headers don't modify the response body—they're metadata that transforms how browsers handle the response.

## Summary

In this chapter, we learned:

- Phoenix's default security headers
- Content-Security-Policy configuration
- X-Frame-Options for clickjacking prevention
- HSTS for forcing HTTPS
- Referrer-Policy for privacy
- Permissions-Policy for feature control
- CORS headers for API access
- Testing security headers

In the next chapter, we'll explore common vulnerabilities and how to prevent them.
