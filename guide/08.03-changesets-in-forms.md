# Chapter 8.3: Changesets in Forms

Ecto changesets provide powerful validation and error handling for forms. In this chapter, we'll explore how changesets integrate with Phoenix forms.

## Changeset Basics

### Creating a Changeset for Forms

```elixir
# File: lib/snippetbox/snippets/snippet.ex

defmodule Snippetbox.Snippets.Snippet do
  use Ecto.Schema
  import Ecto.Changeset

  schema "snippets" do
    field :title, :string
    field :content, :string
    field :language, :string
    field :public, :boolean, default: true
    field :expires_at, :utc_datetime

    belongs_to :user, Snippetbox.Accounts.User

    timestamps()
  end

  @doc """
  Changeset for creating/updating snippets.
  """
  def changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :language, :public, :expires_at])
    |> validate_required([:title, :content])
    |> validate_length(:title, min: 3, max: 100)
    |> validate_length(:content, min: 1, max: 50_000)
    |> validate_inclusion(:language, supported_languages())
  end

  defp supported_languages do
    ~w(elixir javascript python ruby go rust typescript)
  end
end
```

### Context Functions

```elixir
# File: lib/snippetbox/snippets.ex

defmodule Snippetbox.Snippets do
  alias Snippetbox.Repo
  alias Snippetbox.Snippets.Snippet

  @doc """
  Returns a changeset for tracking snippet changes.
  Used in forms to build the initial form state.
  """
  def change_snippet(%Snippet{} = snippet, attrs \\ %{}) do
    Snippet.changeset(snippet, attrs)
  end

  @doc """
  Creates a snippet.
  """
  def create_snippet(attrs) do
    %Snippet{}
    |> Snippet.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Updates a snippet.
  """
  def update_snippet(%Snippet{} = snippet, attrs) do
    snippet
    |> Snippet.changeset(attrs)
    |> Repo.update()
  end
end
```

## Controller Integration

### New Action (Empty Form)

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def new(conn, _params) do
  changeset = Snippets.change_snippet(%Snippet{})
  render(conn, :new, changeset: changeset)
end
```

### Create Action (Process Form)

```elixir
def create(conn, %{"snippet" => snippet_params}) do
  case Snippets.create_snippet(snippet_params) do
    {:ok, snippet} ->
      conn
      |> put_flash(:info, "Snippet created successfully.")
      |> redirect(to: ~p"/snippets/#{snippet}")

    {:error, %Ecto.Changeset{} = changeset} ->
      # Re-render form with errors
      render(conn, :new, changeset: changeset)
  end
end
```

### Edit Action (Populated Form)

```elixir
def edit(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)
  changeset = Snippets.change_snippet(snippet)
  render(conn, :edit, snippet: snippet, changeset: changeset)
end
```

### Update Action

```elixir
def update(conn, %{"id" => id, "snippet" => snippet_params}) do
  snippet = Snippets.get_snippet!(id)

  case Snippets.update_snippet(snippet, snippet_params) do
    {:ok, snippet} ->
      conn
      |> put_flash(:info, "Snippet updated successfully.")
      |> redirect(to: ~p"/snippets/#{snippet}")

    {:error, %Ecto.Changeset{} = changeset} ->
      render(conn, :edit, snippet: snippet, changeset: changeset)
  end
end
```

## Form Template with Changeset

```heex
<%# File: lib/snippetbox_web/controllers/snippet_html/new.html.heex %>

<.header>
  New Snippet
</.header>

<.form for={@changeset} action={~p"/snippets"}>
  <.input field={@form[:title]} label="Title" />
  <.input field={@form[:content]} type="textarea" label="Content" />
  <.input
    field={@form[:language]}
    type="select"
    label="Language"
    prompt="Select..."
    options={~w(elixir javascript python ruby go rust typescript)}
  />
  <.input field={@form[:public]} type="checkbox" label="Public" />

  <.button>Create Snippet</.button>
</.form>
```

## How Errors Are Displayed

### Default Error Component

```elixir
# In core_components.ex

slot :inner_block, required: true

def error(assigns) do
  ~H"""
  <p class="mt-3 flex gap-3 text-sm leading-6 text-rose-600 phx-no-feedback:hidden">
    <.icon name="hero-exclamation-circle-mini" class="mt-0.5 h-5 w-5 flex-none" />
    <%= render_slot(@inner_block) %>
  </p>
  """
end
```

### Error Translation

```elixir
# In core_components.ex

def translate_error({msg, opts}) do
  # Handles interpolation like "should be at least %{count} characters"
  Enum.reduce(opts, msg, fn {key, value}, acc ->
    String.replace(acc, "%{#{key}}", fn _ -> to_string(value) end)
  end)
end
```

### Changeset Errors Structure

```elixir
# When validation fails, changeset contains errors:
%Ecto.Changeset{
  valid?: false,
  errors: [
    title: {"can't be blank", [validation: :required]},
    content: {"should be at least %{count} character(s)", [count: 1, validation: :length, kind: :min]}
  ]
}
```

## Validation Types

### Required Fields

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :language])
  |> validate_required([:title, :content], message: "is required")
end
```

### Length Validation

```elixir
|> validate_length(:title, min: 3, message: "must be at least 3 characters")
|> validate_length(:title, max: 100, message: "must be at most 100 characters")
|> validate_length(:content, min: 1, max: 50_000)
```

### Format Validation

```elixir
|> validate_format(:email, ~r/^[^\s]+@[^\s]+$/, message: "must be a valid email")
|> validate_format(:username, ~r/^[a-z0-9_]+$/, message: "only lowercase letters, numbers, and underscores")
```

### Inclusion/Exclusion

```elixir
|> validate_inclusion(:language, ~w(elixir javascript python))
|> validate_exclusion(:username, ~w(admin root system))
```

### Number Validation

```elixir
|> validate_number(:expires_in, greater_than: 0, less_than_or_equal_to: 365)
```

### Custom Validation

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content])
  |> validate_required([:title, :content])
  |> validate_no_profanity(:title)
  |> validate_no_profanity(:content)
end

defp validate_no_profanity(changeset, field) do
  validate_change(changeset, field, fn _, value ->
    if contains_profanity?(value) do
      [{field, "contains inappropriate content"}]
    else
      []
    end
  end)
end

defp contains_profanity?(text) do
  # Your profanity detection logic
  false
end
```

## Conditional Validation

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :public, :password])
  |> validate_required([:title, :content])
  |> maybe_require_password()
end

defp maybe_require_password(changeset) do
  if get_field(changeset, :public) == false do
    validate_required(changeset, [:password], message: "required for private snippets")
  else
    changeset
  end
end
```

## Multiple Changesets

### Different Changesets for Different Actions

```elixir
# File: lib/snippetbox/snippets/snippet.ex

def create_changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :language])
  |> validate_required([:title, :content])
  |> validate_length(:title, min: 3, max: 100)
end

def update_changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :language, :public])
  |> validate_required([:title, :content])
  |> validate_length(:title, min: 3, max: 100)
end

def publish_changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:published_at])
  |> put_change(:published_at, DateTime.utc_now())
end
```

## Nested Forms with Associations

### Schema with Association

```elixir
defmodule Snippetbox.Snippets.Snippet do
  use Ecto.Schema
  import Ecto.Changeset

  schema "snippets" do
    field :title, :string
    field :content, :string

    has_many :tags, Snippetbox.Snippets.Tag, on_replace: :delete

    timestamps()
  end

  def changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content])
    |> validate_required([:title, :content])
    |> cast_assoc(:tags, with: &Snippetbox.Snippets.Tag.changeset/2)
  end
end
```

### Nested Form Template

```heex
<.form for={@changeset} action={~p"/snippets"}>
  <.input field={@form[:title]} label="Title" />
  <.input field={@form[:content]} type="textarea" label="Content" />

  <fieldset class="mt-4">
    <legend>Tags</legend>
    <.inputs_for :let={tag_form} field={@form[:tags]}>
      <.input field={tag_form[:name]} label="Tag Name" />
    </.inputs_for>
  </fieldset>

  <.button>Save</.button>
</.form>
```

## Displaying All Errors

### Error Summary Component

```elixir
# File: lib/snippetbox_web/components/core_components.ex

attr :changeset, Ecto.Changeset, required: true
attr :title, :string, default: "Please fix the following errors:"

def error_summary(assigns) do
  ~H"""
  <div :if={@changeset.action} class="bg-red-50 border border-red-200 rounded p-4 mb-6">
    <h3 class="text-red-800 font-medium"><%= @title %></h3>
    <ul class="mt-2 list-disc list-inside text-red-700">
      <li :for={{field, errors} <- @changeset.errors}>
        <strong><%= humanize(field) %>:</strong>
        <%= Enum.map_join(errors, ", ", &translate_error/1) %>
      </li>
    </ul>
  </div>
  """
end

defp humanize(atom) when is_atom(atom) do
  atom
  |> Atom.to_string()
  |> String.replace("_", " ")
  |> String.capitalize()
end
```

Usage:

```heex
<.error_summary changeset={@changeset} />

<.form for={@changeset} action={~p"/snippets"}>
  <%# ... %>
</.form>
```

> **FP Concept: Validation as Data**
>
> Ecto represents validation state as data:
>
> ```elixir
> # Changeset is just data describing the transformation
> %Ecto.Changeset{
>   data: %Snippet{},           # Original data
>   params: %{"title" => "..."},# Input parameters
>   changes: %{title: "..."},   # Applied changes
>   errors: [],                 # Validation errors
>   valid?: true                # Overall validity
> }
> ```
>
> This makes validation:
> - Inspectable (you can examine the state)
> - Composable (chain validations together)
> - Testable (just check the changeset data)
>
> **Further Reading**:
> - [Ecto Changeset Documentation](https://hexdocs.pm/ecto/Ecto.Changeset.html)

## Summary

In this chapter, we learned:

- Creating changesets for forms
- Controller patterns for create/edit
- How form errors are displayed
- Various validation types
- Conditional validation
- Multiple changesets for different actions
- Nested forms with associations
- Displaying error summaries

In the next chapter, we'll explore file uploads.
