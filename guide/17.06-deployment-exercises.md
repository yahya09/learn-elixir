# Chapter 17.6: Deployment and Testing Exercises

These exercises reinforce concepts from Chapters 13-14 covering testing, deployment, and production configuration.

## Exercise 1: Property-Based Testing

Write property-based tests for a string utility module.

```elixir
# File: test/snippetbox/string_utils_property_test.exs

defmodule Snippetbox.StringUtilsPropertyTest do
  use ExUnit.Case
  use ExUnitProperties

  # Test properties:
  # 1. slugify always produces valid slugs
  # 2. truncate never exceeds max length
  # 3. split and join are inverse operations
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule Snippetbox.StringUtilsPropertyTest do
  use ExUnit.Case
  use ExUnitProperties

  alias Snippetbox.StringUtils

  property "slugify produces valid slugs" do
    check all string <- string(:printable) do
      slug = StringUtils.slugify(string)

      # Slugs contain only lowercase letters, numbers, and hyphens
      assert slug =~ ~r/^[a-z0-9-]*$/

      # No consecutive hyphens
      refute slug =~ ~r/--/

      # No leading or trailing hyphens
      refute String.starts_with?(slug, "-")
      refute String.ends_with?(slug, "-") or slug == ""
    end
  end

  property "truncate respects max length" do
    check all string <- string(:printable),
              max_length <- integer(1..1000) do
      result = StringUtils.truncate(string, max_length)

      # Result is never longer than max_length + ellipsis (3)
      assert String.length(result) <= max_length + 3

      # If original was short enough, it's unchanged
      if String.length(string) <= max_length do
        assert result == string
      end
    end
  end

  property "split and join are inverses" do
    check all parts <- list_of(string(:alphanumeric, min_length: 1)),
              separator <- string(:alphanumeric, min_length: 1, max_length: 3),
              length(parts) > 0 do
      joined = Enum.join(parts, separator)
      split = String.split(joined, separator)

      assert split == parts
    end
  end

  property "word count is always non-negative" do
    check all string <- string(:printable) do
      count = StringUtils.word_count(string)
      assert count >= 0
    end
  end
end
```
</details>

## Exercise 2: Test Fixtures with ExMachina

Create comprehensive test fixtures.

```elixir
# File: test/support/factory.ex

defmodule Snippetbox.Factory do
  use ExMachina.Ecto, repo: Snippetbox.Repo

  # Create factories for:
  # - User (with traits: admin, confirmed, unconfirmed)
  # - Snippet (with associations)
  # - Comment
  # - Tag
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule Snippetbox.Factory do
  use ExMachina.Ecto, repo: Snippetbox.Repo

  alias Snippetbox.Accounts.User
  alias Snippetbox.Snippets.{Snippet, Tag}
  alias Snippetbox.Comments.Comment

  def user_factory do
    %User{
      email: sequence(:email, &"user#{&1}@example.com"),
      name: sequence(:name, &"User #{&1}"),
      hashed_password: Bcrypt.hash_pwd_salt("password123"),
      confirmed_at: NaiveDateTime.utc_now() |> NaiveDateTime.truncate(:second)
    }
  end

  def admin_factory do
    struct!(
      user_factory(),
      %{admin: true}
    )
  end

  def unconfirmed_user_factory do
    struct!(
      user_factory(),
      %{confirmed_at: nil}
    )
  end

  def snippet_factory do
    %Snippet{
      title: sequence(:title, &"Snippet #{&1}"),
      content: "defmodule Example do\n  def hello, do: :world\nend",
      language: Enum.random(~w(elixir javascript python ruby)),
      public: true,
      user: build(:user)
    }
  end

  def private_snippet_factory do
    struct!(
      snippet_factory(),
      %{public: false}
    )
  end

  def snippet_with_tags_factory do
    struct!(
      snippet_factory(),
      %{tags: build_list(3, :tag)}
    )
  end

  def tag_factory do
    %Tag{
      name: sequence(:tag, &"tag-#{&1}")
    }
  end

  def comment_factory do
    %Comment{
      content: sequence(:content, &"This is comment #{&1}"),
      snippet: build(:snippet),
      user: build(:user)
    }
  end

  def anonymous_comment_factory do
    struct!(
      comment_factory(),
      %{
        user: nil,
        author_name: "Anonymous",
        author_email: sequence(:email, &"anon#{&1}@example.com")
      }
    )
  end
end

# Usage in tests:
# user = insert(:user)
# admin = insert(:admin)
# snippet = insert(:snippet, user: user)
# snippet_with_tags = insert(:snippet_with_tags)
```
</details>

## Exercise 3: Controller Test with Mocking

Test a controller that calls external services.

```elixir
# File: test/snippetbox_web/controllers/github_import_controller_test.exs

defmodule SnippetboxWeb.GithubImportControllerTest do
  use SnippetboxWeb.ConnCase

  # Test the import flow:
  # 1. Mock GitHub API responses
  # 2. Test success case
  # 3. Test API error handling
  # 4. Test rate limiting
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.GithubImportControllerTest do
  use SnippetboxWeb.ConnCase

  import Mox

  setup :verify_on_exit!

  setup %{conn: conn} do
    user = insert(:user)
    conn = log_in_user(conn, user)
    %{conn: conn, user: user}
  end

  describe "create" do
    test "imports gist successfully", %{conn: conn} do
      expect(Snippetbox.Github.MockClient, :get_gist, fn "abc123" ->
        {:ok, %{
          description: "My Gist",
          files: %{
            "example.ex" => %{
              content: "defmodule Example do\nend",
              language: "Elixir"
            }
          }
        }}
      end)

      conn = post(conn, ~p"/import/github", %{gist_id: "abc123"})

      assert redirected_to(conn) =~ "/snippets/"
      assert get_flash(conn, :info) =~ "imported"
    end

    test "handles gist not found", %{conn: conn} do
      expect(Snippetbox.Github.MockClient, :get_gist, fn "invalid" ->
        {:error, :not_found}
      end)

      conn = post(conn, ~p"/import/github", %{gist_id: "invalid"})

      assert html_response(conn, 200) =~ "Gist not found"
    end

    test "handles rate limiting", %{conn: conn} do
      expect(Snippetbox.Github.MockClient, :get_gist, fn _ ->
        {:error, :rate_limited}
      end)

      conn = post(conn, ~p"/import/github", %{gist_id: "abc123"})

      assert html_response(conn, 200) =~ "rate limit"
    end

    test "handles API errors gracefully", %{conn: conn} do
      expect(Snippetbox.Github.MockClient, :get_gist, fn _ ->
        {:error, :server_error}
      end)

      conn = post(conn, ~p"/import/github", %{gist_id: "abc123"})

      assert html_response(conn, 200) =~ "try again"
    end
  end
end
```
</details>

## Exercise 4: LiveView Integration Test

Write comprehensive tests for a LiveView form.

```elixir
# File: test/snippetbox_web/live/snippet_form_live_test.exs

defmodule SnippetboxWeb.SnippetFormLiveTest do
  use SnippetboxWeb.ConnCase

  import Phoenix.LiveViewTest

  # Test:
  # 1. Form rendering
  # 2. Real-time validation
  # 3. Successful submission
  # 4. Error handling
  # 5. Navigation after submit
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.SnippetFormLiveTest do
  use SnippetboxWeb.ConnCase

  import Phoenix.LiveViewTest

  setup %{conn: conn} do
    user = insert(:user)
    %{conn: log_in_user(conn, user), user: user}
  end

  describe "new snippet form" do
    test "renders form", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/snippets/new")

      assert html =~ "New Snippet"
      assert has_element?(view, "form#snippet-form")
      assert has_element?(view, "input[name='snippet[title]']")
      assert has_element?(view, "textarea[name='snippet[content]']")
    end

    test "validates form in real-time", %{conn: conn} do
      {:ok, view, _html} = live(conn, ~p"/snippets/new")

      # Empty title shows error
      view
      |> form("#snippet-form", snippet: %{title: ""})
      |> render_change()

      assert has_element?(view, ".phx-feedback-for-title", "can't be blank")

      # Valid title clears error
      view
      |> form("#snippet-form", snippet: %{title: "Valid Title"})
      |> render_change()

      refute has_element?(view, ".phx-feedback-for-title")
    end

    test "creates snippet on valid submit", %{conn: conn} do
      {:ok, view, _html} = live(conn, ~p"/snippets/new")

      {:ok, conn} =
        view
        |> form("#snippet-form", snippet: %{
          title: "Test Snippet",
          content: "defmodule Test do\nend",
          language: "elixir"
        })
        |> render_submit()
        |> follow_redirect(conn)

      assert html_response(conn, 200) =~ "Test Snippet"
      assert html_response(conn, 200) =~ "created successfully"
    end

    test "shows errors on invalid submit", %{conn: conn} do
      {:ok, view, _html} = live(conn, ~p"/snippets/new")

      view
      |> form("#snippet-form", snippet: %{title: "", content: ""})
      |> render_submit()

      assert has_element?(view, ".phx-feedback-for-title")
      assert has_element?(view, ".phx-feedback-for-content")
    end
  end

  describe "edit snippet form" do
    test "loads existing data", %{conn: conn, user: user} do
      snippet = insert(:snippet, user: user, title: "Original Title")

      {:ok, view, html} = live(conn, ~p"/snippets/#{snippet}/edit")

      assert html =~ "Edit"
      assert has_element?(view, "input[value='Original Title']")
    end

    test "updates snippet", %{conn: conn, user: user} do
      snippet = insert(:snippet, user: user)

      {:ok, view, _html} = live(conn, ~p"/snippets/#{snippet}/edit")

      {:ok, conn} =
        view
        |> form("#snippet-form", snippet: %{title: "Updated Title"})
        |> render_submit()
        |> follow_redirect(conn)

      assert html_response(conn, 200) =~ "Updated Title"
    end
  end
end
```
</details>

## Exercise 5: Release Configuration

Create a complete release configuration.

```elixir
# Requirements:
# 1. Configure runtime.exs for production
# 2. Create Release module with migrations
# 3. Add health check endpoint
# 4. Configure logging for production
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
# config/runtime.exs
import Config

if config_env() == :prod do
  database_url =
    System.get_env("DATABASE_URL") ||
      raise "DATABASE_URL not set"

  config :snippetbox, Snippetbox.Repo,
    url: database_url,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),
    ssl: System.get_env("DATABASE_SSL") == "true"

  secret_key_base =
    System.get_env("SECRET_KEY_BASE") ||
      raise "SECRET_KEY_BASE not set"

  config :snippetbox, SnippetboxWeb.Endpoint,
    url: [host: System.get_env("PHX_HOST"), port: 443, scheme: "https"],
    http: [port: String.to_integer(System.get_env("PORT") || "4000")],
    secret_key_base: secret_key_base,
    server: true

  config :logger,
    level: String.to_atom(System.get_env("LOG_LEVEL") || "info")
end

# lib/snippetbox/release.ex
defmodule Snippetbox.Release do
  @app :snippetbox

  def migrate do
    load_app()

    for repo <- repos() do
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, all: true))
    end
  end

  def rollback(repo, version) do
    load_app()
    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :down, to: version))
  end

  def seed do
    load_app()

    for repo <- repos() do
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, fn _ ->
        seeds_file = Path.join([:code.priv_dir(@app), "repo", "seeds.exs"])
        if File.exists?(seeds_file), do: Code.eval_file(seeds_file)
      end)
    end
  end

  defp repos, do: Application.fetch_env!(@app, :ecto_repos)
  defp load_app, do: Application.load(@app)
end

# lib/snippetbox_web/controllers/health_controller.ex
defmodule SnippetboxWeb.HealthController do
  use SnippetboxWeb, :controller

  def live(conn, _params) do
    json(conn, %{status: "ok", timestamp: DateTime.utc_now()})
  end

  def ready(conn, _params) do
    case check_database() do
      :ok ->
        json(conn, %{status: "ready"})
      :error ->
        conn
        |> put_status(:service_unavailable)
        |> json(%{status: "not_ready", reason: "database"})
    end
  end

  defp check_database do
    case Ecto.Adapters.SQL.query(Snippetbox.Repo, "SELECT 1", []) do
      {:ok, _} -> :ok
      _ -> :error
    end
  end
end
```
</details>

## Exercise 6: Docker Multi-Stage Build

Optimize the Docker build for production.

```dockerfile
# Requirements:
# 1. Multi-stage build
# 2. Minimal runtime image
# 3. Non-root user
# 4. Health check
# 5. Proper caching
```

### Solution
<details>
<summary>Click to reveal</summary>

```dockerfile
# Build stage
ARG ELIXIR_VERSION=1.16.0
ARG OTP_VERSION=26.2
ARG DEBIAN_VERSION=bookworm-20231009-slim

FROM hexpm/elixir:${ELIXIR_VERSION}-erlang-${OTP_VERSION}-debian-${DEBIAN_VERSION} AS builder

RUN apt-get update -y && apt-get install -y build-essential git \
    && apt-get clean && rm -f /var/lib/apt/lists/*_*

WORKDIR /app

RUN mix local.hex --force && mix local.rebar --force

ENV MIX_ENV=prod

# Cache dependencies
COPY mix.exs mix.lock ./
RUN mix deps.get --only $MIX_ENV
RUN mkdir config
COPY config/config.exs config/${MIX_ENV}.exs config/
RUN mix deps.compile

# Cache assets
COPY priv priv
COPY assets assets
RUN mix assets.deploy

# Compile application
COPY lib lib
RUN mix compile

# Build release
COPY config/runtime.exs config/
COPY rel rel
RUN mix release

# Runtime stage
FROM debian:${DEBIAN_VERSION}

RUN apt-get update -y && \
    apt-get install -y libstdc++6 openssl libncurses5 locales curl \
    && apt-get clean && rm -f /var/lib/apt/lists/*_*

RUN sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen

ENV LANG=en_US.UTF-8
ENV LANGUAGE=en_US:en
ENV LC_ALL=en_US.UTF-8

WORKDIR /app

# Create non-root user
RUN groupadd --gid 1000 app && \
    useradd --uid 1000 --gid app --shell /bin/bash app && \
    chown -R app:app /app

USER app

COPY --from=builder --chown=app:app /app/_build/prod/rel/snippetbox ./

ENV MIX_ENV=prod
ENV PORT=4000

EXPOSE 4000

HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
    CMD curl -f http://localhost:4000/health/live || exit 1

CMD ["bin/snippetbox", "start"]
```
</details>

## Challenge: Complete CI/CD Pipeline

Create a full CI/CD pipeline with:

1. Run tests on every PR
2. Check formatting and Credo
3. Build Docker image
4. Push to registry on main
5. Deploy to staging automatically
6. Manual approval for production
7. Run migrations after deploy

Use GitHub Actions and implement the full pipeline.

This comprehensive exercise covers testing, Docker, and deployment.
