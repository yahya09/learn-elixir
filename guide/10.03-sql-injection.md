# Chapter 10.3: SQL Injection Prevention

SQL injection is one of the most dangerous vulnerabilities. In this chapter, we'll explore how Ecto protects against SQL injection and best practices for safe database queries.

## Understanding SQL Injection

### The Attack

```sql
-- Expected query
SELECT * FROM users WHERE username = 'alice' AND password = 'secret'

-- Attacker input: ' OR '1'='1
SELECT * FROM users WHERE username = '' OR '1'='1' AND password = ''
-- Returns all users!

-- Attacker input: '; DROP TABLE users; --
SELECT * FROM users WHERE username = ''; DROP TABLE users; --'
-- Deletes the table!
```

### Why It Happens

```elixir
# DANGEROUS: String interpolation
username = params["username"]
query = "SELECT * FROM users WHERE username = '#{username}'"
Repo.query(query)

# Attacker sends: username = "' OR '1'='1"
# Results in: SELECT * FROM users WHERE username = '' OR '1'='1'
```

## Ecto's Protection

### Parameterized Queries

Ecto uses parameterized queries by default:

```elixir
# Safe - parameters are escaped
username = params["username"]

from(u in User, where: u.username == ^username)
|> Repo.all()

# Generated SQL:
# SELECT * FROM users WHERE username = $1
# Parameters: ["' OR '1'='1"]
# The input is treated as DATA, not SQL
```

### How Parameterization Works

```
Without parameterization:
  SQL: "SELECT * FROM users WHERE name = '" + input + "'"
  If input = "'; DROP TABLE users; --"
  Final: "SELECT * FROM users WHERE name = ''; DROP TABLE users; --'"
  → SQL INJECTION!

With parameterization:
  SQL template: "SELECT * FROM users WHERE name = $1"
  Parameters: ["'; DROP TABLE users; --"]
  → Input treated as literal string, not SQL
  → SAFE!
```

## Safe Ecto Patterns

### Basic Queries

```elixir
# All of these are safe:

# Simple equality
Repo.get_by(User, username: params["username"])

# Query syntax
from(u in User, where: u.email == ^params["email"])
|> Repo.one()

# Keyword queries
User
|> where([u], u.id == ^params["id"])
|> Repo.one()

# Multiple conditions
from u in User,
  where: u.username == ^username,
  where: u.active == true
```

### Dynamic Queries

```elixir
# Building queries dynamically - still safe

def list_users(filters) do
  User
  |> maybe_filter_by_email(filters[:email])
  |> maybe_filter_by_role(filters[:role])
  |> maybe_filter_by_active(filters[:active])
  |> Repo.all()
end

defp maybe_filter_by_email(query, nil), do: query
defp maybe_filter_by_email(query, email) do
  where(query, [u], u.email == ^email)
end

defp maybe_filter_by_role(query, nil), do: query
defp maybe_filter_by_role(query, role) do
  where(query, [u], u.role == ^role)
end
```

### LIKE Queries

```elixir
# Safe LIKE query
def search_users(term) do
  search_pattern = "%#{term}%"

  from(u in User, where: ilike(u.name, ^search_pattern))
  |> Repo.all()
end

# Escape special LIKE characters
def safe_search(term) do
  escaped = term
  |> String.replace("\\", "\\\\")
  |> String.replace("%", "\\%")
  |> String.replace("_", "\\_")

  pattern = "%#{escaped}%"

  from(u in User, where: ilike(u.name, ^pattern))
  |> Repo.all()
end
```

### IN Queries

```elixir
# Safe IN query
ids = [1, 2, 3]
from(u in User, where: u.id in ^ids)
|> Repo.all()

# Dynamic IN from user input
def get_users_by_ids(id_strings) do
  ids = Enum.map(id_strings, &String.to_integer/1)

  from(u in User, where: u.id in ^ids)
  |> Repo.all()
rescue
  ArgumentError -> []  # Invalid input
end
```

## Dangerous Patterns

### String Interpolation

```elixir
# NEVER DO THIS
def unsafe_search(term) do
  Repo.query("SELECT * FROM users WHERE name = '#{term}'")
end

# Also dangerous
def unsafe_order(column) do
  from(u in User, order_by: ^String.to_atom(column))  # Atom creation from user input!
end
```

### Raw SQL

```elixir
# Dangerous
Repo.query("SELECT * FROM users WHERE name = '#{name}'")

# Safe - use parameters
Repo.query("SELECT * FROM users WHERE name = $1", [name])
```

### Fragment Without Parameters

```elixir
# Dangerous
column = params["sort_by"]
from(u in User, order_by: fragment(column))  # SQL injection!

# Safe - whitelist columns
def sort_users(column) when column in ~w(name email inserted_at) do
  from(u in User, order_by: ^[{:asc, String.to_existing_atom(column)}])
end
```

## Safe Fragment Usage

### Parameterized Fragments

```elixir
# Safe - parameters escaped
from u in User,
  where: fragment("lower(?) = lower(?)", u.email, ^email)

# Safe - complex expressions
from s in Snippet,
  where: fragment(
    "? @@ plainto_tsquery('english', ?)",
    s.search_vector,
    ^search_term
  )
```

### Dynamic Column Selection

```elixir
# Safe approach - whitelist columns
@allowed_columns ~w(name email role inserted_at)

def order_by_column(query, column, direction) when column in @allowed_columns do
  col_atom = String.to_existing_atom(column)
  dir = if direction == "desc", do: :desc, else: :asc

  order_by(query, [q], [{^dir, field(q, ^col_atom)}])
end

def order_by_column(query, _column, _direction) do
  query  # Ignore invalid columns
end
```

### Table/Column Names in Fragments

```elixir
# When you must use dynamic identifiers
defmodule SafeSQL do
  @allowed_tables ~w(users snippets comments)
  @allowed_columns %{
    "users" => ~w(id name email),
    "snippets" => ~w(id title content)
  }

  def safe_query(table, column, value) when table in @allowed_tables do
    if column in @allowed_columns[table] do
      # Build query with known-safe identifiers
      sql = "SELECT * FROM #{table} WHERE #{column} = $1"
      Repo.query(sql, [value])
    else
      {:error, :invalid_column}
    end
  end

  def safe_query(_table, _column, _value) do
    {:error, :invalid_table}
  end
end
```

## Input Validation

### Type Casting

```elixir
# Ecto casts types, rejecting invalid input
def get_user(id) do
  # If id is not a valid integer, returns nil
  Repo.get(User, id)
end

# Explicit validation
def get_user(id) when is_integer(id) do
  Repo.get(User, id)
end

def get_user(id) when is_binary(id) do
  case Integer.parse(id) do
    {int_id, ""} -> Repo.get(User, int_id)
    _ -> nil
  end
end
```

### Changeset Validation

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:username, :email])
  |> validate_required([:username, :email])
  |> validate_format(:username, ~r/^[a-z0-9_]+$/)  # Only safe characters
  |> validate_format(:email, ~r/^[^\s]+@[^\s]+$/)
  |> unique_constraint(:username)
  |> unique_constraint(:email)
end
```

## Testing for SQL Injection

### Test Cases

```elixir
# File: test/snippetbox/accounts_test.exs

describe "SQL injection prevention" do
  test "handles malicious username input" do
    # Should not find any users or cause errors
    result = Accounts.get_user_by_username("' OR '1'='1")
    assert result == nil
  end

  test "handles SQL commands in input" do
    result = Accounts.get_user_by_username("'; DROP TABLE users; --")
    assert result == nil

    # Verify table still exists
    assert Repo.aggregate(User, :count) >= 0
  end

  test "handles special characters" do
    # Create user with special chars
    {:ok, user} = Accounts.create_user(%{
      username: "test_user",
      name: "O'Brien",  # Contains quote
      email: "test@example.com"
    })

    # Should find user correctly
    found = Accounts.get_user!(user.id)
    assert found.name == "O'Brien"
  end
end
```

### Audit Query Logging

```elixir
# config/dev.exs
config :snippetbox, Snippetbox.Repo,
  log: :debug

# You'll see parameterized queries in logs:
# [debug] QUERY OK source="users" db=0.5ms
# SELECT * FROM users WHERE username = $1 ["alice"]
```

## Security Audit Checklist

- [ ] No string interpolation in SQL
- [ ] All queries use Ecto Query DSL or parameterized raw SQL
- [ ] Dynamic columns/tables are whitelisted
- [ ] User input is type-cast/validated
- [ ] LIKE queries escape special characters
- [ ] Fragment usage is parameterized
- [ ] Atom creation uses `String.to_existing_atom/1`
- [ ] Raw SQL uses `Repo.query/2` with parameters

> **FP Concept: Data and Code Separation**
>
> SQL injection happens when data is mixed with code. Parameterized queries enforce separation:
>
> ```elixir
> # Code (SQL template) and data (parameters) are separate
> sql_template = "SELECT * FROM users WHERE name = $1"
> data = [user_input]
>
> # The database keeps them separate
> Repo.query(sql_template, data)
> ```
>
> This is a functional principle: pure functions (the query) operate on data (parameters) without mixing them together.

## Summary

In this chapter, we learned:

- How SQL injection attacks work
- Ecto's automatic parameterized queries
- Safe query patterns
- Dangerous patterns to avoid
- Using fragments safely
- Dynamic query building with whitelists
- Input validation
- Testing for SQL injection

In the next chapter, we'll explore XSS prevention.
