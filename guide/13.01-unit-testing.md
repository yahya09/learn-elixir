# Chapter 13.1: Unit Testing

Unit tests verify individual functions and modules in isolation. In this chapter, we'll explore ExUnit fundamentals and testing strategies.

## ExUnit Basics

```elixir
# File: test/snippetbox/calculator_test.exs

defmodule Snippetbox.CalculatorTest do
  use ExUnit.Case, async: true

  alias Snippetbox.Calculator

  describe "add/2" do
    test "adds two positive numbers" do
      assert Calculator.add(1, 2) == 3
    end

    test "adds negative numbers" do
      assert Calculator.add(-1, -2) == -3
    end

    test "adds zero" do
      assert Calculator.add(5, 0) == 5
    end
  end

  describe "divide/2" do
    test "divides two numbers" do
      assert Calculator.divide(10, 2) == {:ok, 5.0}
    end

    test "returns error for division by zero" do
      assert Calculator.divide(10, 0) == {:error, :division_by_zero}
    end
  end
end
```

## Testing Context Modules

### Snippets Context

```elixir
# File: test/snippetbox/snippets_test.exs

defmodule Snippetbox.SnippetsTest do
  use Snippetbox.DataCase, async: true

  alias Snippetbox.Snippets
  alias Snippetbox.Snippets.Snippet

  import Snippetbox.SnippetsFixtures
  import Snippetbox.AccountsFixtures

  describe "list_snippets/0" do
    test "returns all snippets" do
      snippet = snippet_fixture()
      assert Snippets.list_snippets() == [snippet]
    end

    test "returns empty list when no snippets" do
      assert Snippets.list_snippets() == []
    end
  end

  describe "list_snippets/1 with options" do
    test "filters by language" do
      elixir_snippet = snippet_fixture(%{language: "elixir"})
      _python_snippet = snippet_fixture(%{language: "python"})

      assert Snippets.list_snippets(language: "elixir") == [elixir_snippet]
    end

    test "orders by inserted_at desc" do
      old = snippet_fixture()
      new = snippet_fixture()

      assert Snippets.list_snippets(order_by: [desc: :inserted_at]) == [new, old]
    end

    test "limits results" do
      snippet_fixture()
      snippet_fixture()
      snippet_fixture()

      assert length(Snippets.list_snippets(limit: 2)) == 2
    end
  end

  describe "get_snippet!/1" do
    test "returns the snippet with given id" do
      snippet = snippet_fixture()
      assert Snippets.get_snippet!(snippet.id) == snippet
    end

    test "raises for invalid id" do
      assert_raise Ecto.NoResultsError, fn ->
        Snippets.get_snippet!(123)
      end
    end
  end

  describe "get_snippet/1" do
    test "returns snippet for valid id" do
      snippet = snippet_fixture()
      assert Snippets.get_snippet(snippet.id) == snippet
    end

    test "returns nil for invalid id" do
      assert Snippets.get_snippet(123) == nil
    end
  end

  describe "create_snippet/1" do
    test "with valid data creates a snippet" do
      valid_attrs = %{
        title: "Test Snippet",
        content: "defmodule Test do\nend",
        language: "elixir"
      }

      assert {:ok, %Snippet{} = snippet} = Snippets.create_snippet(valid_attrs)
      assert snippet.title == "Test Snippet"
      assert snippet.content == "defmodule Test do\nend"
      assert snippet.language == "elixir"
    end

    test "with invalid data returns error changeset" do
      assert {:error, %Ecto.Changeset{}} = Snippets.create_snippet(%{})
    end

    test "requires title" do
      attrs = %{content: "code", language: "elixir"}
      assert {:error, changeset} = Snippets.create_snippet(attrs)
      assert "can't be blank" in errors_on(changeset).title
    end

    test "validates title length" do
      attrs = %{title: String.duplicate("a", 101), content: "code", language: "elixir"}
      assert {:error, changeset} = Snippets.create_snippet(attrs)
      assert "should be at most 100 character(s)" in errors_on(changeset).title
    end
  end

  describe "create_snippet/2 with user" do
    test "associates snippet with user" do
      user = user_fixture()
      attrs = %{title: "My Snippet", content: "code", language: "elixir"}

      assert {:ok, snippet} = Snippets.create_snippet(user, attrs)
      assert snippet.user_id == user.id
    end
  end

  describe "update_snippet/2" do
    test "with valid data updates the snippet" do
      snippet = snippet_fixture()
      update_attrs = %{title: "Updated Title"}

      assert {:ok, %Snippet{} = updated} = Snippets.update_snippet(snippet, update_attrs)
      assert updated.title == "Updated Title"
    end

    test "with invalid data returns error changeset" do
      snippet = snippet_fixture()
      assert {:error, %Ecto.Changeset{}} = Snippets.update_snippet(snippet, %{title: ""})
      assert snippet == Snippets.get_snippet!(snippet.id)
    end
  end

  describe "delete_snippet/1" do
    test "deletes the snippet" do
      snippet = snippet_fixture()
      assert {:ok, %Snippet{}} = Snippets.delete_snippet(snippet)
      assert_raise Ecto.NoResultsError, fn -> Snippets.get_snippet!(snippet.id) end
    end
  end

  describe "change_snippet/1" do
    test "returns a changeset" do
      snippet = snippet_fixture()
      assert %Ecto.Changeset{} = Snippets.change_snippet(snippet)
    end
  end

  describe "search_snippets/1" do
    test "finds snippets by title" do
      snippet = snippet_fixture(%{title: "Elixir GenServer Example"})
      _other = snippet_fixture(%{title: "Python Script"})

      assert Snippets.search_snippets("genserver") == [snippet]
    end

    test "finds snippets by content" do
      snippet = snippet_fixture(%{content: "defmodule MyGenServer do"})
      _other = snippet_fixture(%{content: "print('hello')"})

      assert Snippets.search_snippets("defmodule") == [snippet]
    end

    test "is case insensitive" do
      snippet = snippet_fixture(%{title: "UPPERCASE TITLE"})

      assert Snippets.search_snippets("uppercase") == [snippet]
    end
  end

  describe "count_snippets/0" do
    test "returns count of all snippets" do
      snippet_fixture()
      snippet_fixture()
      snippet_fixture()

      assert Snippets.count_snippets() == 3
    end
  end
end
```

## Testing Changesets

```elixir
# File: test/snippetbox/snippets/snippet_test.exs

defmodule Snippetbox.Snippets.SnippetTest do
  use Snippetbox.DataCase, async: true

  alias Snippetbox.Snippets.Snippet

  describe "changeset/2" do
    test "valid changeset" do
      attrs = %{title: "Test", content: "code", language: "elixir"}
      changeset = Snippet.changeset(%Snippet{}, attrs)

      assert changeset.valid?
    end

    test "requires title" do
      changeset = Snippet.changeset(%Snippet{}, %{})
      refute changeset.valid?
      assert "can't be blank" in errors_on(changeset).title
    end

    test "requires content" do
      changeset = Snippet.changeset(%Snippet{}, %{title: "Test"})
      refute changeset.valid?
      assert "can't be blank" in errors_on(changeset).content
    end

    test "validates language inclusion" do
      attrs = %{title: "Test", content: "code", language: "invalid"}
      changeset = Snippet.changeset(%Snippet{}, attrs)

      refute changeset.valid?
      assert "is invalid" in errors_on(changeset).language
    end

    test "trims whitespace from title" do
      attrs = %{title: "  Test  ", content: "code", language: "elixir"}
      changeset = Snippet.changeset(%Snippet{}, attrs)

      assert get_change(changeset, :title) == "Test"
    end
  end

  describe "expiration_changeset/2" do
    test "sets expires_at" do
      snippet = %Snippet{id: 1}
      changeset = Snippet.expiration_changeset(snippet, %{expires_in: 3600})

      expires_at = get_change(changeset, :expires_at)
      assert DateTime.diff(expires_at, DateTime.utc_now()) >= 3599
    end
  end
end
```

## Testing Pure Functions

```elixir
# File: test/snippetbox/helpers/string_helper_test.exs

defmodule Snippetbox.Helpers.StringHelperTest do
  use ExUnit.Case, async: true

  alias Snippetbox.Helpers.StringHelper

  describe "truncate/2" do
    test "truncates long strings" do
      assert StringHelper.truncate("Hello World", 5) == "Hello..."
    end

    test "leaves short strings unchanged" do
      assert StringHelper.truncate("Hi", 10) == "Hi"
    end

    test "handles empty string" do
      assert StringHelper.truncate("", 5) == ""
    end

    test "handles exact length" do
      assert StringHelper.truncate("Hello", 5) == "Hello"
    end
  end

  describe "slugify/1" do
    test "converts to lowercase" do
      assert StringHelper.slugify("Hello World") == "hello-world"
    end

    test "replaces spaces with hyphens" do
      assert StringHelper.slugify("foo bar baz") == "foo-bar-baz"
    end

    test "removes special characters" do
      assert StringHelper.slugify("Hello! @World#") == "hello-world"
    end

    test "handles multiple spaces" do
      assert StringHelper.slugify("foo   bar") == "foo-bar"
    end
  end

  describe "word_count/1" do
    test "counts words" do
      assert StringHelper.word_count("Hello World") == 2
    end

    test "handles empty string" do
      assert StringHelper.word_count("") == 0
    end

    test "handles multiple spaces" do
      assert StringHelper.word_count("foo   bar   baz") == 3
    end
  end
end
```

## Testing with Pattern Matching

```elixir
# File: test/snippetbox/parser_test.exs

defmodule Snippetbox.ParserTest do
  use ExUnit.Case, async: true

  alias Snippetbox.Parser

  describe "parse_language/1" do
    test "parses elixir files" do
      assert {:ok, "elixir"} = Parser.parse_language("example.ex")
      assert {:ok, "elixir"} = Parser.parse_language("example.exs")
    end

    test "parses javascript files" do
      assert {:ok, "javascript"} = Parser.parse_language("app.js")
      assert {:ok, "javascript"} = Parser.parse_language("component.jsx")
    end

    test "returns error for unknown extensions" do
      assert {:error, :unknown_language} = Parser.parse_language("file.xyz")
    end
  end

  describe "parse_metadata/1" do
    test "extracts title from first line comment" do
      code = """
      # Title: My Snippet
      defmodule Test do
      end
      """

      assert %{title: "My Snippet"} = Parser.parse_metadata(code)
    end

    test "returns nil for missing metadata" do
      code = "defmodule Test do\nend"
      assert %{title: nil} = Parser.parse_metadata(code)
    end
  end
end
```

## Testing with Setup

```elixir
# File: test/snippetbox/accounts_test.exs

defmodule Snippetbox.AccountsTest do
  use Snippetbox.DataCase, async: true

  alias Snippetbox.Accounts
  alias Snippetbox.Accounts.User

  import Snippetbox.AccountsFixtures

  # Shared setup for all tests in describe block
  describe "users" do
    setup do
      %{user: user_fixture()}
    end

    test "get_user!/1 returns the user", %{user: user} do
      assert Accounts.get_user!(user.id) == user
    end

    test "get_user_by_email/1 returns the user", %{user: user} do
      assert Accounts.get_user_by_email(user.email) == user
    end
  end

  # Setup that returns multiple values
  describe "user relationships" do
    setup do
      user = user_fixture()
      snippet = Snippetbox.SnippetsFixtures.snippet_fixture(%{user_id: user.id})
      %{user: user, snippet: snippet}
    end

    test "user has snippets", %{user: user, snippet: snippet} do
      user = Accounts.get_user_with_snippets(user.id)
      assert snippet in user.snippets
    end
  end
end
```

## Assertions

### Common Assertions

```elixir
# Equality
assert result == expected
refute result == unexpected

# Pattern matching
assert {:ok, value} = function()
assert %User{email: email} = user

# Truthiness
assert truthy_value
refute falsy_value

# In collections
assert item in list
refute item in list

# Raise exceptions
assert_raise Ecto.NoResultsError, fn -> Accounts.get_user!(0) end
assert_raise ArgumentError, "invalid argument", fn -> raise ArgumentError, "invalid argument" end

# Receive messages
assert_receive {:message, data}, 1000  # timeout in ms
refute_receive {:message, _}, 100

# Approximate equality (for floats)
assert_in_delta 1.0, 1.001, 0.01
```

### Custom Assertions

```elixir
# File: test/support/assertions.ex

defmodule Snippetbox.TestAssertions do
  import ExUnit.Assertions

  def assert_valid_changeset(changeset) do
    assert changeset.valid?, "Expected changeset to be valid, got errors: #{inspect(errors_on(changeset))}"
  end

  def assert_invalid_changeset(changeset) do
    refute changeset.valid?, "Expected changeset to be invalid"
  end

  def assert_error_on(changeset, field, message) do
    errors = errors_on(changeset)
    assert message in Map.get(errors, field, []),
           "Expected error '#{message}' on #{field}, got: #{inspect(errors)}"
  end

  defp errors_on(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
      Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
      end)
    end)
  end
end

# Usage
import Snippetbox.TestAssertions

test "validates email format" do
  changeset = User.changeset(%User{}, %{email: "invalid"})
  assert_error_on(changeset, :email, "must have the @ sign and no spaces")
end
```

## Doctest

Test examples in documentation:

```elixir
# File: lib/snippetbox/helpers/string_helper.ex

defmodule Snippetbox.Helpers.StringHelper do
  @doc """
  Truncates a string to the specified length.

  ## Examples

      iex> Snippetbox.Helpers.StringHelper.truncate("Hello World", 5)
      "Hello..."

      iex> Snippetbox.Helpers.StringHelper.truncate("Hi", 10)
      "Hi"
  """
  def truncate(string, max_length) when byte_size(string) <= max_length do
    string
  end

  def truncate(string, max_length) do
    String.slice(string, 0, max_length) <> "..."
  end
end

# File: test/snippetbox/helpers/string_helper_test.exs

defmodule Snippetbox.Helpers.StringHelperTest do
  use ExUnit.Case, async: true

  # Run doctests from the module
  doctest Snippetbox.Helpers.StringHelper
end
```

> **FP Concept: Pure Functions Are Easy to Test**
>
> Pure functions with no side effects are trivial to test:
>
> ```elixir
> # Pure function: same input always gives same output
> def add(a, b), do: a + b
>
> # Test is straightforward
> test "add/2" do
>   assert add(1, 2) == 3  # Always true
> end
> ```
>
> Functions with side effects require mocking or setup, making them harder to test.

## Summary

In this chapter, we learned:

- ExUnit basics and structure
- Testing context modules
- Testing changesets
- Testing pure functions
- Setup and fixtures
- Assertions and doctests

In the next chapter, we'll explore controller testing.
