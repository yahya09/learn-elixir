# Chapter 11.6: Email Verification

Email verification confirms users own their email addresses. In this chapter, we'll implement a complete email confirmation flow.

## Why Verify Emails?

- **Prevent typos** in email addresses
- **Reduce spam accounts**
- **Enable password recovery**
- **Validate user identity**
- **Compliance requirements**

## Confirmation Flow

```
1. User registers
2. Account created (unconfirmed)
3. Confirmation email sent
4. User clicks confirmation link
5. Account marked as confirmed
6. Full access granted
```

## Schema Updates

```elixir
# File: lib/snippetbox/accounts/user.ex

schema "users" do
  field :email, :string
  field :name, :string
  field :password, :string, virtual: true, redact: true
  field :hashed_password, :string, redact: true
  field :confirmed_at, :naive_datetime  # New field

  timestamps()
end

@doc """
Confirms the account by setting `confirmed_at`.
"""
def confirm_changeset(user) do
  now = NaiveDateTime.utc_now() |> NaiveDateTime.truncate(:second)
  change(user, confirmed_at: now)
end
```

## Migration

```elixir
# File: priv/repo/migrations/YYYYMMDDHHMMSS_add_confirmed_at_to_users.exs

defmodule Snippetbox.Repo.Migrations.AddConfirmedAtToUsers do
  use Ecto.Migration

  def change do
    alter table(:users) do
      add :confirmed_at, :naive_datetime
    end
  end
end
```

## Context Functions

```elixir
# File: lib/snippetbox/accounts.ex

@doc """
Delivers the confirmation email instructions to the given user.
"""
def deliver_user_confirmation_instructions(%User{} = user, confirmation_url_fun)
    when is_function(confirmation_url_fun, 1) do
  if user.confirmed_at do
    {:error, :already_confirmed}
  else
    {encoded_token, user_token} = UserToken.build_email_token(user, "confirm")
    Repo.insert!(user_token)
    UserNotifier.deliver_confirmation_instructions(user, confirmation_url_fun.(encoded_token))
  end
end

@doc """
Confirms a user by the given token.
"""
def confirm_user(token) do
  with {:ok, query} <- UserToken.verify_email_token_query(token, "confirm"),
       %User{} = user <- Repo.one(query),
       {:ok, %{user: user}} <- Repo.transaction(confirm_user_multi(user)) do
    {:ok, user}
  else
    _ -> :error
  end
end

defp confirm_user_multi(user) do
  Ecto.Multi.new()
  |> Ecto.Multi.update(:user, User.confirm_changeset(user))
  |> Ecto.Multi.delete_all(:tokens, UserToken.by_user_and_contexts_query(user, ["confirm"]))
end
```

## Email Notifier

```elixir
# File: lib/snippetbox/accounts/user_notifier.ex

@doc """
Deliver instructions to confirm account.
"""
def deliver_confirmation_instructions(user, url) do
  deliver(user.email, "Confirm your account", """
  Hi #{user.name},

  Welcome to Snippetbox! Please confirm your account by visiting the URL below:

  #{url}

  If you didn't create an account with us, please ignore this email.

  This link will expire in 7 days.
  """)
end
```

## Controller

```elixir
# File: lib/snippetbox_web/controllers/user_confirmation_controller.ex

defmodule SnippetboxWeb.UserConfirmationController do
  use SnippetboxWeb, :controller

  alias Snippetbox.Accounts

  def new(conn, _params) do
    render(conn, :new)
  end

  def create(conn, %{"user" => %{"email" => email}}) do
    if user = Accounts.get_user_by_email(email) do
      Accounts.deliver_user_confirmation_instructions(
        user,
        &url(~p"/confirm/#{&1}")
      )
    end

    conn
    |> put_flash(:info, "If your email is in our system and it has not been confirmed yet, you will receive an email with instructions shortly.")
    |> redirect(to: ~p"/")
  end

  def edit(conn, %{"token" => token}) do
    render(conn, :edit, token: token)
  end

  def update(conn, %{"token" => token}) do
    case Accounts.confirm_user(token) do
      {:ok, _} ->
        conn
        |> put_flash(:info, "Your account has been confirmed successfully.")
        |> redirect(to: ~p"/login")

      :error ->
        case conn.assigns do
          %{current_user: %{confirmed_at: confirmed_at}} when not is_nil(confirmed_at) ->
            redirect(conn, to: ~p"/")

          %{} ->
            conn
            |> put_flash(:error, "Confirmation link is invalid or has expired.")
            |> redirect(to: ~p"/")
        end
    end
  end
end
```

## Templates

### Request Confirmation

```heex
<%# File: lib/snippetbox_web/controllers/user_confirmation_html/new.html.heex %>

<div class="mx-auto max-w-md">
  <.header class="text-center">
    Resend confirmation instructions
    <:subtitle>We'll send a new confirmation link to your email</:subtitle>
  </.header>

  <.form for={%{}} action={~p"/confirm"} as={:user} class="mt-8">
    <.input name="email" type="email" label="Email" required />
    <.button class="mt-6 w-full">Resend confirmation instructions</.button>
  </.form>

  <p class="mt-4 text-center text-sm">
    <.link href={~p"/register"}>Register</.link> |
    <.link href={~p"/login"}>Log in</.link>
  </p>
</div>
```

### Confirm Account

```heex
<%# File: lib/snippetbox_web/controllers/user_confirmation_html/edit.html.heex %>

<div class="mx-auto max-w-md text-center">
  <.header>
    Confirm Account
    <:subtitle>Click the button below to confirm your account</:subtitle>
  </.header>

  <.form for={%{}} action={~p"/confirm/#{@token}"} method="put" class="mt-8">
    <.button class="w-full">Confirm my account</.button>
  </.form>

  <p class="mt-4 text-sm text-gray-600">
    <.link href={~p"/confirm"}>
      Didn't receive confirmation instructions?
    </.link>
  </p>
</div>
```

## Router

```elixir
# File: lib/snippetbox_web/router.ex

scope "/", SnippetboxWeb do
  pipe_through [:browser, :redirect_if_user_is_authenticated]

  get "/confirm", UserConfirmationController, :new
  post "/confirm", UserConfirmationController, :create
  get "/confirm/:token", UserConfirmationController, :edit
  put "/confirm/:token", UserConfirmationController, :update
end
```

## Registration Integration

```elixir
# File: lib/snippetbox_web/controllers/user_registration_controller.ex

def create(conn, %{"user" => user_params}) do
  case Accounts.register_user(user_params) do
    {:ok, user} ->
      {:ok, _} =
        Accounts.deliver_user_confirmation_instructions(
          user,
          &url(~p"/confirm/#{&1}")
        )

      conn
      |> put_flash(:info, "Account created! Please check your email to confirm your account.")
      |> redirect(to: ~p"/login")

    {:error, %Ecto.Changeset{} = changeset} ->
      render(conn, :new, changeset: changeset)
  end
end
```

## Requiring Confirmation

### Plug for Confirmed Users

```elixir
# File: lib/snippetbox_web/user_auth.ex

@doc """
Requires the user to have confirmed their email.
"""
def require_confirmed_user(conn, _opts) do
  user = conn.assigns[:current_user]

  if user && user.confirmed_at do
    conn
  else
    conn
    |> put_flash(:error, "Please confirm your email to continue.")
    |> redirect(to: ~p"/confirm")
    |> halt()
  end
end
```

### Router Usage

```elixir
# Routes requiring confirmation
scope "/", SnippetboxWeb do
  pipe_through [:browser, :require_authenticated_user, :require_confirmed_user]

  resources "/snippets", SnippetController
end

# Routes for unconfirmed users (limited access)
scope "/", SnippetboxWeb do
  pipe_through [:browser, :require_authenticated_user]

  get "/confirm", UserConfirmationController, :new
  post "/confirm", UserConfirmationController, :create
end
```

## Resend Confirmation

Add button in user interface:

```heex
<%= if @current_user && !@current_user.confirmed_at do %>
  <div class="bg-yellow-50 border border-yellow-200 p-4 rounded-lg mb-4">
    <p class="text-yellow-800">
      Your email hasn't been confirmed yet.
      <.link href={~p"/confirm"} class="font-medium underline">
        Resend confirmation email
      </.link>
    </p>
  </div>
<% end %>
```

## Email Change Confirmation

When users change their email:

```elixir
# File: lib/snippetbox/accounts.ex

@doc """
Delivers the update email instructions to the given user.
"""
def deliver_user_update_email_instructions(%User{} = user, current_email, update_email_url_fun) do
  {encoded_token, user_token} = UserToken.build_email_token(user, "change:#{current_email}")
  Repo.insert!(user_token)
  UserNotifier.deliver_update_email_instructions(user, update_email_url_fun.(encoded_token))
end

@doc """
Updates the user email using the given token.
"""
def update_user_email(user, token) do
  context = "change:#{user.email}"

  with {:ok, query} <- UserToken.verify_change_email_token_query(token, context),
       %UserToken{sent_to: email} <- Repo.one(query),
       {:ok, _} <- Repo.transaction(user_email_multi(user, email, context)) do
    :ok
  else
    _ -> :error
  end
end

defp user_email_multi(user, email, context) do
  changeset = user |> User.email_changeset(%{email: email}) |> User.confirm_changeset()

  Ecto.Multi.new()
  |> Ecto.Multi.update(:user, changeset)
  |> Ecto.Multi.delete_all(:tokens, UserToken.by_user_and_contexts_query(user, [context]))
end
```

## Testing Email Verification

```elixir
# File: test/snippetbox_web/controllers/user_confirmation_controller_test.exs

defmodule SnippetboxWeb.UserConfirmationControllerTest do
  use SnippetboxWeb.ConnCase

  alias Snippetbox.Accounts
  import Snippetbox.AccountsFixtures

  setup do
    %{user: user_fixture()}
  end

  describe "GET /confirm/:token" do
    test "renders confirmation page", %{conn: conn, user: user} do
      token = extract_user_token(fn url ->
        Accounts.deliver_user_confirmation_instructions(user, fn t -> url <> t end)
      end)

      conn = get(conn, ~p"/confirm/#{token}")
      assert html_response(conn, 200) =~ "Confirm Account"
    end
  end

  describe "PUT /confirm/:token" do
    test "confirms the user", %{conn: conn, user: user} do
      token = extract_user_token(fn url ->
        Accounts.deliver_user_confirmation_instructions(user, fn t -> url <> t end)
      end)

      conn = put(conn, ~p"/confirm/#{token}")

      assert redirected_to(conn) == ~p"/login"
      assert Phoenix.Flash.get(conn.assigns.flash, :info) =~ "confirmed"
      assert Accounts.get_user!(user.id).confirmed_at
    end

    test "does not confirm with invalid token", %{conn: conn} do
      conn = put(conn, ~p"/confirm/invalid")

      assert redirected_to(conn) == ~p"/"
      assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ "invalid"
    end

    test "does not confirm already confirmed user", %{conn: conn, user: user} do
      Accounts.confirm_user(extract_token(user))

      token = extract_user_token(fn url ->
        Accounts.deliver_user_confirmation_instructions(user, fn t -> url <> t end)
      end)

      # Second confirmation should fail gracefully
      conn = put(conn, ~p"/confirm/#{token}")
      assert redirected_to(conn) == ~p"/"
    end
  end
end
```

> **FP Concept: State Transitions**
>
> Email confirmation is a state transition:
>
> ```elixir
> # User states
> :unconfirmed → :confirmed
>
> # Transition is atomic
> Ecto.Multi.new()
> |> Ecto.Multi.update(:user, confirm_changeset)
> |> Ecto.Multi.delete_all(:tokens, token_query)
> |> Repo.transaction()
> ```
>
> Either both updates succeed or neither does—no partial states.

## Summary

In this chapter, we learned:

- Email verification flow
- Token generation for confirmation
- Sending confirmation emails
- Confirming user accounts
- Requiring confirmation for features
- Resending confirmation emails
- Email change confirmation
- Testing email verification

In the next chapter, we'll explore OAuth integration.
