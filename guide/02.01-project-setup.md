# Chapter 2.1: Project Setup and Creating a Phoenix Application

Before we write any code, we need to create our Phoenix project. In this chapter, we'll use the Phoenix generator to scaffold our application and understand the generated structure.

## Creating the Project

Open your terminal and navigate to where you want to create your project. I'll create mine in `$HOME/code`, but you can choose any location.

```bash
$ cd $HOME/code
$ mix phx.new snippetbox
```

The Phoenix generator will ask you a few questions:

```bash
Fetch and install dependencies? [Yn]
```

Type `Y` and press Enter. Phoenix will:

1. Create the project directory structure
2. Generate configuration files
3. Install dependencies
4. Set up a git repository (if git is available)

You should see output like this:

```bash
* creating snippetbox/config/config.exs
* creating snippetbox/config/dev.exs
* creating snippetbox/config/prod.exs
* creating snippetbox/config/runtime.exs
* creating snippetbox/config/test.exs
* creating snippetbox/lib/snippetbox/application.ex
* creating snippetbox/lib/snippetbox.ex
* creating snippetbox/lib/snippetbox_web/controllers/error_json.ex
* creating snippetbox/lib/snippetbox_web/endpoint.ex
...

We are almost there! The following steps are missing:

    $ cd snippetbox

Then configure your database in config/dev.exs and run:

    $ mix ecto.create

Start your Phoenix app with:

    $ mix phx.server

You can also run your app inside IEx (Interactive Elixir) as:

    $ iex -S mix phx.server
```

## Understanding the Project Structure

Let's explore what Phoenix generated. Change into the project directory:

```bash
$ cd snippetbox
$ ls -la
```

You'll see:

```
snippetbox/
├── .formatter.exs        # Code formatting configuration
├── .gitignore           # Git ignore rules
├── README.md            # Project readme
├── mix.exs              # Project definition and dependencies
├── mix.lock             # Dependency lock file
├── assets/              # Frontend assets (JS, CSS)
├── config/              # Application configuration
├── lib/                 # Application source code
│   ├── snippetbox/      # Core business logic
│   └── snippetbox_web/  # Web layer (controllers, views, templates)
├── priv/                # Static assets and database files
└── test/                # Test files
```

Let's examine the key directories:

### config/

Configuration for different environments:

```
config/
├── config.exs        # Shared configuration
├── dev.exs          # Development environment
├── prod.exs         # Production environment
├── runtime.exs      # Runtime configuration
└── test.exs         # Test environment
```

### lib/

Your application code lives here, split into two main directories:

**lib/snippetbox/** - Your core application (business logic, contexts)
```
lib/snippetbox/
├── application.ex   # Application supervisor
└── repo.ex          # Database repository
```

**lib/snippetbox_web/** - Your web interface layer
```
lib/snippetbox_web/
├── controllers/     # Request handlers
├── components/      # Reusable UI components
├── endpoint.ex      # HTTP endpoint configuration
├── router.ex        # URL routing
└── telemetry.ex     # Monitoring and metrics
```

### priv/

Files that need to be in production but aren't source code:

```
priv/
├── gettext/         # Internationalization
├── repo/            # Database migrations and seeds
└── static/          # Compiled static assets
```

### assets/

Frontend assets (before compilation):

```
assets/
├── css/             # Stylesheets
├── js/              # JavaScript
└── vendor/          # Third-party JS libraries
```

## Understanding mix.exs

Open `mix.exs` in your editor. This file defines your project:

```elixir
# File: mix.exs

defmodule Snippetbox.MixProject do
  use Mix.Project

  def project do
    [
      app: :snippetbox,
      version: "0.1.0",
      elixir: "~> 1.14",
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps()
    ]
  end

  # Configuration for the OTP application.
  def application do
    [
      mod: {Snippetbox.Application, []},
      extra_applications: [:logger, :runtime_tools]
    ]
  end

  # Specifies which paths to compile per environment.
  defp elixirc_paths(:test), do: ["lib", "test/support"]
  defp elixirc_paths(_), do: ["lib"]

  # Specifies your project dependencies.
  defp deps do
    [
      {:phoenix, "~> 1.7.10"},
      {:phoenix_ecto, "~> 4.4"},
      {:ecto_sql, "~> 3.10"},
      {:postgrex, ">= 0.0.0"},
      {:phoenix_html, "~> 4.0"},
      {:phoenix_live_reload, "~> 1.2", only: :dev},
      {:phoenix_live_view, "~> 0.20.1"},
      {:floki, ">= 0.30.0", only: :test},
      {:phoenix_live_dashboard, "~> 0.8.2"},
      {:esbuild, "~> 0.8", runtime: Mix.env() == :dev},
      {:tailwind, "~> 0.2", runtime: Mix.env() == :dev},
      {:telemetry_metrics, "~> 0.6"},
      {:telemetry_poller, "~> 1.0"},
      {:gettext, "~> 0.20"},
      {:jason, "~> 1.2"},
      {:dns_cluster, "~> 0.1.1"},
      {:bandit, "~> 1.0"}
    ]
  end

  # Aliases are shortcuts or tasks specific to the current project.
  defp aliases do
    [
      setup: ["deps.get", "ecto.setup", "assets.setup", "assets.build"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"],
      "assets.setup": ["tailwind.install --if-missing", "esbuild.install --if-missing"],
      "assets.build": ["tailwind snippetbox", "esbuild snippetbox"],
      "assets.deploy": [
        "tailwind snippetbox --minify",
        "esbuild snippetbox --minify",
        "phx.digest"
      ]
    ]
  end
end
```

> **Note**: The `mix.exs` file is similar to `package.json` in Node.js, `requirements.txt` in Python, `composer.json` in PHP, or `Gemfile` in Ruby. It defines your application and its dependencies.

## Configuring the Database

Before we can run our application, we need to configure the database connection. Open `config/dev.exs`:

```elixir
# File: config/dev.exs

import Config

# Configure your database
config :snippetbox, Snippetbox.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "snippetbox_dev",
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 10
```

Adjust the `username` and `password` to match your PostgreSQL setup. The default is:
- Username: `postgres`
- Password: `postgres`

If you set a different password during PostgreSQL installation, update it here.

## Creating the Database

Now create the database:

```bash
$ mix ecto.create
```

You should see:

```bash
Compiling 15 files (.ex)
Generated snippetbox app
The database for Snippetbox.Repo has been created
```

If you get an error, double-check your database credentials in `config/dev.exs`.

## Starting the Server

Start the Phoenix server:

```bash
$ mix phx.server
```

You should see output like:

```bash
[info] Running SnippetboxWeb.Endpoint with Bandit 1.1.0 at 127.0.0.1:4000 (http)
[info] Access SnippetboxWeb.Endpoint at http://localhost:4000
[watch] build finished, watching for changes...
```

Open your browser and visit `http://localhost:4000`. You should see the Phoenix welcome page:

```
┌────────────────────────────────┐
│   Peace of mind from prototype │
│           to production        │
│                                │
│   [Phoenix Framework logo]     │
│                                │
│   Mix Tasks:                   │
│   • mix phx.new               │
│   • mix phx.gen.html          │
│   ...                          │
└────────────────────────────────┘
```

Press `Ctrl+C` twice to stop the server.

## Understanding the Application Module

Let's look at the entry point of our application. Open `lib/snippetbox/application.ex`:

```elixir
# File: lib/snippetbox/application.ex

defmodule Snippetbox.Application do
  @moduledoc false

  use Application

  @impl true
  def start(_type, _args) do
    children = [
      SnippetboxWeb.Telemetry,
      Snippetbox.Repo,
      {DNSCluster, query: Application.get_env(:snippetbox, :dns_cluster_query) || :ignore},
      {Phoenix.PubSub, name: Snippetbox.PubSub},
      {Finch, name: Snippetbox.Finch},
      SnippetboxWeb.Endpoint
    ]

    opts = [strategy: :one_for_one, name: Snippetbox.Supervisor]
    Supervisor.start_link(children, opts)
  end

  @impl true
  def config_change(changed, _new, removed) do
    SnippetboxWeb.Endpoint.config_change(changed, removed)
    :ok
  end
end
```

> **FP Concept: Supervision Trees**
>
> This file defines a **supervision tree** - a key concept in Elixir/Erlang OTP. Each `child` is a process that the supervisor monitors. If a child crashes, the supervisor restarts it automatically.
>
> This is the "let it crash" philosophy:
> - Don't try to prevent every error
> - Let processes fail and restart cleanly
> - Isolate failures so they don't bring down the whole system
>
> Coming from other languages, this is similar to:
> - Process managers (PM2, systemd)
> - Container orchestrators (Kubernetes)
>
> But it's built into the language and happens at the process level, not the OS level.
>
> **Further Reading**:
> - [Elixir School - Supervisors](https://elixirschool.com/en/lessons/advanced/otp_supervisors)
> - [Erlang OTP Design Principles](https://www.erlang.org/doc/design_principles/users_guide.html)

## Understanding the Endpoint

The `Endpoint` is where HTTP requests enter your application. Open `lib/snippetbox_web/endpoint.ex`:

```elixir
# File: lib/snippetbox_web/endpoint.ex

defmodule SnippetboxWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :snippetbox

  # Serve static files
  plug Plug.Static,
    at: "/",
    from: :snippetbox,
    gzip: false,
    only: SnippetboxWeb.static_paths()

  # Code reloading in development
  if code_reloading? do
    socket "/phoenix/live_reload/socket", Phoenix.LiveReloader.Socket
    plug Phoenix.LiveReloader
    plug Phoenix.CodeReloader
  end

  plug Phoenix.LiveDashboard.RequestLogger,
    param_key: "request_logger",
    cookie_key: "request_logger"

  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  plug Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: ["*/*"],
    json_decoder: Phoenix.json_library()

  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session,
    store: :cookie,
    key: "_snippetbox_key",
    signing_salt: "some-signing-salt",
    same_site: "Lax"

  plug SnippetboxWeb.Router
end
```

The `Endpoint` is a series of `plugs` (middleware) that process the request before it reaches your router. We'll learn more about plugs in Chapter 6.

## Interactive Elixir with Your Application

You can start an interactive Elixir session with your application loaded:

```bash
$ iex -S mix phx.server
```

This starts both IEx and your Phoenix server. You can now interact with your application:

```elixir
iex(1)> SnippetboxWeb.Endpoint.url()
"http://localhost:4000"

iex(2)> Application.get_env(:snippetbox, Snippetbox.Repo)
[
  username: "postgres",
  password: "postgres",
  database: "snippetbox_dev",
  hostname: "localhost",
  ...
]
```

Press `Ctrl+C` twice to exit.

## Hello World

Let's make a small change to verify everything works. Open `lib/snippetbox_web/controllers/page_controller.ex`:

```elixir
# File: lib/snippetbox_web/controllers/page_controller.ex

defmodule SnippetboxWeb.PageController do
  use SnippetboxWeb, :controller

  def home(conn, _params) do
    render(conn, :home, layout: false)
  end
end
```

Change the `home` function to:

```elixir
def home(conn, _params) do
  conn
  |> put_resp_content_type("text/plain")
  |> send_resp(200, "Hello from SnippetBox!")
end
```

Start the server:

```bash
$ mix phx.server
```

Visit `http://localhost:4000` in your browser. You should see:

```
Hello from SnippetBox!
```

The changes appeared automatically without restarting the server. This is Phoenix's **live code reloading** in action - one of the best features for developer productivity.

## Summary

In this chapter, we:

- Created a new Phoenix project with `mix phx.new`
- Explored the Phoenix project structure
- Configured the database connection
- Started the development server
- Made our first code change with live reloading

In the next chapter, we'll dive deeper into how Phoenix handles web requests, starting with routing and controllers.

---

## Additional Information

### Mix vs Other Build Tools

Mix is Elixir's build tool. Here's how it compares:

| Task | Mix | npm | Cargo | Maven |
|------|-----|-----|-------|-------|
| New project | `mix new` | `npm init` | `cargo new` | `mvn archetype:generate` |
| Dependencies | `mix deps.get` | `npm install` | `cargo build` | `mvn install` |
| Run tests | `mix test` | `npm test` | `cargo test` | `mvn test` |
| Run project | `mix phx.server` | `npm start` | `cargo run` | `mvn exec:java` |

### Phoenix vs mix phx.new Options

The `mix phx.new` command has several options:

```bash
# Generate without Ecto (no database)
$ mix phx.new my_app --no-ecto

# Generate an API-only application (no HTML)
$ mix phx.new my_app --no-html

# Generate with LiveView
$ mix phx.new my_app --live

# See all options
$ mix help phx.new
```

For this book, we use the default options which include:
- Ecto for database access
- HTML templating
- Asset management
- LiveView support

### The Difference Between lib/snippetbox and lib/snippetbox_web

Phoenix separates your application into two parts:

**lib/snippetbox/** - Core logic (contexts)
- Business logic
- Database schemas
- Application-specific code
- Could be used by multiple interfaces (web, CLI, API)

**lib/snippetbox_web/** - Web interface
- Controllers
- Views
- Templates
- Router
- Plugs

This separation is intentional:
- Keeps web concerns separate from business logic
- Makes testing easier
- Allows multiple interfaces to the same core logic

This pattern is similar to:
- **Hexagonal Architecture** (Ports and Adapters)
- **Clean Architecture** (Entities vs Interfaces)
- **Domain-Driven Design** (Domain vs Application layers)
