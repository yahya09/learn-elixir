# Chapter 4.2: Creating Database Migrations

Migrations are versioned scripts that modify your database schema. In this chapter, we'll learn how to create and manage migrations for our snippets table.

## What Are Migrations?

Migrations provide:

- **Version control** for database schema
- **Reproducibility** across environments
- **Collaboration** among team members
- **Rollback** capability when things go wrong

## Creating Your First Migration

### Generate Migration

```bash
$ mix ecto.gen.migration create_snippets
* creating priv/repo/migrations/20240115100000_create_snippets.exs
```

The filename includes a timestamp for ordering.

### Write the Migration

```elixir
# File: priv/repo/migrations/20240115100000_create_snippets.exs

defmodule Snippetbox.Repo.Migrations.CreateSnippets do
  use Ecto.Migration

  def change do
    create table(:snippets) do
      add :title, :string, null: false
      add :content, :text, null: false
      add :expires_at, :utc_datetime

      timestamps(type: :utc_datetime)
    end
  end
end
```

### Run the Migration

```bash
$ mix ecto.migrate
[info] == Running 20240115100000 Snippetbox.Repo.Migrations.CreateSnippets.change/0 forward
[info] create table snippets
[info] == Migrated 20240115100000 in 0.0s
```

## Migration DSL

### Creating Tables

```elixir
def change do
  create table(:snippets) do
    add :title, :string, null: false
    add :content, :text
    add :views, :integer, default: 0
    add :is_public, :boolean, default: true
    add :expires_at, :utc_datetime

    timestamps()  # Adds inserted_at and updated_at
  end
end
```

### Column Types

| Elixir Type | PostgreSQL Type | Description |
|-------------|-----------------|-------------|
| `:string` | `varchar(255)` | Short text |
| `:text` | `text` | Unlimited text |
| `:integer` | `integer` | 32-bit integer |
| `:bigint` | `bigint` | 64-bit integer |
| `:float` | `float` | Floating point |
| `:decimal` | `decimal` | Exact decimal |
| `:boolean` | `boolean` | True/false |
| `:date` | `date` | Date only |
| `:time` | `time` | Time only |
| `:naive_datetime` | `timestamp` | Date+time, no timezone |
| `:utc_datetime` | `timestamptz` | Date+time with timezone |
| `:uuid` | `uuid` | UUID |
| `:binary` | `bytea` | Binary data |
| `:map` | `jsonb` | JSON data |
| `{:array, :string}` | `varchar[]` | Array |

### Column Options

```elixir
add :email, :string,
  null: false,          # NOT NULL constraint
  size: 100,            # varchar(100)
  default: "unknown"    # DEFAULT value

add :age, :integer,
  default: fragment("18")  # SQL fragment for default

add :status, :string,
  default: "draft"

add :metadata, :map,
  default: %{}
```

### Primary Keys

```elixir
# Default: bigserial (auto-incrementing bigint)
create table(:snippets) do
  # id is added automatically
end

# UUID primary key
create table(:snippets, primary_key: false) do
  add :id, :binary_id, primary_key: true
  # ...
end

# Composite primary key
create table(:snippet_tags, primary_key: false) do
  add :snippet_id, references(:snippets), primary_key: true
  add :tag_id, references(:tags), primary_key: true
end
```

### Foreign Keys

```elixir
def change do
  create table(:snippets) do
    add :title, :string
    add :user_id, references(:users, on_delete: :delete_all)
    timestamps()
  end

  create index(:snippets, [:user_id])
end
```

Foreign key options:
- `:nothing` - Do nothing (default)
- `:delete_all` - Cascade delete
- `:nilify_all` - Set to NULL
- `:restrict` - Prevent deletion

### Indexes

```elixir
def change do
  create table(:snippets) do
    add :title, :string
    add :slug, :string
    add :user_id, references(:users)
    timestamps()
  end

  # Simple index
  create index(:snippets, [:user_id])

  # Unique index
  create unique_index(:snippets, [:slug])

  # Composite index
  create index(:snippets, [:user_id, :inserted_at])

  # Partial index
  create index(:snippets, [:expires_at],
    where: "expires_at IS NOT NULL",
    name: :snippets_expiring_index
  )
end
```

## Modifying Tables

### Adding Columns

```elixir
def change do
  alter table(:snippets) do
    add :language, :string, default: "text"
    add :views_count, :integer, default: 0
  end
end
```

### Removing Columns

```elixir
def change do
  alter table(:snippets) do
    remove :deprecated_field
  end
end
```

For reversible removal (if you need data on rollback):

```elixir
def change do
  alter table(:snippets) do
    remove :language, :string, default: "text"  # Include type for rollback
  end
end
```

### Modifying Columns

```elixir
def change do
  alter table(:snippets) do
    modify :content, :text, from: :string  # Change type
    modify :title, :string, null: false, from: {:string, null: true}
  end
end
```

### Renaming

```elixir
def change do
  # Rename table
  rename table(:posts), to: table(:snippets)

  # Rename column
  rename table(:snippets), :body, to: :content
end
```

## Up and Down Functions

For non-reversible changes, use `up` and `down`:

```elixir
def up do
  execute """
  ALTER TABLE snippets
  ADD CONSTRAINT check_title_length
  CHECK (char_length(title) >= 3)
  """
end

def down do
  execute """
  ALTER TABLE snippets
  DROP CONSTRAINT check_title_length
  """
end
```

## Running Raw SQL

```elixir
def change do
  # Execute SQL
  execute "CREATE EXTENSION IF NOT EXISTS pg_trgm"

  # With up/down
  execute(
    "CREATE INDEX snippets_title_trgm ON snippets USING gin(title gin_trgm_ops)",
    "DROP INDEX snippets_title_trgm"
  )
end
```

## Migration Commands

```bash
# Run pending migrations
$ mix ecto.migrate

# Rollback last migration
$ mix ecto.rollback

# Rollback multiple migrations
$ mix ecto.rollback --step 3

# Rollback to specific version
$ mix ecto.rollback --to 20240115100000

# Check migration status
$ mix ecto.migrations

# Reset database (drop + create + migrate)
$ mix ecto.reset

# Setup database (create + migrate + seed)
$ mix ecto.setup
```

## Complete Migration Example

```elixir
# File: priv/repo/migrations/20240115100000_create_snippets.exs

defmodule Snippetbox.Repo.Migrations.CreateSnippets do
  use Ecto.Migration

  def change do
    # Create snippets table
    create table(:snippets) do
      add :title, :string, null: false, size: 100
      add :content, :text, null: false
      add :language, :string, default: "text"
      add :expires_at, :utc_datetime
      add :is_public, :boolean, default: true
      add :views_count, :integer, default: 0
      add :user_id, references(:users, on_delete: :nilify_all)

      timestamps(type: :utc_datetime)
    end

    # Indexes
    create index(:snippets, [:user_id])
    create index(:snippets, [:inserted_at])
    create index(:snippets, [:expires_at], where: "expires_at IS NOT NULL")

    # Unique slug would go here if we had one
    # create unique_index(:snippets, [:slug])
  end
end
```

## Migration Best Practices

### 1. Make Migrations Reversible

```elixir
# Good: Reversible
def change do
  add :column, :string
end

# When not reversible, provide both directions
def up do
  execute "CREATE EXTENSION ..."
end

def down do
  execute "DROP EXTENSION ..."
end
```

### 2. Don't Modify Existing Migrations

Once a migration runs in production, create a new migration for changes.

### 3. Keep Migrations Small

One logical change per migration makes debugging easier.

### 4. Add Indexes for Foreign Keys

```elixir
add :user_id, references(:users)
create index(:snippets, [:user_id])  # Don't forget!
```

### 5. Consider Null Constraints

```elixir
# Be explicit about nullability
add :required_field, :string, null: false
add :optional_field, :string  # null: true is default
```

> **FP Concept: Migrations as Transformations**
>
> Migrations are functions that transform database state:
>
> ```
> State₀ --migration₁--> State₁ --migration₂--> State₂
> ```
>
> Each migration is a reversible transformation:
> - `up`: Transform forward (State₀ → State₁)
> - `down`: Transform backward (State₁ → State₀)
>
> The `change/0` function is special - Ecto automatically derives the reverse transformation when possible.
>
> **Further Reading**:
> - [Ecto Migrations](https://hexdocs.pm/ecto_sql/Ecto.Migration.html)

## Summary

In this chapter, we learned:

- Creating migrations with `mix ecto.gen.migration`
- Table creation with columns and constraints
- Column types and options
- Foreign keys and indexes
- Modifying existing tables
- Running and rolling back migrations

In the next chapter, we'll create Ecto schemas to map our database tables to Elixir structs.

---

## Additional Information

### Migration Locking

Ecto uses advisory locks to prevent concurrent migrations:

```elixir
config :snippetbox, Snippetbox.Repo,
  migration_lock: :pg_advisory_lock  # Default for PostgreSQL
```

### Data Migrations

For data migrations, use Ecto directly:

```elixir
def up do
  # Add column
  alter table(:snippets) do
    add :slug, :string
  end

  flush()  # Ensure schema change is applied

  # Migrate data
  execute """
  UPDATE snippets
  SET slug = lower(replace(title, ' ', '-'))
  """

  # Add constraint after data migration
  alter table(:snippets) do
    modify :slug, :string, null: false
  end

  create unique_index(:snippets, [:slug])
end
```

### Testing Migrations

```bash
# Test migrate and rollback
$ mix ecto.migrate
$ mix ecto.rollback
$ mix ecto.migrate
```
