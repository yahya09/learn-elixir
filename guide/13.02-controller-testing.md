# Chapter 13.2: Controller Testing

Controller tests verify HTTP endpoints, request handling, and response generation. In this chapter, we'll explore Phoenix controller testing patterns.

## ConnCase Setup

```elixir
# File: test/support/conn_case.ex

defmodule SnippetboxWeb.ConnCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      @endpoint SnippetboxWeb.Endpoint

      use SnippetboxWeb, :verified_routes

      import Plug.Conn
      import Phoenix.ConnTest
      import SnippetboxWeb.ConnCase
    end
  end

  setup tags do
    Snippetbox.DataCase.setup_sandbox(tags)
    {:ok, conn: Phoenix.ConnTest.build_conn()}
  end

  @doc """
  Setup helper that registers and logs in users.
  """
  def register_and_log_in_user(%{conn: conn}) do
    user = Snippetbox.AccountsFixtures.user_fixture()
    %{conn: log_in_user(conn, user), user: user}
  end

  @doc """
  Logs the given `user` into the `conn`.
  """
  def log_in_user(conn, user) do
    token = Snippetbox.Accounts.generate_user_session_token(user)

    conn
    |> Phoenix.ConnTest.init_test_session(%{})
    |> Plug.Conn.put_session(:user_token, token)
  end
end
```

## Basic Controller Tests

```elixir
# File: test/snippetbox_web/controllers/page_controller_test.exs

defmodule SnippetboxWeb.PageControllerTest do
  use SnippetboxWeb.ConnCase

  test "GET /", %{conn: conn} do
    conn = get(conn, ~p"/")

    assert html_response(conn, 200) =~ "Welcome to Snippetbox"
  end

  test "GET /about", %{conn: conn} do
    conn = get(conn, ~p"/about")

    assert html_response(conn, 200) =~ "About"
  end

  test "returns 404 for unknown routes", %{conn: conn} do
    assert_raise Phoenix.Router.NoRouteError, fn ->
      get(conn, "/nonexistent")
    end
  end
end
```

## Resource Controller Tests

```elixir
# File: test/snippetbox_web/controllers/snippet_controller_test.exs

defmodule SnippetboxWeb.SnippetControllerTest do
  use SnippetboxWeb.ConnCase

  import Snippetbox.SnippetsFixtures
  import Snippetbox.AccountsFixtures

  @create_attrs %{title: "Test Snippet", content: "code", language: "elixir"}
  @update_attrs %{title: "Updated Snippet"}
  @invalid_attrs %{title: nil, content: nil}

  describe "index" do
    test "lists all snippets", %{conn: conn} do
      conn = get(conn, ~p"/snippets")
      assert html_response(conn, 200) =~ "Snippets"
    end

    test "displays snippets", %{conn: conn} do
      snippet = snippet_fixture()
      conn = get(conn, ~p"/snippets")

      assert html_response(conn, 200) =~ snippet.title
    end
  end

  describe "show" do
    test "shows snippet", %{conn: conn} do
      snippet = snippet_fixture()
      conn = get(conn, ~p"/snippets/#{snippet}")

      assert html_response(conn, 200) =~ snippet.title
    end

    test "returns 404 for invalid id", %{conn: conn} do
      assert_raise Ecto.NoResultsError, fn ->
        get(conn, ~p"/snippets/999999")
      end
    end
  end

  describe "new" do
    setup [:register_and_log_in_user]

    test "renders form", %{conn: conn} do
      conn = get(conn, ~p"/snippets/new")
      assert html_response(conn, 200) =~ "New Snippet"
    end
  end

  describe "new (unauthenticated)" do
    test "redirects to login", %{conn: conn} do
      conn = get(conn, ~p"/snippets/new")

      assert redirected_to(conn) == ~p"/login"
    end
  end

  describe "create" do
    setup [:register_and_log_in_user]

    test "redirects to show when data is valid", %{conn: conn} do
      conn = post(conn, ~p"/snippets", snippet: @create_attrs)

      assert %{id: id} = redirected_params(conn)
      assert redirected_to(conn) == ~p"/snippets/#{id}"

      conn = get(conn, ~p"/snippets/#{id}")
      assert html_response(conn, 200) =~ @create_attrs.title
    end

    test "renders errors when data is invalid", %{conn: conn} do
      conn = post(conn, ~p"/snippets", snippet: @invalid_attrs)

      assert html_response(conn, 200) =~ "can&#39;t be blank"
    end
  end

  describe "edit" do
    setup [:register_and_log_in_user]

    test "renders form for editing chosen snippet", %{conn: conn, user: user} do
      snippet = snippet_fixture(%{user_id: user.id})
      conn = get(conn, ~p"/snippets/#{snippet}/edit")

      assert html_response(conn, 200) =~ "Edit Snippet"
    end

    test "returns 403 for other user's snippet", %{conn: conn} do
      other_user = user_fixture()
      snippet = snippet_fixture(%{user_id: other_user.id})

      conn = get(conn, ~p"/snippets/#{snippet}/edit")

      assert response(conn, 403) =~ "Forbidden"
    end
  end

  describe "update" do
    setup [:register_and_log_in_user]

    test "redirects when data is valid", %{conn: conn, user: user} do
      snippet = snippet_fixture(%{user_id: user.id})
      conn = put(conn, ~p"/snippets/#{snippet}", snippet: @update_attrs)

      assert redirected_to(conn) == ~p"/snippets/#{snippet}"

      conn = get(conn, ~p"/snippets/#{snippet}")
      assert html_response(conn, 200) =~ "Updated Snippet"
    end

    test "renders errors when data is invalid", %{conn: conn, user: user} do
      snippet = snippet_fixture(%{user_id: user.id})
      conn = put(conn, ~p"/snippets/#{snippet}", snippet: @invalid_attrs)

      assert html_response(conn, 200) =~ "can&#39;t be blank"
    end
  end

  describe "delete" do
    setup [:register_and_log_in_user]

    test "deletes chosen snippet", %{conn: conn, user: user} do
      snippet = snippet_fixture(%{user_id: user.id})
      conn = delete(conn, ~p"/snippets/#{snippet}")

      assert redirected_to(conn) == ~p"/snippets"

      assert_raise Ecto.NoResultsError, fn ->
        get(conn, ~p"/snippets/#{snippet}")
      end
    end
  end
end
```

## Testing JSON APIs

```elixir
# File: test/snippetbox_web/controllers/api/snippet_controller_test.exs

defmodule SnippetboxWeb.Api.SnippetControllerTest do
  use SnippetboxWeb.ConnCase

  import Snippetbox.SnippetsFixtures

  @create_attrs %{title: "API Snippet", content: "code", language: "elixir"}
  @invalid_attrs %{title: nil}

  setup %{conn: conn} do
    {:ok, conn: put_req_header(conn, "accept", "application/json")}
  end

  describe "index" do
    test "lists all snippets", %{conn: conn} do
      conn = get(conn, ~p"/api/snippets")
      assert json_response(conn, 200)["data"] == []
    end

    test "returns snippets", %{conn: conn} do
      snippet = snippet_fixture()
      conn = get(conn, ~p"/api/snippets")

      assert [%{"id" => id, "title" => title}] = json_response(conn, 200)["data"]
      assert id == snippet.id
      assert title == snippet.title
    end
  end

  describe "show" do
    test "returns snippet", %{conn: conn} do
      snippet = snippet_fixture()
      conn = get(conn, ~p"/api/snippets/#{snippet}")

      assert %{
               "id" => id,
               "title" => title,
               "content" => content,
               "language" => language
             } = json_response(conn, 200)["data"]

      assert id == snippet.id
      assert title == snippet.title
      assert content == snippet.content
      assert language == snippet.language
    end

    test "returns 404 for invalid id", %{conn: conn} do
      conn = get(conn, ~p"/api/snippets/999999")
      assert json_response(conn, 404)["errors"] != %{}
    end
  end

  describe "create" do
    setup [:authenticate_api]

    test "creates snippet when data is valid", %{conn: conn} do
      conn = post(conn, ~p"/api/snippets", snippet: @create_attrs)

      assert %{"id" => id} = json_response(conn, 201)["data"]

      conn = get(conn, ~p"/api/snippets/#{id}")
      assert json_response(conn, 200)["data"]["title"] == "API Snippet"
    end

    test "returns errors when data is invalid", %{conn: conn} do
      conn = post(conn, ~p"/api/snippets", snippet: @invalid_attrs)
      assert json_response(conn, 422)["errors"] != %{}
    end
  end

  describe "create (unauthenticated)" do
    test "returns 401", %{conn: conn} do
      conn = post(conn, ~p"/api/snippets", snippet: @create_attrs)
      assert json_response(conn, 401)["errors"]["detail"] =~ "unauthenticated"
    end
  end

  defp authenticate_api(%{conn: conn}) do
    user = Snippetbox.AccountsFixtures.user_fixture()
    token = Snippetbox.Accounts.generate_api_token(user)

    conn =
      conn
      |> put_req_header("authorization", "Bearer #{token}")

    %{conn: conn, user: user}
  end
end
```

## Testing Authentication

```elixir
# File: test/snippetbox_web/controllers/user_session_controller_test.exs

defmodule SnippetboxWeb.UserSessionControllerTest do
  use SnippetboxWeb.ConnCase

  import Snippetbox.AccountsFixtures

  setup do
    %{user: user_fixture()}
  end

  describe "new" do
    test "renders login page", %{conn: conn} do
      conn = get(conn, ~p"/login")
      assert html_response(conn, 200) =~ "Log In"
    end

    test "redirects if already logged in", %{conn: conn, user: user} do
      conn = conn |> log_in_user(user) |> get(~p"/login")
      assert redirected_to(conn) == ~p"/"
    end
  end

  describe "create" do
    test "logs in the user with valid credentials", %{conn: conn, user: user} do
      conn =
        post(conn, ~p"/login", %{
          "user" => %{"email" => user.email, "password" => valid_user_password()}
        })

      assert get_session(conn, :user_token)
      assert redirected_to(conn) == ~p"/"

      # Now do a request with the session
      conn = get(conn, ~p"/")
      response = html_response(conn, 200)
      assert response =~ user.email
    end

    test "logs in with remember me", %{conn: conn, user: user} do
      conn =
        post(conn, ~p"/login", %{
          "user" => %{
            "email" => user.email,
            "password" => valid_user_password(),
            "remember_me" => "true"
          }
        })

      assert conn.resp_cookies["_snippetbox_web_user_remember_me"]
    end

    test "renders errors with invalid credentials", %{conn: conn} do
      conn =
        post(conn, ~p"/login", %{
          "user" => %{"email" => "invalid@example.com", "password" => "invalid"}
        })

      response = html_response(conn, 200)
      assert response =~ "Log In"
      assert response =~ "Invalid email or password"
    end
  end

  describe "delete" do
    test "logs out the user", %{conn: conn, user: user} do
      conn = conn |> log_in_user(user) |> delete(~p"/logout")

      assert redirected_to(conn) == ~p"/"
      refute get_session(conn, :user_token)
    end

    test "succeeds even if user not logged in", %{conn: conn} do
      conn = delete(conn, ~p"/logout")
      assert redirected_to(conn) == ~p"/"
    end
  end
end
```

## Testing Flash Messages

```elixir
test "shows success flash after create", %{conn: conn} do
  conn = post(conn, ~p"/snippets", snippet: @create_attrs)

  assert Phoenix.Flash.get(conn.assigns.flash, :info) =~ "Snippet created"
end

test "shows error flash for failed login", %{conn: conn} do
  conn = post(conn, ~p"/login", %{"user" => %{"email" => "bad", "password" => "bad"}})

  assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ "Invalid"
end
```

## Testing Redirects

```elixir
test "redirects to snippet after create", %{conn: conn} do
  conn = post(conn, ~p"/snippets", snippet: @create_attrs)

  assert %{id: id} = redirected_params(conn)
  assert redirected_to(conn) == ~p"/snippets/#{id}"
end

test "preserves return_to param", %{conn: conn} do
  conn =
    conn
    |> put_session(:user_return_to, "/snippets/42")
    |> post(~p"/login", %{"user" => %{"email" => email, "password" => password}})

  assert redirected_to(conn) == "/snippets/42"
end
```

## Testing Response Headers

```elixir
test "sets cache control header", %{conn: conn} do
  conn = get(conn, ~p"/api/snippets")

  assert get_resp_header(conn, "cache-control") == ["max-age=3600, public"]
end

test "sets content type for JSON", %{conn: conn} do
  conn = get(conn, ~p"/api/snippets")

  assert get_resp_header(conn, "content-type") == ["application/json; charset=utf-8"]
end

test "sets CORS headers", %{conn: conn} do
  conn = get(conn, ~p"/api/snippets")

  assert get_resp_header(conn, "access-control-allow-origin") == ["*"]
end
```

## Testing File Uploads

```elixir
describe "file upload" do
  setup [:register_and_log_in_user]

  test "uploads file successfully", %{conn: conn} do
    upload = %Plug.Upload{
      path: "test/fixtures/example.ex",
      filename: "example.ex",
      content_type: "text/plain"
    }

    conn = post(conn, ~p"/snippets/import", %{"file" => upload})

    assert redirected_to(conn) =~ "/snippets/"
    assert Phoenix.Flash.get(conn.assigns.flash, :info) =~ "Imported"
  end

  test "rejects invalid file type", %{conn: conn} do
    upload = %Plug.Upload{
      path: "test/fixtures/image.png",
      filename: "image.png",
      content_type: "image/png"
    }

    conn = post(conn, ~p"/snippets/import", %{"file" => upload})

    assert html_response(conn, 200) =~ "Invalid file type"
  end
end
```

## Testing Plugs

```elixir
# File: test/snippetbox_web/plugs/require_auth_test.exs

defmodule SnippetboxWeb.Plugs.RequireAuthTest do
  use SnippetboxWeb.ConnCase

  alias SnippetboxWeb.Plugs.RequireAuth

  describe "call/2" do
    test "passes through authenticated user", %{conn: conn} do
      user = Snippetbox.AccountsFixtures.user_fixture()
      conn = conn |> log_in_user(user) |> RequireAuth.call([])

      assert conn.assigns.current_user == user
      refute conn.halted
    end

    test "redirects unauthenticated user", %{conn: conn} do
      conn =
        conn
        |> fetch_flash()
        |> RequireAuth.call([])

      assert conn.halted
      assert redirected_to(conn) == ~p"/login"
    end

    test "returns 401 for API requests", %{conn: conn} do
      conn =
        conn
        |> put_req_header("accept", "application/json")
        |> RequireAuth.call([])

      assert conn.halted
      assert json_response(conn, 401)["errors"]["detail"] =~ "unauthenticated"
    end
  end
end
```

> **FP Concept: Immutable Request/Response**
>
> Phoenix tests follow the functional pattern of transforming connections:
>
> ```elixir
> # Each function returns a new conn
> conn
> |> put_req_header("accept", "application/json")
> |> post("/api/snippets", snippet: attrs)
> |> json_response(201)
>
> # The original conn is never modified
> # Each step produces a new connection struct
> ```
>
> This makes tests predictable and easy to compose.

## Summary

In this chapter, we learned:

- ConnCase setup and helpers
- Testing CRUD controllers
- Testing JSON APIs
- Testing authentication
- Testing flash messages and redirects
- Testing response headers
- Testing file uploads
- Testing plugs

In the next chapter, we'll explore integration testing.
