# Chapter 11.4: Remember Me

Remember me functionality allows users to stay logged in across browser sessions. In this chapter, we'll implement secure persistent authentication.

## How Remember Me Works

```
1. User logs in with "Remember me" checked
2. Server creates long-lived token
3. Token stored in signed cookie
4. On next visit, cookie token restores session
5. New session token created from remember me token
```

## Security Considerations

| Approach | Security | User Experience |
|----------|----------|-----------------|
| Long session | Lower | Best |
| Remember me cookie | Better | Good |
| Token rotation | Best | Good |

## Implementation

### Cookie Configuration

```elixir
# File: lib/snippetbox_web/user_auth.ex

@max_age 60 * 60 * 24 * 60  # 60 days
@remember_me_cookie "_snippetbox_remember_me"
@remember_me_options [
  sign: true,
  max_age: @max_age,
  same_site: "Lax",
  http_only: true,
  secure: Mix.env() == :prod
]
```

### Setting the Cookie

```elixir
def log_in_user(conn, user, params \\ %{}) do
  token = Accounts.generate_user_session_token(user)
  user_return_to = get_session(conn, :user_return_to)

  conn
  |> renew_session()
  |> put_token_in_session(token)
  |> maybe_write_remember_me_cookie(token, params)
  |> redirect(to: user_return_to || signed_in_path(conn))
end

defp maybe_write_remember_me_cookie(conn, token, %{"remember_me" => "true"}) do
  put_resp_cookie(conn, @remember_me_cookie, token, @remember_me_options)
end

defp maybe_write_remember_me_cookie(conn, _token, _params) do
  conn
end
```

### Reading the Cookie

```elixir
def fetch_current_user(conn, _opts) do
  {user_token, conn} = ensure_user_token(conn)
  user = user_token && Accounts.get_user_by_session_token(user_token)
  assign(conn, :current_user, user)
end

defp ensure_user_token(conn) do
  if token = get_session(conn, :user_token) do
    {token, conn}
  else
    conn = fetch_cookies(conn, signed: [@remember_me_cookie])

    if token = conn.cookies[@remember_me_cookie] do
      {token, put_token_in_session(conn, token)}
    else
      {nil, conn}
    end
  end
end
```

### Clearing on Logout

```elixir
def log_out_user(conn) do
  user_token = get_session(conn, :user_token)
  user_token && Accounts.delete_user_session_token(user_token)

  conn
  |> renew_session()
  |> delete_resp_cookie(@remember_me_cookie)
  |> redirect(to: ~p"/")
end
```

## Token Rotation

For enhanced security, rotate tokens on each use:

```elixir
# File: lib/snippetbox/accounts.ex

def get_user_by_session_token_and_rotate(old_token) do
  {:ok, query} = UserToken.verify_session_token_query(old_token)

  case Repo.one(query) do
    nil ->
      nil

    user ->
      # Delete old token
      delete_user_session_token(old_token)
      # Create new token
      new_token = generate_user_session_token(user)
      {user, new_token}
  end
end
```

```elixir
# In UserAuth
defp ensure_user_token(conn) do
  if token = get_session(conn, :user_token) do
    {token, conn}
  else
    conn = fetch_cookies(conn, signed: [@remember_me_cookie])

    if old_token = conn.cookies[@remember_me_cookie] do
      case Accounts.get_user_by_session_token_and_rotate(old_token) do
        {_user, new_token} ->
          conn =
            conn
            |> put_resp_cookie(@remember_me_cookie, new_token, @remember_me_options)
            |> put_token_in_session(new_token)

          {new_token, conn}

        nil ->
          conn = delete_resp_cookie(conn, @remember_me_cookie)
          {nil, conn}
      end
    else
      {nil, conn}
    end
  end
end
```

## Login Form with Remember Me

```heex
<%# File: lib/snippetbox_web/controllers/user_session_html/new.html.heex %>

<.form for={%{}} action={~p"/login"} as={:user}>
  <div class="space-y-4">
    <.input name="email" type="email" label="Email" required />
    <.input name="password" type="password" label="Password" required />
  </div>

  <div class="mt-4 flex items-center">
    <input
      type="checkbox"
      id="remember_me"
      name="remember_me"
      value="true"
      class="h-4 w-4 rounded border-gray-300 text-brand focus:ring-brand"
    />
    <label for="remember_me" class="ml-2 text-sm text-gray-600">
      Keep me logged in for 60 days
    </label>
  </div>

  <.button class="mt-6 w-full">Log in</.button>
</.form>
```

## Session Management Page

Allow users to view and revoke sessions:

```elixir
# File: lib/snippetbox/accounts.ex

def list_user_sessions(user) do
  UserToken
  |> where([t], t.user_id == ^user.id and t.context == "session")
  |> order_by([t], desc: t.inserted_at)
  |> Repo.all()
end

def delete_user_session(user, token_id) do
  UserToken
  |> where([t], t.id == ^token_id and t.user_id == ^user.id)
  |> Repo.delete_all()
end

def delete_all_user_sessions(user, except_token \\ nil) do
  query = from t in UserToken,
    where: t.user_id == ^user.id and t.context == "session"

  query =
    if except_token do
      where(query, [t], t.token != ^except_token)
    else
      query
    end

  Repo.delete_all(query)
end
```

### Sessions Controller

```elixir
# File: lib/snippetbox_web/controllers/user_sessions_controller.ex

defmodule SnippetboxWeb.UserSessionsController do
  use SnippetboxWeb, :controller

  alias Snippetbox.Accounts

  def index(conn, _params) do
    user = conn.assigns.current_user
    sessions = Accounts.list_user_sessions(user)
    current_token = get_session(conn, :user_token)

    render(conn, :index, sessions: sessions, current_token: current_token)
  end

  def delete(conn, %{"id" => id}) do
    user = conn.assigns.current_user
    Accounts.delete_user_session(user, id)

    conn
    |> put_flash(:info, "Session revoked.")
    |> redirect(to: ~p"/settings/sessions")
  end

  def delete_all(conn, _params) do
    user = conn.assigns.current_user
    current_token = get_session(conn, :user_token)

    Accounts.delete_all_user_sessions(user, current_token)

    conn
    |> put_flash(:info, "All other sessions have been logged out.")
    |> redirect(to: ~p"/settings/sessions")
  end
end
```

### Sessions Template

```heex
<%# File: lib/snippetbox_web/controllers/user_sessions_html/index.html.heex %>

<.header>
  Active Sessions
  <:subtitle>Manage your logged-in devices</:subtitle>
</.header>

<div class="mt-8 space-y-4">
  <%= for session <- @sessions do %>
    <div class="flex items-center justify-between p-4 border rounded-lg">
      <div>
        <p class="font-medium">
          <%= if session.token == @current_token do %>
            Current Session
          <% else %>
            Session
          <% end %>
        </p>
        <p class="text-sm text-gray-500">
          Created <%= format_datetime(session.inserted_at) %>
        </p>
      </div>

      <%= unless session.token == @current_token do %>
        <.link
          href={~p"/settings/sessions/#{session.id}"}
          method="delete"
          data-confirm="Are you sure?"
          class="text-red-600 hover:text-red-800"
        >
          Revoke
        </.link>
      <% end %>
    </div>
  <% end %>
</div>

<div class="mt-8">
  <.link
    href={~p"/settings/sessions/all"}
    method="delete"
    data-confirm="This will log you out from all other devices. Continue?"
    class="text-red-600 hover:text-red-800"
  >
    Log out from all other sessions
  </.link>
</div>
```

## Device Information

Optionally track device info:

```elixir
# Migration addition
add :user_agent, :string
add :ip_address, :string

# When creating token
def build_session_token(user, conn) do
  token = :crypto.strong_rand_bytes(@rand_size)

  {token, %__MODULE__{
    token: token,
    context: "session",
    user_id: user.id,
    user_agent: get_user_agent(conn),
    ip_address: get_ip_address(conn)
  }}
end

defp get_user_agent(conn) do
  conn
  |> Plug.Conn.get_req_header("user-agent")
  |> List.first()
  |> truncate(255)
end

defp get_ip_address(conn) do
  conn.remote_ip |> :inet.ntoa() |> to_string()
end
```

## Testing Remember Me

```elixir
# File: test/snippetbox_web/user_auth_test.exs

describe "remember me" do
  test "stores token in cookie when remember_me is true", %{conn: conn} do
    user = user_fixture()

    conn =
      post(conn, ~p"/login", %{
        "user" => %{
          "email" => user.email,
          "password" => valid_user_password(),
          "remember_me" => "true"
        }
      })

    assert conn.resp_cookies["_snippetbox_remember_me"]
  end

  test "does not store token when remember_me is false", %{conn: conn} do
    user = user_fixture()

    conn =
      post(conn, ~p"/login", %{
        "user" => %{
          "email" => user.email,
          "password" => valid_user_password()
        }
      })

    refute conn.resp_cookies["_snippetbox_remember_me"]
  end

  test "restores session from remember me cookie", %{conn: conn} do
    user = user_fixture()
    token = Accounts.generate_user_session_token(user)

    conn =
      conn
      |> put_req_cookie("_snippetbox_remember_me", token)
      |> get(~p"/")

    assert conn.assigns.current_user.id == user.id
  end

  test "clears remember me cookie on logout", %{conn: conn} do
    user = user_fixture()

    conn =
      conn
      |> log_in_user(user, %{"remember_me" => "true"})
      |> delete(~p"/logout")

    assert conn.resp_cookies["_snippetbox_remember_me"].max_age == 0
  end
end
```

> **FP Concept: Stateless Token Verification**
>
> Remember me tokens enable stateless authentication:
>
> ```elixir
> # Token is self-contained proof of identity
> token = signed_cookie_value
>
> # Verification is a pure lookup
> user = Accounts.get_user_by_session_token(token)
>
> # No server-side session state required
> ```
>
> The database stores tokens, but the verification process is statelessâ€”same token always maps to same user.

## Summary

In this chapter, we learned:

- How remember me authentication works
- Setting and reading remember me cookies
- Token rotation for security
- Session management interface
- Tracking device information
- Testing remember me functionality

In the next chapter, we'll implement password reset.
