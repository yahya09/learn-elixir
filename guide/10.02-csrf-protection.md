# Chapter 10.2: CSRF Protection

Cross-Site Request Forgery (CSRF) tricks users into performing unwanted actions. In this chapter, we'll explore how Phoenix protects against CSRF attacks.

## Understanding CSRF

### The Attack

```
1. Alice logs into bank.com (gets session cookie)
2. Alice visits malicious-site.com
3. Malicious site contains hidden form:
   <form action="https://bank.com/transfer" method="POST">
     <input name="to" value="attacker">
     <input name="amount" value="10000">
   </form>
   <script>document.forms[0].submit()</script>
4. Alice's browser sends request WITH her session cookie
5. Bank processes the "legitimate" request
6. Alice's money is transferred to attacker
```

### Why It Works

- Cookies are sent automatically with requests
- The server can't distinguish legitimate from forged requests
- The request looks exactly like a real user action

## Phoenix CSRF Protection

### How It Works

```
1. Server generates unique CSRF token
2. Token embedded in form as hidden field
3. Token also stored in session
4. On form submission, tokens are compared
5. Request rejected if tokens don't match
```

### Enabling CSRF Protection

```elixir
# File: lib/snippetbox_web/router.ex

pipeline :browser do
  plug :accepts, ["html"]
  plug :fetch_session
  plug :fetch_live_flash
  plug :put_root_layout, html: {SnippetboxWeb.Layouts, :root}
  plug :protect_from_forgery  # ← CSRF protection
  plug :put_secure_browser_headers
end
```

### Token in Forms

Phoenix automatically includes the token:

```heex
<.form for={@changeset} action={~p"/snippets"}>
  <%# Automatically generates: %>
  <%# <input type="hidden" name="_csrf_token" value="IwoGFgM..."> %>

  <.input field={@form[:title]} label="Title" />
  <.button>Save</.button>
</.form>
```

### Token in Meta Tag

For JavaScript requests:

```heex
<%# File: lib/snippetbox_web/components/layouts/root.html.heex %>

<head>
  <meta name="csrf-token" content={get_csrf_token()} />
  <%# ... %>
</head>
```

## CSRF in JavaScript

### Fetch API

```javascript
// Get token from meta tag
const csrfToken = document.querySelector("meta[name='csrf-token']").content;

// Include in fetch requests
fetch('/api/snippets', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken  // Phoenix checks this header
  },
  body: JSON.stringify({ title: 'New Snippet' })
});
```

### Axios

```javascript
// Configure Axios globally
import axios from 'axios';

const csrfToken = document.querySelector("meta[name='csrf-token']").content;

axios.defaults.headers.common['X-CSRF-Token'] = csrfToken;

// Now all requests include the token
axios.post('/api/snippets', { title: 'New Snippet' });
```

### Phoenix LiveView Socket

LiveView handles CSRF automatically:

```javascript
// assets/js/app.js
import { Socket } from "phoenix";
import { LiveSocket } from "phoenix_live_view";

let csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");

let liveSocket = new LiveSocket("/live", Socket, {
  params: { _csrf_token: csrfToken }  // Included automatically
});
```

## API Routes (No CSRF)

For API routes using token authentication, CSRF isn't needed:

```elixir
# File: lib/snippetbox_web/router.ex

pipeline :api do
  plug :accepts, ["json"]
  # No :protect_from_forgery
  # API uses Bearer token authentication instead
end

scope "/api", SnippetboxWeb.API do
  pipe_through :api

  resources "/snippets", SnippetController
end
```

### Why APIs Don't Need CSRF

- APIs use token-based authentication (Bearer tokens)
- Tokens are sent in Authorization header, not cookies
- Attackers can't forge the Authorization header
- CSRF relies on automatic cookie sending

## Custom CSRF Handling

### Skipping CSRF for Specific Routes

```elixir
# File: lib/snippetbox_web/router.ex

pipeline :browser_no_csrf do
  plug :accepts, ["html"]
  plug :fetch_session
  plug :fetch_live_flash
  plug :put_root_layout, html: {SnippetboxWeb.Layouts, :root}
  # No :protect_from_forgery
  plug :put_secure_browser_headers
end

# Webhook endpoints (external services can't include CSRF token)
scope "/webhooks", SnippetboxWeb do
  pipe_through :browser_no_csrf

  post "/stripe", WebhookController, :stripe
  post "/github", WebhookController, :github
end
```

### Verify Webhooks Differently

```elixir
# File: lib/snippetbox_web/controllers/webhook_controller.ex

defmodule SnippetboxWeb.WebhookController do
  use SnippetboxWeb, :controller

  def stripe(conn, params) do
    # Verify using Stripe's signature instead of CSRF
    signature = get_req_header(conn, "stripe-signature") |> List.first()
    payload = conn.assigns[:raw_body]

    case Stripe.Webhook.construct_event(payload, signature, webhook_secret()) do
      {:ok, event} ->
        handle_stripe_event(event)
        json(conn, %{status: "ok"})

      {:error, reason} ->
        conn
        |> put_status(:bad_request)
        |> json(%{error: reason})
    end
  end

  defp webhook_secret, do: Application.get_env(:snippetbox, :stripe_webhook_secret)
end
```

## CSRF Token Management

### Token Rotation

```elixir
# Tokens are tied to session
# Renewing session generates new token

def login(conn, params) do
  # After successful login
  conn
  |> configure_session(renew: true)  # New session = new CSRF token
  |> put_session(:user_id, user.id)
end
```

### Getting Token Programmatically

```elixir
# In controller or plug
def some_action(conn, _params) do
  token = Plug.CSRFProtection.get_csrf_token()
  # Use token...
end
```

### Validating Token Manually

```elixir
def custom_action(conn, %{"_csrf_token" => token}) do
  if Plug.CSRFProtection.valid_state_and_csrf_token?(
       Plug.CSRFProtection.get_csrf_token_for(token),
       token
     ) do
    # Valid token
  else
    # Invalid token
  end
end
```

## Double Submit Cookie

Alternative CSRF protection pattern:

```elixir
# File: lib/snippetbox_web/plugs/double_submit_csrf.ex

defmodule SnippetboxWeb.Plugs.DoubleSubmitCSRF do
  import Plug.Conn

  @cookie_name "_csrf_double"
  @header_name "x-csrf-token"

  def init(opts), do: opts

  def call(conn, _opts) do
    if safe_method?(conn.method) do
      ensure_token_cookie(conn)
    else
      validate_token(conn)
    end
  end

  defp safe_method?(method) when method in ["GET", "HEAD", "OPTIONS"], do: true
  defp safe_method?(_), do: false

  defp ensure_token_cookie(conn) do
    if conn.cookies[@cookie_name] do
      conn
    else
      token = generate_token()
      put_resp_cookie(conn, @cookie_name, token, http_only: false)
    end
  end

  defp validate_token(conn) do
    cookie_token = conn.cookies[@cookie_name]
    header_token = get_req_header(conn, @header_name) |> List.first()

    if cookie_token && cookie_token == header_token do
      conn
    else
      conn
      |> put_status(:forbidden)
      |> Phoenix.Controller.json(%{error: "Invalid CSRF token"})
      |> halt()
    end
  end

  defp generate_token do
    :crypto.strong_rand_bytes(32) |> Base.url_encode64()
  end
end
```

## Testing CSRF

### Controller Tests

```elixir
# File: test/snippetbox_web/controllers/snippet_controller_test.exs

describe "CSRF protection" do
  test "rejects POST without CSRF token", %{conn: conn} do
    conn =
      conn
      |> delete_req_header("x-csrf-token")
      |> post(~p"/snippets", snippet: %{title: "Test"})

    assert html_response(conn, 403)
  end

  test "accepts POST with valid CSRF token", %{conn: conn} do
    conn =
      conn
      |> get(~p"/snippets/new")  # Get token

    token = conn.cookies["_csrf_token"]

    conn =
      recycle(conn)
      |> put_req_header("x-csrf-token", token)
      |> post(~p"/snippets", snippet: %{title: "Test", content: "Code"})

    assert redirected_to(conn)
  end
end
```

### Integration Tests

```elixir
# ConnCase already handles CSRF for you
# But you can test explicitly:

test "form includes CSRF token", %{conn: conn} do
  conn = get(conn, ~p"/snippets/new")
  html = html_response(conn, 200)

  assert html =~ ~r/<input[^>]*name="_csrf_token"[^>]*>/
end
```

## Common Issues

### Token Mismatch After Deploy

```elixir
# If secret_key_base changes, all tokens become invalid
# Solution: Use consistent secret_key_base

# config/prod.exs
config :snippetbox, SnippetboxWeb.Endpoint,
  secret_key_base: System.get_env("SECRET_KEY_BASE")
```

### Ajax Requests Failing

```javascript
// Ensure token is included
const csrfToken = document.querySelector("meta[name='csrf-token']")?.content;

if (!csrfToken) {
  console.error("CSRF token not found!");
}

// Include in request
fetch(url, {
  headers: { 'X-CSRF-Token': csrfToken }
});
```

### Cross-Origin Requests

```elixir
# CORS requests from different origin won't have CSRF token
# Use API authentication instead

pipeline :api do
  plug CORSPlug
  plug :accepts, ["json"]
  plug :fetch_api_token  # Token auth, not CSRF
end
```

> **FP Concept: Stateless Verification**
>
> CSRF protection uses cryptographic verification:
>
> ```elixir
> # Token generation (deterministic from session)
> token = hmac(secret_key, session_id)
>
> # Verification (compare computed vs submitted)
> valid? = secure_compare(computed_token, submitted_token)
> ```
>
> The token isn't stored—it's computed from session data. This is a functional approach: same input always produces same output, no mutable state needed.

## Summary

In this chapter, we learned:

- How CSRF attacks work
- Phoenix's automatic CSRF protection
- Including tokens in forms and JavaScript
- API routes without CSRF
- Custom CSRF handling for webhooks
- Token management and rotation
- Testing CSRF protection
- Common issues and solutions

In the next chapter, we'll explore SQL injection prevention.
