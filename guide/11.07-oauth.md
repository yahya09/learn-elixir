# Chapter 11.7: OAuth Integration

OAuth allows users to sign in using third-party providers like GitHub, Google, or Twitter. In this chapter, we'll implement OAuth authentication.

## OAuth Flow

```
1. User clicks "Sign in with GitHub"
2. Redirect to GitHub authorization page
3. User authorizes your app
4. GitHub redirects back with code
5. Exchange code for access token
6. Fetch user info from GitHub
7. Create/login user in your app
```

## Dependencies

```elixir
# File: mix.exs

defp deps do
  [
    {:ueberauth, "~> 0.10"},
    {:ueberauth_github, "~> 0.8"}
  ]
end
```

## Configuration

### GitHub OAuth App

1. Go to GitHub Settings → Developer Settings → OAuth Apps
2. Create new OAuth App
3. Set Authorization callback URL: `http://localhost:4000/auth/github/callback`

### Application Config

```elixir
# File: config/config.exs

config :ueberauth, Ueberauth,
  providers: [
    github: {Ueberauth.Strategy.Github, [default_scope: "user:email"]}
  ]

# File: config/dev.exs

config :ueberauth, Ueberauth.Strategy.Github.OAuth,
  client_id: System.get_env("GITHUB_CLIENT_ID"),
  client_secret: System.get_env("GITHUB_CLIENT_SECRET")

# File: config/runtime.exs

config :ueberauth, Ueberauth.Strategy.Github.OAuth,
  client_id: System.get_env("GITHUB_CLIENT_ID"),
  client_secret: System.get_env("GITHUB_CLIENT_SECRET")
```

## Schema Updates

```elixir
# File: lib/snippetbox/accounts/user.ex

schema "users" do
  field :email, :string
  field :name, :string
  field :password, :string, virtual: true, redact: true
  field :hashed_password, :string, redact: true
  field :confirmed_at, :naive_datetime

  # OAuth fields
  field :provider, :string
  field :provider_id, :string
  field :avatar_url, :string

  timestamps()
end

@doc """
Changeset for OAuth registration.
"""
def oauth_changeset(user, attrs) do
  user
  |> cast(attrs, [:email, :name, :provider, :provider_id, :avatar_url])
  |> validate_required([:email, :provider, :provider_id])
  |> validate_email()
  |> unique_constraint(:email)
  |> unique_constraint([:provider, :provider_id])
  |> put_change(:confirmed_at, NaiveDateTime.utc_now() |> NaiveDateTime.truncate(:second))
end
```

## Migration

```elixir
# File: priv/repo/migrations/YYYYMMDDHHMMSS_add_oauth_fields_to_users.exs

defmodule Snippetbox.Repo.Migrations.AddOauthFieldsToUsers do
  use Ecto.Migration

  def change do
    alter table(:users) do
      add :provider, :string
      add :provider_id, :string
      add :avatar_url, :string
      modify :hashed_password, :string, null: true  # OAuth users don't have passwords
    end

    create unique_index(:users, [:provider, :provider_id])
  end
end
```

## Auth Controller

```elixir
# File: lib/snippetbox_web/controllers/auth_controller.ex

defmodule SnippetboxWeb.AuthController do
  use SnippetboxWeb, :controller
  plug Ueberauth

  alias Snippetbox.Accounts
  alias SnippetboxWeb.UserAuth

  def callback(%{assigns: %{ueberauth_failure: _fails}} = conn, _params) do
    conn
    |> put_flash(:error, "Failed to authenticate.")
    |> redirect(to: ~p"/login")
  end

  def callback(%{assigns: %{ueberauth_auth: auth}} = conn, _params) do
    user_params = %{
      email: auth.info.email,
      name: auth.info.name || auth.info.nickname,
      provider: to_string(auth.provider),
      provider_id: to_string(auth.uid),
      avatar_url: auth.info.image
    }

    case Accounts.find_or_create_oauth_user(user_params) do
      {:ok, user} ->
        conn
        |> put_flash(:info, "Successfully authenticated!")
        |> UserAuth.log_in_user(user)

      {:error, reason} ->
        conn
        |> put_flash(:error, "Error: #{reason}")
        |> redirect(to: ~p"/login")
    end
  end

  def delete(conn, _params) do
    conn
    |> put_flash(:info, "Logged out successfully.")
    |> UserAuth.log_out_user()
  end
end
```

## Context Functions

```elixir
# File: lib/snippetbox/accounts.ex

@doc """
Finds or creates a user from OAuth data.
"""
def find_or_create_oauth_user(attrs) do
  case get_user_by_provider(attrs.provider, attrs.provider_id) do
    nil ->
      # Check if email already exists
      case get_user_by_email(attrs.email) do
        nil ->
          create_oauth_user(attrs)

        existing_user ->
          # Link OAuth to existing account
          link_oauth_to_user(existing_user, attrs)
      end

    user ->
      # Update user info from OAuth
      update_oauth_user(user, attrs)
  end
end

def get_user_by_provider(provider, provider_id) do
  Repo.get_by(User, provider: provider, provider_id: provider_id)
end

defp create_oauth_user(attrs) do
  %User{}
  |> User.oauth_changeset(attrs)
  |> Repo.insert()
end

defp link_oauth_to_user(user, attrs) do
  user
  |> User.oauth_changeset(%{
    provider: attrs.provider,
    provider_id: attrs.provider_id,
    avatar_url: attrs.avatar_url
  })
  |> Repo.update()
end

defp update_oauth_user(user, attrs) do
  user
  |> User.oauth_changeset(%{
    name: attrs.name,
    avatar_url: attrs.avatar_url
  })
  |> Repo.update()
end
```

## Router

```elixir
# File: lib/snippetbox_web/router.ex

scope "/auth", SnippetboxWeb do
  pipe_through [:browser, :redirect_if_user_is_authenticated]

  get "/:provider", AuthController, :request
  get "/:provider/callback", AuthController, :callback
  post "/:provider/callback", AuthController, :callback
end
```

## Login Page with OAuth

```heex
<%# File: lib/snippetbox_web/controllers/user_session_html/new.html.heex %>

<div class="mx-auto max-w-md">
  <.header class="text-center">
    Log In
  </.header>

  <div class="mt-8 space-y-4">
    <a
      href={~p"/auth/github"}
      class="flex items-center justify-center gap-2 w-full px-4 py-2 border rounded-lg hover:bg-gray-50"
    >
      <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
        <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/>
      </svg>
      Continue with GitHub
    </a>
  </div>

  <div class="relative my-6">
    <div class="absolute inset-0 flex items-center">
      <div class="w-full border-t border-gray-300"></div>
    </div>
    <div class="relative flex justify-center text-sm">
      <span class="px-2 bg-white text-gray-500">Or continue with email</span>
    </div>
  </div>

  <.form for={%{}} action={~p"/login"} as={:user}>
    <div class="space-y-4">
      <.input name="email" type="email" label="Email" required />
      <.input name="password" type="password" label="Password" required />
    </div>
    <.button class="mt-6 w-full">Log in</.button>
  </.form>
</div>
```

## Multiple Providers

### Adding Google

```elixir
# mix.exs
{:ueberauth_google, "~> 0.10"}

# config/config.exs
config :ueberauth, Ueberauth,
  providers: [
    github: {Ueberauth.Strategy.Github, [default_scope: "user:email"]},
    google: {Ueberauth.Strategy.Google, [default_scope: "email profile"]}
  ]

# config/runtime.exs
config :ueberauth, Ueberauth.Strategy.Google.OAuth,
  client_id: System.get_env("GOOGLE_CLIENT_ID"),
  client_secret: System.get_env("GOOGLE_CLIENT_SECRET")
```

### Provider Buttons

```heex
<div class="space-y-3">
  <a href={~p"/auth/github"} class="oauth-button">
    <.icon name="github" /> Continue with GitHub
  </a>

  <a href={~p"/auth/google"} class="oauth-button">
    <.icon name="google" /> Continue with Google
  </a>

  <a href={~p"/auth/twitter"} class="oauth-button">
    <.icon name="twitter" /> Continue with Twitter
  </a>
</div>
```

## Account Linking

Allow users to link multiple OAuth providers:

```elixir
# File: lib/snippetbox/accounts/user_identity.ex

defmodule Snippetbox.Accounts.UserIdentity do
  use Ecto.Schema
  import Ecto.Changeset

  schema "user_identities" do
    field :provider, :string
    field :provider_id, :string
    field :provider_email, :string
    field :provider_name, :string
    field :avatar_url, :string

    belongs_to :user, Snippetbox.Accounts.User

    timestamps()
  end

  def changeset(identity, attrs) do
    identity
    |> cast(attrs, [:provider, :provider_id, :provider_email, :provider_name, :avatar_url])
    |> validate_required([:provider, :provider_id])
    |> unique_constraint([:provider, :provider_id])
  end
end
```

### Migration

```elixir
defmodule Snippetbox.Repo.Migrations.CreateUserIdentities do
  use Ecto.Migration

  def change do
    create table(:user_identities) do
      add :user_id, references(:users, on_delete: :delete_all), null: false
      add :provider, :string, null: false
      add :provider_id, :string, null: false
      add :provider_email, :string
      add :provider_name, :string
      add :avatar_url, :string

      timestamps()
    end

    create index(:user_identities, [:user_id])
    create unique_index(:user_identities, [:provider, :provider_id])
  end
end
```

## Security Considerations

### State Parameter

Ueberauth handles CSRF via state parameter automatically.

### Token Storage

Never store OAuth tokens unless needed for API access:

```elixir
# Only store if you need to make API calls
def callback(%{assigns: %{ueberauth_auth: auth}} = conn, _params) do
  credentials = auth.credentials

  # Store encrypted if needed
  if credentials.refresh_token do
    Accounts.store_oauth_credentials(user, %{
      access_token: encrypt(credentials.token),
      refresh_token: encrypt(credentials.refresh_token),
      expires_at: credentials.expires_at
    })
  end
end
```

### Scope Minimization

Only request scopes you need:

```elixir
# Minimal scope
config :ueberauth, Ueberauth,
  providers: [
    github: {Ueberauth.Strategy.Github, [default_scope: "user:email"]}
  ]
```

## Testing OAuth

```elixir
# File: test/snippetbox_web/controllers/auth_controller_test.exs

defmodule SnippetboxWeb.AuthControllerTest do
  use SnippetboxWeb.ConnCase

  describe "callback/2" do
    test "creates new user from OAuth", %{conn: conn} do
      auth = %Ueberauth.Auth{
        provider: :github,
        uid: "12345",
        info: %Ueberauth.Auth.Info{
          email: "oauth@example.com",
          name: "OAuth User",
          image: "https://example.com/avatar.png"
        }
      }

      conn =
        conn
        |> assign(:ueberauth_auth, auth)
        |> get(~p"/auth/github/callback")

      assert redirected_to(conn) == ~p"/"
      assert get_session(conn, :user_token)

      user = Snippetbox.Accounts.get_user_by_email("oauth@example.com")
      assert user.provider == "github"
      assert user.provider_id == "12345"
    end

    test "logs in existing OAuth user", %{conn: conn} do
      {:ok, existing} = Snippetbox.Accounts.create_oauth_user(%{
        email: "existing@example.com",
        name: "Existing",
        provider: "github",
        provider_id: "12345"
      })

      auth = %Ueberauth.Auth{
        provider: :github,
        uid: "12345",
        info: %Ueberauth.Auth.Info{
          email: "existing@example.com",
          name: "Updated Name"
        }
      }

      conn =
        conn
        |> assign(:ueberauth_auth, auth)
        |> get(~p"/auth/github/callback")

      assert redirected_to(conn) == ~p"/"

      # Name should be updated
      user = Snippetbox.Accounts.get_user!(existing.id)
      assert user.name == "Updated Name"
    end

    test "handles OAuth failure", %{conn: conn} do
      conn =
        conn
        |> assign(:ueberauth_failure, %Ueberauth.Failure{})
        |> get(~p"/auth/github/callback")

      assert redirected_to(conn) == ~p"/login"
      assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ "Failed"
    end
  end
end
```

> **FP Concept: External State Integration**
>
> OAuth integrates external state (third-party identity) with local state:
>
> ```elixir
> # External: OAuth provider data
> auth = %{provider: "github", uid: "123", email: "..."}
>
> # Transform to local representation
> user_params = transform_oauth_to_user(auth)
>
> # Persist locally
> {:ok, user} = find_or_create_user(user_params)
> ```
>
> The transformation is explicit, making the boundary between external and internal data clear.

## Summary

In this chapter, we learned:

- OAuth authentication flow
- Setting up Ueberauth
- Configuring OAuth providers
- Creating OAuth users
- Account linking
- Multiple provider support
- Security considerations
- Testing OAuth flows

This completes the Authentication chapter. In the next chapter, we'll explore Phoenix LiveView.
