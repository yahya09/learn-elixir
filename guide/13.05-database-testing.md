# Chapter 13.5: Database Testing

Database testing requires careful handling of state and isolation. In this chapter, we'll explore Ecto testing strategies.

## SQL Sandbox

The SQL Sandbox wraps each test in a transaction that rolls back:

```elixir
# File: test/test_helper.exs

ExUnit.start()
Ecto.Adapters.SQL.Sandbox.mode(Snippetbox.Repo, :manual)
```

```elixir
# File: test/support/data_case.ex

defmodule Snippetbox.DataCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      alias Snippetbox.Repo

      import Ecto
      import Ecto.Changeset
      import Ecto.Query
      import Snippetbox.DataCase
    end
  end

  setup tags do
    Snippetbox.DataCase.setup_sandbox(tags)
    :ok
  end

  def setup_sandbox(tags) do
    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(Snippetbox.Repo, shared: not tags[:async])
    on_exit(fn -> Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)
  end
end
```

### Async vs Shared Mode

```elixir
# Async mode: each test has its own connection
# Tests run in parallel, isolated from each other
use Snippetbox.DataCase, async: true

# Shared mode: all tests share one connection
# Required for tests that spawn processes (LiveView, etc.)
use Snippetbox.DataCase, async: false
```

## Testing Queries

```elixir
# File: test/snippetbox/snippets_test.exs

defmodule Snippetbox.SnippetsTest do
  use Snippetbox.DataCase, async: true

  alias Snippetbox.Snippets
  alias Snippetbox.Snippets.Snippet

  import Snippetbox.SnippetsFixtures
  import Snippetbox.AccountsFixtures

  describe "list_snippets/1" do
    test "returns empty list when no snippets" do
      assert Snippets.list_snippets() == []
    end

    test "returns all snippets" do
      snippet1 = snippet_fixture()
      snippet2 = snippet_fixture()

      assert Snippets.list_snippets() == [snippet1, snippet2]
    end

    test "filters by language" do
      elixir = snippet_fixture(%{language: "elixir"})
      _python = snippet_fixture(%{language: "python"})

      assert Snippets.list_snippets(language: "elixir") == [elixir]
    end

    test "filters by user" do
      user1 = user_fixture()
      user2 = user_fixture()

      snippet1 = snippet_fixture(%{user_id: user1.id})
      _snippet2 = snippet_fixture(%{user_id: user2.id})

      assert Snippets.list_snippets(user_id: user1.id) == [snippet1]
    end

    test "orders by inserted_at desc" do
      old = snippet_fixture()
      # Ensure different timestamp
      Process.sleep(10)
      new = snippet_fixture()

      [first, second] = Snippets.list_snippets(order_by: [desc: :inserted_at])
      assert first.id == new.id
      assert second.id == old.id
    end

    test "paginates results" do
      for _ <- 1..15, do: snippet_fixture()

      page1 = Snippets.list_snippets(page: 1, per_page: 10)
      page2 = Snippets.list_snippets(page: 2, per_page: 10)

      assert length(page1) == 10
      assert length(page2) == 5
    end
  end

  describe "search_snippets/1" do
    test "searches title" do
      match = snippet_fixture(%{title: "Elixir GenServer"})
      _nomatch = snippet_fixture(%{title: "Python Script"})

      assert Snippets.search_snippets("genserver") == [match]
    end

    test "searches content" do
      match = snippet_fixture(%{content: "defmodule GenServer do"})
      _nomatch = snippet_fixture(%{content: "print('hello')"})

      assert Snippets.search_snippets("defmodule") == [match]
    end

    test "is case insensitive" do
      snippet = snippet_fixture(%{title: "UPPERCASE TITLE"})

      assert Snippets.search_snippets("uppercase") == [snippet]
      assert Snippets.search_snippets("UPPERCASE") == [snippet]
    end

    test "returns empty for no match" do
      snippet_fixture()

      assert Snippets.search_snippets("nonexistent") == []
    end
  end
end
```

## Testing Associations

```elixir
describe "associations" do
  test "snippet belongs to user" do
    user = user_fixture()
    snippet = snippet_fixture(%{user_id: user.id})

    snippet = Repo.preload(snippet, :user)
    assert snippet.user.id == user.id
  end

  test "user has many snippets" do
    user = user_fixture()
    snippet1 = snippet_fixture(%{user_id: user.id})
    snippet2 = snippet_fixture(%{user_id: user.id})

    user = Repo.preload(user, :snippets)
    assert length(user.snippets) == 2
    assert snippet1 in user.snippets
    assert snippet2 in user.snippets
  end

  test "snippet has many comments" do
    snippet = snippet_fixture()
    comment1 = comment_fixture(%{snippet_id: snippet.id})
    comment2 = comment_fixture(%{snippet_id: snippet.id})

    snippet = Repo.preload(snippet, :comments)
    assert length(snippet.comments) == 2
  end

  test "deleting snippet deletes comments" do
    snippet = snippet_fixture()
    comment = comment_fixture(%{snippet_id: snippet.id})

    Snippets.delete_snippet(snippet)

    assert Repo.get(Comment, comment.id) == nil
  end
end
```

## Testing Transactions

```elixir
describe "transactions" do
  test "creates snippet with tags atomically" do
    attrs = %{
      title: "Test",
      content: "code",
      language: "elixir",
      tags: [%{name: "elixir"}, %{name: "tutorial"}]
    }

    {:ok, snippet} = Snippets.create_snippet_with_tags(attrs)

    snippet = Repo.preload(snippet, :tags)
    assert length(snippet.tags) == 2
  end

  test "rolls back on failure" do
    attrs = %{
      title: "Test",
      content: "code",
      language: "elixir",
      tags: [%{name: nil}]  # Invalid tag
    }

    {:error, :tags, _changeset, _} = Snippets.create_snippet_with_tags(attrs)

    # Snippet was not created
    assert Snippets.list_snippets() == []
  end
end
```

## Testing Constraints

```elixir
describe "constraints" do
  test "email must be unique" do
    user_fixture(%{email: "test@example.com"})

    {:error, changeset} =
      Snippetbox.Accounts.register_user(%{
        email: "test@example.com",
        password: "validpassword123"
      })

    assert "has already been taken" in errors_on(changeset).email
  end

  test "foreign key constraint" do
    {:error, changeset} =
      Snippets.create_snippet(%{
        title: "Test",
        content: "code",
        language: "elixir",
        user_id: 999999  # Non-existent user
      })

    assert "does not exist" in errors_on(changeset).user
  end

  test "check constraint" do
    {:error, changeset} =
      Snippets.create_snippet(%{
        title: "Test",
        content: "code",
        language: "elixir",
        view_count: -1  # Check constraint: view_count >= 0
      })

    assert "must be greater than or equal to 0" in errors_on(changeset).view_count
  end
end
```

## Testing Migrations

```elixir
# File: test/snippetbox/repo_test.exs

defmodule Snippetbox.RepoTest do
  use Snippetbox.DataCase, async: false

  describe "migrations" do
    test "all migrations run successfully" do
      # This test verifies that the test database was migrated
      assert {:ok, _} = Ecto.Adapters.SQL.query(Repo, "SELECT 1")
    end

    test "snippets table exists with expected columns" do
      {:ok, result} = Ecto.Adapters.SQL.query(Repo, """
        SELECT column_name, data_type
        FROM information_schema.columns
        WHERE table_name = 'snippets'
        ORDER BY ordinal_position
      """)

      columns = Enum.map(result.rows, fn [name, _type] -> name end)

      assert "id" in columns
      assert "title" in columns
      assert "content" in columns
      assert "language" in columns
      assert "inserted_at" in columns
      assert "updated_at" in columns
    end
  end
end
```

## Testing with Seeds

```elixir
# File: test/support/seeds.ex

defmodule Snippetbox.TestSeeds do
  alias Snippetbox.Repo
  alias Snippetbox.Accounts.User
  alias Snippetbox.Snippets.Snippet

  def seed_users(count \\ 5) do
    for i <- 1..count do
      %User{}
      |> User.registration_changeset(%{
        email: "user#{i}@test.com",
        password: "password123456"
      })
      |> Repo.insert!()
    end
  end

  def seed_snippets(user, count \\ 10) do
    for i <- 1..count do
      %Snippet{}
      |> Snippet.changeset(%{
        title: "Snippet #{i}",
        content: "Code #{i}",
        language: Enum.random(~w(elixir python javascript)),
        user_id: user.id
      })
      |> Repo.insert!()
    end
  end
end

# Usage in tests
defmodule Snippetbox.PaginationTest do
  use Snippetbox.DataCase

  alias Snippetbox.TestSeeds

  setup do
    [user | _] = TestSeeds.seed_users(1)
    TestSeeds.seed_snippets(user, 50)
    %{user: user}
  end

  test "paginates through all snippets" do
    page1 = Snippets.list_snippets(page: 1, per_page: 20)
    page2 = Snippets.list_snippets(page: 2, per_page: 20)
    page3 = Snippets.list_snippets(page: 3, per_page: 20)

    assert length(page1) == 20
    assert length(page2) == 20
    assert length(page3) == 10
  end
end
```

## Fixtures

```elixir
# File: test/support/fixtures/snippets_fixtures.ex

defmodule Snippetbox.SnippetsFixtures do
  alias Snippetbox.Snippets

  def unique_snippet_title, do: "snippet#{System.unique_integer()}"

  def valid_snippet_attributes(attrs \\ %{}) do
    Enum.into(attrs, %{
      title: unique_snippet_title(),
      content: "defmodule Test do\nend",
      language: "elixir"
    })
  end

  def snippet_fixture(attrs \\ %{}) do
    user_id = attrs[:user_id] || Snippetbox.AccountsFixtures.user_fixture().id

    {:ok, snippet} =
      attrs
      |> Enum.into(%{user_id: user_id})
      |> valid_snippet_attributes()
      |> Snippets.create_snippet()

    snippet
  end
end
```

## Testing Aggregations

```elixir
describe "aggregations" do
  test "count_snippets/0" do
    assert Snippets.count_snippets() == 0

    snippet_fixture()
    snippet_fixture()
    snippet_fixture()

    assert Snippets.count_snippets() == 3
  end

  test "count_by_language/0" do
    snippet_fixture(%{language: "elixir"})
    snippet_fixture(%{language: "elixir"})
    snippet_fixture(%{language: "python"})

    counts = Snippets.count_by_language()

    assert counts["elixir"] == 2
    assert counts["python"] == 1
  end

  test "total_views/0" do
    snippet_fixture(%{view_count: 100})
    snippet_fixture(%{view_count: 50})

    assert Snippets.total_views() == 150
  end

  test "most_viewed/1" do
    low = snippet_fixture(%{view_count: 10})
    high = snippet_fixture(%{view_count: 100})
    medium = snippet_fixture(%{view_count: 50})

    [first, second] = Snippets.most_viewed(2)

    assert first.id == high.id
    assert second.id == medium.id
  end
end
```

## Testing Complex Queries

```elixir
describe "complex queries" do
  test "snippets_with_comment_count" do
    snippet1 = snippet_fixture()
    snippet2 = snippet_fixture()

    comment_fixture(%{snippet_id: snippet1.id})
    comment_fixture(%{snippet_id: snippet1.id})
    comment_fixture(%{snippet_id: snippet2.id})

    results = Snippets.list_with_comment_counts()

    snippet1_result = Enum.find(results, &(&1.id == snippet1.id))
    snippet2_result = Enum.find(results, &(&1.id == snippet2.id))

    assert snippet1_result.comment_count == 2
    assert snippet2_result.comment_count == 1
  end

  test "recent_with_authors" do
    user = user_fixture(%{name: "Test User"})
    snippet = snippet_fixture(%{user_id: user.id})

    [result] = Snippets.recent_with_authors(10)

    assert result.id == snippet.id
    assert result.user.name == "Test User"
  end
end
```

> **FP Concept: Isolated Test State**
>
> The SQL Sandbox provides isolation without shared mutable state:
>
> ```elixir
> # Each test starts with a clean database
> setup do
>   Ecto.Adapters.SQL.Sandbox.checkout(Repo)
>   :ok
> end
>
> # Changes are wrapped in a transaction
> test "creates data" do
>   snippet_fixture()  # Only visible to this test
>   assert Snippets.count() == 1
> end
>
> # Transaction is rolled back after test
> # Next test sees empty database
> ```
>
> This ensures tests are independent and reproducible.

## Summary

In this chapter, we learned:

- SQL Sandbox for test isolation
- Testing queries and filters
- Testing associations
- Testing transactions
- Testing constraints
- Testing migrations
- Using fixtures effectively
- Testing aggregations and complex queries

In the next chapter, we'll explore test coverage and best practices.
