# Chapter 4.3: Ecto Schemas

Schemas define how your database tables map to Elixir structs. In this chapter, we'll create a schema for our snippets and understand how Ecto transforms database rows into Elixir data.

## What is a Schema?

An Ecto schema:

1. **Maps** database columns to struct fields
2. **Defines** field types for casting and validation
3. **Declares** associations between tables
4. **Provides** a struct for working with data

## Creating a Snippet Schema

### Generate with Mix

```bash
$ mix phx.gen.schema Snippets.Snippet snippets title:string content:text expires_at:utc_datetime
* creating lib/snippetbox/snippets/snippet.ex
```

### Manual Creation

```elixir
# File: lib/snippetbox/snippets/snippet.ex

defmodule Snippetbox.Snippets.Snippet do
  use Ecto.Schema
  import Ecto.Changeset

  schema "snippets" do
    field :title, :string
    field :content, :string
    field :expires_at, :utc_datetime

    timestamps(type: :utc_datetime)
  end

  @doc false
  def changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :expires_at])
    |> validate_required([:title, :content])
  end
end
```

## Schema Structure

### The `schema` Block

```elixir
schema "snippets" do          # "snippets" is the table name
  field :title, :string       # Maps title column to :title field
  field :content, :string
  field :views, :integer, default: 0
  field :is_public, :boolean, default: true

  timestamps()                # Adds :inserted_at and :updated_at
end
```

### Field Types

| Schema Type | Elixir Type | Database Type |
|-------------|-------------|---------------|
| `:string` | `String.t()` | `varchar` |
| `:integer` | `integer()` | `integer` |
| `:float` | `float()` | `float` |
| `:decimal` | `Decimal.t()` | `decimal` |
| `:boolean` | `boolean()` | `boolean` |
| `:date` | `Date.t()` | `date` |
| `:time` | `Time.t()` | `time` |
| `:naive_datetime` | `NaiveDateTime.t()` | `timestamp` |
| `:utc_datetime` | `DateTime.t()` | `timestamptz` |
| `:uuid` | `String.t()` | `uuid` |
| `:binary` | `binary()` | `bytea` |
| `:map` | `map()` | `jsonb` |
| `{:array, :string}` | `[String.t()]` | `varchar[]` |

### Field Options

```elixir
schema "snippets" do
  field :title, :string                         # Required in migration
  field :views, :integer, default: 0            # Default value
  field :metadata, :map, default: %{}           # Default empty map
  field :password, :string, virtual: true       # Not persisted
  field :password_hash, :string, redact: true   # Hidden in logs
  field :type, :string, source: :snippet_type   # Different column name
end
```

### Timestamps

```elixir
# Default (naive_datetime)
timestamps()

# With timezone (recommended)
timestamps(type: :utc_datetime)

# Custom field names
timestamps(inserted_at: :created_at, updated_at: :modified_at)

# Disable one
timestamps(updated_at: false)
```

## Primary Keys

### Auto-incrementing Integer (Default)

```elixir
schema "snippets" do
  # id field is automatically added as :id, :bigserial
end
```

### UUID Primary Key

```elixir
# In schema
@primary_key {:id, :binary_id, autogenerate: true}
@foreign_key_type :binary_id

schema "snippets" do
  field :title, :string
  # ...
end
```

```elixir
# In migration
create table(:snippets, primary_key: false) do
  add :id, :binary_id, primary_key: true
  # ...
end
```

### Application-wide UUID

```elixir
# File: lib/snippetbox/schema.ex

defmodule Snippetbox.Schema do
  defmacro __using__(_) do
    quote do
      use Ecto.Schema
      @primary_key {:id, :binary_id, autogenerate: true}
      @foreign_key_type :binary_id
    end
  end
end

# Usage in schemas
defmodule Snippetbox.Snippets.Snippet do
  use Snippetbox.Schema  # Instead of use Ecto.Schema
  # ...
end
```

## Working with Schemas

### Creating Structs

```elixir
# Empty struct
%Snippetbox.Snippets.Snippet{}
# => %Snippet{id: nil, title: nil, content: nil, ...}

# With values
%Snippet{title: "Hello", content: "World"}

# Alias for convenience
alias Snippetbox.Snippets.Snippet
%Snippet{title: "Hello"}
```

### Querying Returns Structs

```elixir
alias Snippetbox.Repo
alias Snippetbox.Snippets.Snippet

# Returns a Snippet struct
Repo.get(Snippet, 1)
# => %Snippet{id: 1, title: "Example", content: "..."}

# Returns list of Snippet structs
Repo.all(Snippet)
# => [%Snippet{...}, %Snippet{...}]
```

### Accessing Fields

```elixir
snippet = Repo.get!(Snippet, 1)

snippet.title      # => "Example"
snippet.content    # => "Hello World"
snippet.id         # => 1

# Pattern matching
%Snippet{title: title} = snippet
title  # => "Example"
```

## The Complete Snippet Schema

```elixir
# File: lib/snippetbox/snippets/snippet.ex

defmodule Snippetbox.Snippets.Snippet do
  @moduledoc """
  Schema for code snippets.
  """

  use Ecto.Schema
  import Ecto.Changeset

  schema "snippets" do
    field :title, :string
    field :content, :string
    field :language, :string, default: "text"
    field :expires_at, :utc_datetime
    field :is_public, :boolean, default: true
    field :views_count, :integer, default: 0

    timestamps(type: :utc_datetime)
  end

  @required_fields [:title, :content]
  @optional_fields [:language, :expires_at, :is_public]

  @doc """
  Creates a changeset for creating/updating a snippet.
  """
  def changeset(snippet, attrs) do
    snippet
    |> cast(attrs, @required_fields ++ @optional_fields)
    |> validate_required(@required_fields)
    |> validate_length(:title, min: 1, max: 100)
    |> validate_length(:content, min: 1, max: 100_000)
    |> validate_inclusion(:language, supported_languages())
  end

  @doc """
  List of supported syntax highlighting languages.
  """
  def supported_languages do
    ~w(text elixir ruby python javascript go rust java c cpp)
  end
end
```

## Schema Introspection

```elixir
alias Snippetbox.Snippets.Snippet

# Get table name
Snippet.__schema__(:source)
# => "snippets"

# Get all fields
Snippet.__schema__(:fields)
# => [:id, :title, :content, :language, :expires_at, :is_public, :views_count, :inserted_at, :updated_at]

# Get field type
Snippet.__schema__(:type, :title)
# => :string

# Get primary key
Snippet.__schema__(:primary_key)
# => [:id]
```

## Virtual Fields

Virtual fields exist on the struct but not in the database:

```elixir
schema "users" do
  field :email, :string
  field :password_hash, :string

  # Virtual - not persisted
  field :password, :string, virtual: true
  field :password_confirmation, :string, virtual: true
end

def registration_changeset(user, attrs) do
  user
  |> cast(attrs, [:email, :password, :password_confirmation])
  |> validate_required([:email, :password, :password_confirmation])
  |> validate_confirmation(:password)
  |> hash_password()
end

defp hash_password(changeset) do
  case changeset do
    %{valid?: true, changes: %{password: password}} ->
      put_change(changeset, :password_hash, Bcrypt.hash_pwd_salt(password))
    _ ->
      changeset
  end
end
```

## Embedded Schemas

For nested data stored as JSON:

```elixir
defmodule Snippetbox.Snippets.Snippet do
  use Ecto.Schema

  schema "snippets" do
    field :title, :string
    embeds_one :metadata, Metadata
    timestamps()
  end
end

defmodule Snippetbox.Snippets.Snippet.Metadata do
  use Ecto.Schema

  @primary_key false
  embedded_schema do
    field :syntax_theme, :string, default: "monokai"
    field :line_numbers, :boolean, default: true
    field :word_wrap, :boolean, default: false
  end
end
```

Usage:

```elixir
%Snippet{
  title: "Example",
  metadata: %Metadata{
    syntax_theme: "dracula",
    line_numbers: true
  }
}
```

> **FP Concept: Data Transformation**
>
> Schemas define a transformation between two representations:
>
> ```
> Database Row (map with strings)
>        ↓ load
> Elixir Struct (typed fields)
>        ↓ dump
> Database Row
> ```
>
> This is similar to serialization/deserialization, but with automatic type coercion:
>
> ```elixir
> # Database returns: %{"title" => "Hello", "views_count" => "42"}
> # Schema transforms to: %Snippet{title: "Hello", views_count: 42}
> ```
>
> The schema acts as a contract defining the shape of your data.
>
> **Further Reading**:
> - [Ecto.Schema](https://hexdocs.pm/ecto/Ecto.Schema.html)

## Summary

In this chapter, we learned:

- Creating schemas with `use Ecto.Schema`
- Mapping database columns to struct fields
- Field types and options
- Primary key configuration
- Virtual and embedded fields
- Schema introspection

In the next chapter, we'll learn about changesets for validating and transforming data.

---

## Additional Information

### Schema vs Migration Types

Schemas and migrations use slightly different type names:

| Migration | Schema |
|-----------|--------|
| `:text` | `:string` |
| `:timestamptz` | `:utc_datetime` |
| `references(:users)` | `belongs_to :user, User` |

### Read-Only Schemas

For database views or external tables:

```elixir
defmodule Snippetbox.Reports.SnippetStats do
  use Ecto.Schema

  @primary_key false
  schema "snippet_stats_view" do
    field :snippet_id, :integer
    field :total_views, :integer
    field :unique_viewers, :integer
  end
end
```

### Comparing to Other ORMs

**ActiveRecord (Rails)**:
```ruby
class Snippet < ApplicationRecord
  # Schema inferred from database
end
```

**Django**:
```python
class Snippet(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
```

**Ecto**:
```elixir
schema "snippets" do
  field :title, :string
  field :content, :string
end
```

Ecto requires explicit schema definition, providing better type safety and documentation.
