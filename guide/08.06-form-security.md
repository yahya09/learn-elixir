# Chapter 8.6: Form Security

Forms are a common attack vector. In this chapter, we'll explore security measures to protect your Phoenix application from form-based attacks.

## CSRF Protection

### What is CSRF?

Cross-Site Request Forgery (CSRF) tricks users into submitting malicious requests:

```
1. User logs into yoursite.com
2. User visits malicious-site.com
3. Malicious site contains:
   <form action="https://yoursite.com/transfer" method="post">
     <input name="amount" value="10000">
     <input name="to" value="attacker">
   </form>
   <script>document.forms[0].submit()</script>
4. Browser sends request with user's session cookie
5. Server processes unauthorized request
```

### Phoenix CSRF Protection

Phoenix automatically generates and validates CSRF tokens:

```elixir
# File: lib/snippetbox_web/router.ex

pipeline :browser do
  plug :accepts, ["html"]
  plug :fetch_session
  plug :fetch_live_flash
  plug :put_root_layout, html: {SnippetboxWeb.Layouts, :root}
  plug :protect_from_forgery  # ‚Üê CSRF protection
  plug :put_secure_browser_headers
end
```

### How It Works

```heex
<%# Phoenix automatically includes CSRF token in forms %>
<.form for={@changeset} action={~p"/snippets"}>
  <%# Generates: %>
  <%# <input type="hidden" name="_csrf_token" value="abc123..."> %>
</.form>
```

The token is validated on POST/PUT/PATCH/DELETE requests.

### Token in AJAX Requests

For JavaScript requests, include the token from the meta tag:

```heex
<%# In root layout %>
<meta name="csrf-token" content={get_csrf_token()} />
```

```javascript
// In JavaScript
const csrfToken = document.querySelector("meta[name='csrf-token']").content;

fetch('/api/snippets', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  },
  body: JSON.stringify(data)
});
```

### Disabling CSRF (API Routes)

For API routes with token authentication, CSRF isn't needed:

```elixir
pipeline :api do
  plug :accepts, ["json"]
  # No :protect_from_forgery - API uses token auth
end
```

## Mass Assignment Protection

### The Problem

Without protection, users can modify any field:

```html
<!-- Attacker adds hidden field -->
<input type="hidden" name="user[role]" value="admin">
```

### Ecto's cast/4 Solution

Only explicitly listed fields are accepted:

```elixir
def changeset(user, attrs) do
  user
  # Only these fields can be set from params
  |> cast(attrs, [:name, :email, :bio])
  # role, admin, etc. are NOT castable
  |> validate_required([:name, :email])
end
```

### Different Changesets for Different Contexts

```elixir
# For user self-registration
def registration_changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :email, :password])
  |> validate_required([:name, :email, :password])
  |> hash_password()
end

# For admin editing users
def admin_changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :email, :role, :active])
  |> validate_required([:name, :email])
  |> validate_inclusion(:role, [:user, :moderator, :admin])
end

# For user updating own profile
def profile_changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :bio, :website])
  |> validate_length(:bio, max: 500)
  |> validate_url(:website)
end
```

## Input Sanitization

### XSS Protection

Phoenix/HEEx automatically escapes output:

```heex
<%# Automatically escaped - safe %>
<p><%= @snippet.content %></p>

<%# Renders as: %>
<p>&lt;script&gt;alert('xss')&lt;/script&gt;</p>
```

### Raw HTML (Use Carefully)

```heex
<%# DANGEROUS - only use for trusted content %>
<div><%= raw(@trusted_html) %></div>

<%# Or with Phoenix.HTML.raw/1 %>
<div><%= Phoenix.HTML.raw(@trusted_html) %></div>
```

### HTML Sanitization for User Content

If you need to allow some HTML:

```elixir
# Add to mix.exs
{:html_sanitize_ex, "~> 1.4"}

# Sanitize user input
defmodule Snippetbox.Sanitizer do
  def sanitize_html(html) do
    HtmlSanitizeEx.basic_html(html)
    # Allows: p, br, strong, em, a, ul, ol, li
    # Strips: script, style, iframe, etc.
  end

  def strip_all_html(text) do
    HtmlSanitizeEx.strip_tags(text)
  end
end

# In changeset
def changeset(comment, attrs) do
  comment
  |> cast(attrs, [:content])
  |> sanitize_field(:content)
end

defp sanitize_field(changeset, field) do
  case get_change(changeset, field) do
    nil -> changeset
    value -> put_change(changeset, field, Sanitizer.sanitize_html(value))
  end
end
```

## SQL Injection Prevention

### Ecto Protects You

Ecto uses parameterized queries by default:

```elixir
# Safe - parameters are escaped
Repo.all(from s in Snippet, where: s.title == ^user_input)

# Generated SQL:
# SELECT * FROM snippets WHERE title = $1
# Parameters: [user_input]
```

### Dangerous: Raw SQL

Avoid string interpolation in queries:

```elixir
# DANGEROUS - SQL injection vulnerability
query = "SELECT * FROM snippets WHERE title = '#{user_input}'"
Repo.query(query)

# Safe - use parameters
Repo.query("SELECT * FROM snippets WHERE title = $1", [user_input])
```

### Fragment with Parameters

```elixir
# Safe use of fragment
from s in Snippet,
  where: fragment("lower(?) LIKE lower(?)", s.title, ^"%#{search}%")
```

## Rate Limiting

### Protect Against Brute Force

```elixir
# File: lib/snippetbox_web/plugs/rate_limit.ex

defmodule SnippetboxWeb.Plugs.RateLimit do
  import Plug.Conn
  import Phoenix.Controller

  def rate_limit_login(conn, _opts) do
    ip = to_string(:inet.ntoa(conn.remote_ip))
    key = "login_attempts:#{ip}"

    case Hammer.check_rate(key, 60_000, 5) do
      {:allow, _count} ->
        conn

      {:deny, _limit} ->
        conn
        |> put_flash(:error, "Too many login attempts. Please try again later.")
        |> redirect(to: ~p"/login")
        |> halt()
    end
  end
end
```

Usage:

```elixir
# In router or controller
plug :rate_limit_login when action in [:create]
```

### Form Submission Rate Limiting

```elixir
defmodule SnippetboxWeb.SnippetController do
  plug :rate_limit_create when action == :create

  defp rate_limit_create(conn, _opts) do
    user_id = conn.assigns.current_user.id
    key = "snippet_create:#{user_id}"

    case Hammer.check_rate(key, 3600_000, 10) do  # 10 per hour
      {:allow, _count} -> conn
      {:deny, _limit} ->
        conn
        |> put_flash(:error, "You're creating snippets too quickly.")
        |> redirect(to: ~p"/snippets")
        |> halt()
    end
  end
end
```

## Hidden Field Tampering

### Verify Hidden Field Values

```elixir
def update(conn, %{"id" => id, "snippet" => params}) do
  snippet = Snippets.get_snippet!(id)

  # Verify ownership - don't trust hidden user_id field
  if snippet.user_id != conn.assigns.current_user.id do
    conn
    |> put_flash(:error, "You can't edit this snippet.")
    |> redirect(to: ~p"/snippets")
  else
    # Safe to proceed
    case Snippets.update_snippet(snippet, params) do
      {:ok, snippet} -> redirect(conn, to: ~p"/snippets/#{snippet}")
      {:error, changeset} -> render(conn, :edit, changeset: changeset)
    end
  end
end
```

### Signed Values

For sensitive hidden fields:

```elixir
# Sign value before putting in form
def new(conn, _params) do
  token = Phoenix.Token.sign(conn, "return_to", conn.request_path)
  render(conn, :new, return_token: token)
end

# Verify on submission
def create(conn, %{"return_token" => token} = params) do
  case Phoenix.Token.verify(conn, "return_to", token, max_age: 3600) do
    {:ok, return_path} ->
      # Safe to redirect to return_path
      redirect(conn, to: return_path)

    {:error, _reason} ->
      redirect(conn, to: ~p"/")
  end
end
```

## Content Security Policy

### Restrict Form Targets

```elixir
# File: lib/snippetbox_web/plugs/security_headers.ex

defmodule SnippetboxWeb.Plugs.SecurityHeaders do
  import Plug.Conn

  def call(conn, _opts) do
    conn
    |> put_resp_header("content-security-policy",
         "default-src 'self'; " <>
         "form-action 'self'; " <>  # Forms can only submit to same origin
         "frame-ancestors 'none'")
    |> put_resp_header("x-frame-options", "DENY")
    |> put_resp_header("x-content-type-options", "nosniff")
  end
end
```

## Security Checklist

### Form Security Checklist

- [ ] CSRF protection enabled for browser routes
- [ ] Use `cast/4` to whitelist form fields
- [ ] Different changesets for different user roles
- [ ] HTML output is escaped (default in HEEx)
- [ ] Raw HTML is sanitized if needed
- [ ] No SQL string interpolation
- [ ] Rate limiting on sensitive forms
- [ ] Verify ownership before updates
- [ ] Sign sensitive hidden values
- [ ] CSP headers configured

### Testing Security

```elixir
# File: test/snippetbox_web/controllers/snippet_controller_test.exs

describe "security" do
  test "rejects requests without CSRF token", %{conn: conn} do
    conn =
      conn
      |> delete_req_header("x-csrf-token")
      |> post(~p"/snippets", snippet: %{title: "Test"})

    assert html_response(conn, 403) =~ "forbidden"
  end

  test "cannot mass assign protected fields", %{conn: conn} do
    user = user_fixture()
    conn = log_in_user(conn, user)

    post(conn, ~p"/users/#{user}", user: %{role: "admin"})

    # Role should not change
    assert Accounts.get_user!(user.id).role == :user
  end

  test "cannot edit other users' snippets", %{conn: conn} do
    owner = user_fixture()
    attacker = user_fixture()
    snippet = snippet_fixture(user: owner)

    conn = log_in_user(conn, attacker)
    conn = put(conn, ~p"/snippets/#{snippet}", snippet: %{title: "Hacked"})

    assert redirected_to(conn) == ~p"/snippets"
    assert Snippets.get_snippet!(snippet.id).title != "Hacked"
  end
end
```

> **FP Concept: Defense in Depth**
>
> Security follows the functional principle of composition:
>
> ```elixir
> conn
> |> validate_csrf_token()      # Layer 1
> |> authenticate_user()        # Layer 2
> |> authorize_resource()       # Layer 3
> |> validate_input()           # Layer 4
> |> process_safely()           # Layer 5
> ```
>
> Each layer is independent and composable. If one fails, it halts the pipeline. This makes security both robust and testable.
>
> **Further Reading**:
> - [OWASP Top 10](https://owasp.org/www-project-top-ten/)
> - [Phoenix Security Guide](https://hexdocs.pm/phoenix/security.html)

## Summary

In this chapter, we learned:

- CSRF protection and tokens
- Mass assignment protection with changesets
- XSS prevention and HTML sanitization
- SQL injection prevention
- Rate limiting forms
- Hidden field tampering protection
- Content Security Policy
- Security testing practices

This completes the Processing Forms chapter. In the next chapter, we'll explore sessions and state management.
