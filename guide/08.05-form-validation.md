# Chapter 8.5: Form Validation

Effective form validation improves user experience and data integrity. In this chapter, we'll explore validation strategies at multiple levels.

## Validation Layers

```
┌─────────────────────────────────────────┐
│           Client-Side (HTML5)           │  ← Instant feedback
├─────────────────────────────────────────┤
│        Client-Side (JavaScript)         │  ← Rich validation
├─────────────────────────────────────────┤
│         Server-Side (Changeset)         │  ← Business rules
├─────────────────────────────────────────┤
│        Database (Constraints)           │  ← Data integrity
└─────────────────────────────────────────┘
```

## HTML5 Validation

### Built-in Attributes

```heex
<%# Required field %>
<.input field={@form[:title]} label="Title" required />

<%# Length constraints %>
<.input field={@form[:title]} label="Title" minlength={3} maxlength={100} />

<%# Pattern matching %>
<.input field={@form[:username]} label="Username" pattern="[a-z0-9_]+" />

<%# Number range %>
<.input field={@form[:age]} type="number" label="Age" min={18} max={120} />

<%# Email format %>
<.input field={@form[:email]} type="email" label="Email" />
```

### Disabling HTML5 Validation

Sometimes you want server-side validation only:

```heex
<.form for={@changeset} action={~p"/snippets"} novalidate>
  <%# Fields... %>
</.form>
```

## Server-Side Validation

### Changeset Validations

```elixir
# File: lib/snippetbox/snippets/snippet.ex

def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :language, :expires_at])
  |> validate_required([:title, :content])
  |> validate_length(:title, min: 3, max: 100)
  |> validate_length(:content, min: 1, max: 100_000)
  |> validate_inclusion(:language, supported_languages())
  |> validate_future_date(:expires_at)
  |> unique_constraint(:title, name: :snippets_user_id_title_index)
end
```

### Custom Validation Functions

```elixir
defp validate_future_date(changeset, field) do
  validate_change(changeset, field, fn _, value ->
    if DateTime.compare(value, DateTime.utc_now()) == :gt do
      []
    else
      [{field, "must be in the future"}]
    end
  end)
end

defp validate_no_spam(changeset, field) do
  validate_change(changeset, field, fn _, value ->
    spam_patterns = ~r/(viagra|casino|lottery|winner)/i

    if Regex.match?(spam_patterns, value) do
      [{field, "contains prohibited content"}]
    else
      []
    end
  end)
end

defp validate_url(changeset, field) do
  validate_change(changeset, field, fn _, value ->
    case URI.parse(value) do
      %URI{scheme: scheme, host: host}
      when scheme in ["http", "https"] and not is_nil(host) ->
        []

      _ ->
        [{field, "must be a valid URL"}]
    end
  end)
end
```

### Cross-Field Validation

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:password, :password_confirmation])
  |> validate_required([:password])
  |> validate_confirmation(:password, message: "does not match password")
end

# Or custom cross-field validation
def changeset(event, attrs) do
  event
  |> cast(attrs, [:starts_at, :ends_at])
  |> validate_required([:starts_at, :ends_at])
  |> validate_end_after_start()
end

defp validate_end_after_start(changeset) do
  starts_at = get_field(changeset, :starts_at)
  ends_at = get_field(changeset, :ends_at)

  if starts_at && ends_at && DateTime.compare(ends_at, starts_at) != :gt do
    add_error(changeset, :ends_at, "must be after start time")
  else
    changeset
  end
end
```

### Conditional Validation

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :visibility, :password])
  |> validate_required([:title, :content, :visibility])
  |> validate_password_if_private()
end

defp validate_password_if_private(changeset) do
  case get_field(changeset, :visibility) do
    :private ->
      changeset
      |> validate_required([:password], message: "required for private snippets")
      |> validate_length(:password, min: 8)

    _ ->
      changeset
  end
end
```

## Database Constraints

### Unique Constraints

```elixir
# Migration
create unique_index(:users, [:email])
create unique_index(:snippets, [:user_id, :title], name: :snippets_user_id_title_index)

# Changeset
def changeset(user, attrs) do
  user
  |> cast(attrs, [:email, :username])
  |> validate_required([:email, :username])
  |> unique_constraint(:email)
  |> unique_constraint(:username)
end

def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :user_id])
  |> unique_constraint([:user_id, :title],
       name: :snippets_user_id_title_index,
       message: "you already have a snippet with this title")
end
```

### Check Constraints

```elixir
# Migration
create constraint(:products, :price_must_be_positive, check: "price > 0")
create constraint(:events, :end_after_start, check: "ends_at > starts_at")

# Changeset
def changeset(product, attrs) do
  product
  |> cast(attrs, [:name, :price])
  |> check_constraint(:price, name: :price_must_be_positive, message: "must be positive")
end
```

### Foreign Key Constraints

```elixir
# Migration
alter table(:snippets) do
  add :user_id, references(:users, on_delete: :delete_all), null: false
end

# Changeset
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :user_id])
  |> foreign_key_constraint(:user_id, message: "user does not exist")
end
```

## Error Messages

### Custom Error Messages

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:email, :password, :age])
  |> validate_required(:email, message: "we need your email to continue")
  |> validate_format(:email, ~r/@/, message: "must contain @")
  |> validate_length(:password,
       min: 12,
       message: "must be at least 12 characters for security")
  |> validate_number(:age,
       greater_than_or_equal_to: 13,
       message: "you must be at least 13 years old")
end
```

### Interpolated Messages

```elixir
|> validate_length(:title, min: 3, max: 100)
# Default message: "should be at least %{count} character(s)"

# Custom with interpolation
|> validate_length(:title, min: 3,
     message: "please enter at least %{count} characters")
```

### Translation

```elixir
# File: lib/snippetbox_web/components/core_components.ex

def translate_error({msg, opts}) do
  # Use Gettext for translations
  if count = opts[:count] do
    Gettext.dngettext(SnippetboxWeb.Gettext, "errors", msg, msg, count, opts)
  else
    Gettext.dgettext(SnippetboxWeb.Gettext, "errors", msg, opts)
  end
end
```

## Real-Time Validation with LiveView

### Setup

```elixir
# File: lib/snippetbox_web/live/snippet_live/form.ex

defmodule SnippetboxWeb.SnippetLive.Form do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Snippets
  alias Snippetbox.Snippets.Snippet

  @impl true
  def mount(_params, _session, socket) do
    changeset = Snippets.change_snippet(%Snippet{})

    {:ok,
     socket
     |> assign(:changeset, changeset)
     |> assign(:check_errors, false)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <.form
      for={@changeset}
      phx-change="validate"
      phx-submit="save"
    >
      <.input field={@form[:title]} label="Title" phx-debounce="300" />
      <.input field={@form[:content]} type="textarea" label="Content" phx-debounce="500" />

      <.button phx-disable-with="Saving...">Save</.button>
    </.form>
    """
  end

  @impl true
  def handle_event("validate", %{"snippet" => params}, socket) do
    changeset =
      %Snippet{}
      |> Snippets.change_snippet(params)
      |> Map.put(:action, :validate)

    {:noreply, assign(socket, :changeset, changeset)}
  end

  @impl true
  def handle_event("save", %{"snippet" => params}, socket) do
    case Snippets.create_snippet(params) do
      {:ok, snippet} ->
        {:noreply,
         socket
         |> put_flash(:info, "Snippet created!")
         |> push_navigate(to: ~p"/snippets/#{snippet}")}

      {:error, changeset} ->
        {:noreply, assign(socket, :changeset, changeset)}
    end
  end
end
```

### Async Validation

```elixir
def handle_event("validate", %{"user" => %{"username" => username} = params}, socket) do
  # Check username availability asynchronously
  send(self(), {:check_username, username})

  changeset =
    %User{}
    |> Users.change_user(params)
    |> Map.put(:action, :validate)

  {:noreply, assign(socket, :changeset, changeset)}
end

def handle_info({:check_username, username}, socket) do
  available = Users.username_available?(username)

  socket =
    if available do
      socket
    else
      changeset =
        socket.assigns.changeset
        |> Ecto.Changeset.add_error(:username, "is already taken")
        |> Map.put(:action, :validate)

      assign(socket, :changeset, changeset)
    end

  {:noreply, socket}
end
```

## Validation Best Practices

### 1. Validate Early, Validate Often

```elixir
# In context module - single source of truth
def change_snippet(snippet, attrs \\ %{}) do
  Snippet.changeset(snippet, attrs)
end

# Used in:
# - Controller new action (empty form)
# - Controller create action (validation)
# - LiveView validate event (real-time)
# - LiveView save event (final validation)
```

### 2. User-Friendly Error Messages

```elixir
# Bad
validate_length(:password, min: 8)
# "should be at least 8 character(s)"

# Good
validate_length(:password, min: 8,
  message: "must be at least 8 characters for security")
```

### 3. Show Errors at the Right Time

```elixir
# Only show errors after user interaction
def input(%{field: %Phoenix.HTML.FormField{} = field} = assigns) do
  # phx-no-feedback class hides errors until form is submitted
  ~H"""
  <div phx-feedback-for={@name}>
    <%# ... %>
  </div>
  """
end
```

### 4. Combine Client and Server Validation

```heex
<%# HTML5 for instant feedback %>
<.input
  field={@form[:email]}
  type="email"
  label="Email"
  required
/>

<%# Server validates everything again %>
```

> **FP Concept: Validation as Composition**
>
> Ecto validation composes naturally:
>
> ```elixir
> changeset
> |> validate_required([:title])      # First validation
> |> validate_length(:title, min: 3)  # Adds to errors if any
> |> validate_format(:title, ~r/.../) # Adds more if needed
> |> unique_constraint(:title)        # DB-level check
> ```
>
> Each validation is independent and composable. The changeset accumulates all errors, giving users complete feedback in one response.

## Summary

In this chapter, we learned:

- Multiple validation layers (client, server, database)
- HTML5 validation attributes
- Changeset validations (built-in and custom)
- Cross-field and conditional validation
- Database constraints for data integrity
- Custom error messages and translation
- Real-time validation with LiveView
- Validation best practices

In the next chapter, we'll explore form security.
