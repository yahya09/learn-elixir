# Chapter 2.3: Routing Requests

The router is the traffic controller of your Phoenix application. It examines incoming requests and dispatches them to the appropriate controller action. In this chapter, we'll explore Phoenix routing in depth.

## Basic Route Patterns

Phoenix routes follow this pattern:

```elixir
verb "path", Controller, :action
```

Where:
- `verb` is the HTTP method (get, post, put, patch, delete)
- `"path"` is the URL pattern to match
- `Controller` is the controller module
- `:action` is the function to call

### HTTP Methods

```elixir
# File: lib/snippetbox_web/router.ex

scope "/", SnippetboxWeb do
  pipe_through :browser

  get "/snippets", SnippetController, :index       # List all
  post "/snippets", SnippetController, :create     # Create new
  get "/snippets/:id", SnippetController, :show    # Show one
  put "/snippets/:id", SnippetController, :update  # Update (full)
  patch "/snippets/:id", SnippetController, :update  # Update (partial)
  delete "/snippets/:id", SnippetController, :delete # Delete
end
```

## Dynamic Segments

Use `:name` to capture URL segments:

```elixir
get "/snippets/:id", SnippetController, :show
```

When someone visits `/snippets/123`, Phoenix calls:

```elixir
SnippetController.show(conn, %{"id" => "123"})
```

Multiple segments:

```elixir
get "/users/:user_id/snippets/:id", SnippetController, :show
# /users/5/snippets/123 →
# show(conn, %{"user_id" => "5", "id" => "123"})
```

## Query String Parameters

Query strings are automatically parsed:

```elixir
# URL: /snippets?page=2&limit=10
# params: %{"page" => "2", "limit" => "10"}

def index(conn, params) do
  page = Map.get(params, "page", "1")
  limit = Map.get(params, "limit", "10")
  # ...
end
```

With pattern matching:

```elixir
def index(conn, %{"page" => page, "limit" => limit}) do
  # Matches only when both params exist
end

def index(conn, params) do
  # Catches all other cases
  page = Map.get(params, "page", "1")
  limit = Map.get(params, "limit", "10")
end
```

## Resourceful Routes

Phoenix provides `resources` macro for RESTful routing:

```elixir
# Instead of manually defining all routes:
get "/snippets", SnippetController, :index
get "/snippets/new", SnippetController, :new
post "/snippets", SnippetController, :create
get "/snippets/:id", SnippetController, :show
get "/snippets/:id/edit", SnippetController, :edit
put "/snippets/:id", SnippetController, :update
patch "/snippets/:id", SnippetController, :update
delete "/snippets/:id", SnippetController, :delete

# Use this:
resources "/snippets", SnippetController
```

This generates all 8 RESTful routes automatically.

Limit which actions to generate:

```elixir
# Only index, show, and create
resources "/snippets", SnippetController, only: [:index, :show, :create]

# Everything except delete
resources "/snippets", SnippetController, except: [:delete]
```

## Nested Resources

For related resources:

```elixir
resources "/users", UserController do
  resources "/snippets", SnippetController
end
```

This generates routes like:
- `GET /users/:user_id/snippets` - List user's snippets
- `GET /users/:user_id/snippets/:id` - Show one snippet

## Scoped Routes

Group routes under a common path prefix:

```elixir
scope "/admin", SnippetboxWeb.Admin do
  pipe_through [:browser, :require_admin]

  resources "/snippets", SnippetController
  resources "/users", UserController
end
```

Routes become:
- `/admin/snippets`
- `/admin/users`

And use controllers from `SnippetboxWeb.Admin` namespace.

## Named Routes (Path Helpers)

Phoenix generates helper functions for each route. Instead of hardcoding URLs:

```elixir
# Don't do this
redirect(conn, to: "/snippets/#{snippet.id}")

# Do this
redirect(conn, to: ~p"/snippets/#{snippet.id}")
```

The `~p` sigil creates verified routes that are checked at compile-time.

Common path helpers:

```elixir
~p"/"                           # "/"
~p"/snippets"                   # "/snippets"
~p"/snippets/#{id}"             # "/snippets/123"
~p"/snippets/#{id}/edit"        # "/snippets/123/edit"
~p"/snippets?#{[page: 2]}"      # "/snippets?page=2"
```

## Route Constraints

Constrain what patterns match:

```elixir
# Only match numeric IDs
get "/snippets/:id", SnippetController, :show,
  constraints: %{id: ~r/\d+/}

# Won't match /snippets/abc, only /snippets/123
```

## Forward Routes

Forward a path prefix to another plug or router:

```elixir
forward "/api/v1", SnippetboxWeb.API.V1.Router
```

All requests to `/api/v1/*` go to the V1 router.

## Pipelines

Pipelines are groups of plugs (middleware) applied to routes:

```elixir
pipeline :browser do
  plug :accepts, ["html"]
  plug :fetch_session
  plug :put_secure_browser_headers
end

pipeline :api do
  plug :accepts, ["json"]
end

pipeline :auth do
  plug :require_login
end

scope "/", SnippetboxWeb do
  pipe_through :browser

  get "/", PageController, :home
end

scope "/admin", SnippetboxWeb.Admin do
  pipe_through [:browser, :auth]  # Apply multiple pipelines

  resources "/snippets", SnippetController
end
```

## Inspecting Routes

List all routes in your application:

```bash
$ mix phx.routes
```

Output:

```
GET    /                                      PageController :home
GET    /snippets                              SnippetController :index
GET    /snippets/:id                          SnippetController :show
POST   /snippets                              SnippetController :create
GET    /snippets/new                          SnippetController :new
GET    /snippets/:id/edit                     SnippetController :edit
PATCH  /snippets/:id                          SnippetController :update
PUT    /snippets/:id                          SnippetController :update
DELETE /snippets/:id                          SnippetController :delete
```

Search for specific routes:

```bash
$ mix phx.routes SnippetController
$ mix phx.routes | grep snippet
```

## Building Our Snippet Routes

Let's add proper routing for our SnippetBox application. Update your router:

```elixir
# File: lib/snippetbox_web/router.ex

defmodule SnippetboxWeb.Router do
  use SnippetboxWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {SnippetboxWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  scope "/", SnippetboxWeb do
    pipe_through :browser

    get "/", PageController, :home
    get "/snippet/view/:id", SnippetController, :show
    get "/snippet/create", SnippetController, :new
    post "/snippet/create", SnippetController, :create
  end
end
```

Notice we're not using `resources` yet - we want to learn the basics first. We'll refactor to use `resources` later.

## Creating the Snippet Controller

Create a new controller:

```bash
$ mkdir -p lib/snippetbox_web/controllers
$ touch lib/snippetbox_web/controllers/snippet_controller.ex
```

Add the controller code:

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

defmodule SnippetboxWeb.SnippetController do
  use SnippetboxWeb, :controller

  def show(conn, %{"id" => id}) do
    # For now, just show the ID
    # We'll add database queries in Chapter 4
    text(conn, "Display snippet with ID: #{id}")
  end

  def new(conn, _params) do
    text(conn, "Form to create a new snippet")
  end

  def create(conn, params) do
    # For now, just echo the params
    text(conn, "Create snippet with params: #{inspect(params)}")
  end
end
```

Test the routes:

```bash
$ mix phx.server

# In another terminal:
$ curl http://localhost:4000/
$ curl http://localhost:4000/snippet/view/123
$ curl http://localhost:4000/snippet/create
```

## Understanding Route Matching Order

Phoenix matches routes in order from top to bottom:

```elixir
# ❌ Bad: specific route after wildcard
get "/snippets/:id", SnippetController, :show
get "/snippets/new", SnippetController, :new  # Never matches!

# ✅ Good: specific routes first
get "/snippets/new", SnippetController, :new
get "/snippets/:id", SnippetController, :show
```

## Catch-All Routes

Handle 404s with a catch-all:

```elixir
scope "/", SnippetboxWeb do
  pipe_through :browser

  get "/", PageController, :home
  # ... other routes ...

  # Catch all unmatched routes
  get "/*path", PageController, :not_found
end
```

```elixir
def not_found(conn, %{"path" => path}) do
  conn
  |> put_status(:not_found)
  |> text("Page not found: /#{Enum.join(path, "/")}")
end
```

> **FP Concept: Pattern Matching in Routes**
>
> Phoenix routing uses pattern matching at compile-time to build an efficient dispatch table. When a request arrives, Phoenix:
>
> 1. Matches the HTTP method
> 2. Matches the path pattern
> 3. Extracts parameters
> 4. Calls the controller
>
> This is very fast because routes are compiled into a decision tree, not checked sequentially at runtime.
>
> Compare to other frameworks that check routes at runtime:
> ```python
> # Django checks each pattern sequentially
> urlpatterns = [
>     path('articles/<int:year>/', views.year_archive),
>     path('articles/<int:year>/<int:month>/', views.month_archive),
> ]
> ```
>
> Phoenix's compile-time routing means:
> - Faster request handling
> - Compile-time route verification
> - Better error messages
>
> **Further Reading**:
> - [Phoenix Routing Internals](https://hexdocs.pm/phoenix/routing.html)

## Summary

In this chapter, we learned:

- How to define routes with different HTTP methods
- How to capture dynamic segments in URLs
- How to use query string parameters
- How to create resourceful routes
- How to organize routes with scopes and pipelines
- How to use verified routes with `~p`
- How Phoenix matches routes efficiently

In the next chapter, we'll learn how to customize HTTP headers and work with different response types.

---

## Additional Information

### REST vs RPC Style Routing

Phoenix encourages RESTful routing:

**RESTful (Resource-oriented)**
```elixir
GET    /snippets        # List
POST   /snippets        # Create
GET    /snippets/:id    # Show
PUT    /snippets/:id    # Update
DELETE /snippets/:id    # Delete
```

**RPC (Action-oriented)**
```elixir
GET  /snippets/list
POST /snippets/add
GET  /snippets/get/:id
POST /snippets/modify/:id
POST /snippets/remove/:id
```

RESTful routing is preferred because:
- Standard HTTP semantics
- Easier to cache
- Better API design
- Works well with HTTP methods

However, not every action fits REST. For custom actions:

```elixir
resources "/snippets", SnippetController do
  post "/publish", SnippetController, :publish      # /snippets/:id/publish
  delete "/archive", SnippetController, :archive    # /snippets/:id/archive
end
```

### Router Performance

Phoenix routers are extremely fast because:

1. **Compile-time generation**: Routes compile to efficient pattern matching
2. **No runtime regex**: Path patterns converted to pattern matching
3. **Minimal overhead**: Direct function calls, no reflection

Benchmarks show Phoenix can handle 100k+ requests/second on modest hardware, with routing overhead measured in microseconds.
