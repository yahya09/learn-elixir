# Chapter 14.2: Docker Deployment

Docker provides consistent environments across development and production. In this chapter, we'll explore containerizing Phoenix applications.

## Phoenix Dockerfile

Phoenix generates a production-ready Dockerfile:

```bash
mix phx.gen.release --docker
```

### Generated Dockerfile

```dockerfile
# File: Dockerfile

# Find eligible builder and runner images at:
# https://hub.docker.com/r/hexpm/elixir/tags

ARG ELIXIR_VERSION=1.16.0
ARG OTP_VERSION=26.2
ARG DEBIAN_VERSION=bookworm-20231009-slim

ARG BUILDER_IMAGE="hexpm/elixir:${ELIXIR_VERSION}-erlang-${OTP_VERSION}-debian-${DEBIAN_VERSION}"
ARG RUNNER_IMAGE="debian:${DEBIAN_VERSION}"

FROM ${BUILDER_IMAGE} as builder

# Install build dependencies
RUN apt-get update -y && apt-get install -y build-essential git \
    && apt-get clean && rm -f /var/lib/apt/lists/*_*

# Prepare build dir
WORKDIR /app

# Install hex + rebar
RUN mix local.hex --force && \
    mix local.rebar --force

# Set build ENV
ENV MIX_ENV="prod"

# Install mix dependencies
COPY mix.exs mix.lock ./
RUN mix deps.get --only $MIX_ENV
RUN mkdir config

# Copy compile-time config files
COPY config/config.exs config/${MIX_ENV}.exs config/
RUN mix deps.compile

COPY priv priv
COPY lib lib
COPY assets assets

# Compile assets
RUN mix assets.deploy

# Compile the release
RUN mix compile

# Changes to config/runtime.exs don't require recompiling the code
COPY config/runtime.exs config/

# Build release
COPY rel rel
RUN mix release

# Start a new build stage for the minimal runtime image
FROM ${RUNNER_IMAGE}

RUN apt-get update -y && \
    apt-get install -y libstdc++6 openssl libncurses5 locales ca-certificates \
    && apt-get clean && rm -f /var/lib/apt/lists/*_*

# Set the locale
RUN sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen

ENV LANG en_US.UTF-8
ENV LANGUAGE en_US:en
ENV LC_ALL en_US.UTF-8

WORKDIR "/app"
RUN chown nobody /app

# Set runner ENV
ENV MIX_ENV="prod"

# Only copy the final release from the build stage
COPY --from=builder --chown=nobody:root /app/_build/${MIX_ENV}/rel/snippetbox ./

USER nobody

# Set default command
CMD ["/app/bin/server"]
```

## Multi-Stage Build Explained

```dockerfile
# Stage 1: Build environment
FROM hexpm/elixir:1.16-erlang-26-debian-bookworm as builder
# - Full Elixir/Erlang environment
# - Build tools installed
# - Dependencies compiled
# - Assets built
# - Release created

# Stage 2: Runtime environment
FROM debian:bookworm-slim
# - Minimal base image
# - Only runtime dependencies
# - Copy release from builder
# - ~100MB final image vs ~1GB build image
```

## Docker Compose

### Development

```yaml
# File: docker-compose.yml

version: "3.8"

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "4000:4000"
    volumes:
      - .:/app
      - deps:/app/deps
      - build:/app/_build
    environment:
      - MIX_ENV=dev
      - DATABASE_URL=ecto://postgres:postgres@db/snippetbox_dev
    depends_on:
      - db

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: snippetbox_dev
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  deps:
  build:
  pgdata:
```

### Development Dockerfile

```dockerfile
# File: Dockerfile.dev

FROM elixir:1.16

RUN apt-get update && \
    apt-get install -y inotify-tools && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

RUN mix local.hex --force && mix local.rebar --force

COPY mix.exs mix.lock ./
RUN mix deps.get

COPY . .

CMD ["mix", "phx.server"]
```

### Production

```yaml
# File: docker-compose.prod.yml

version: "3.8"

services:
  app:
    image: snippetbox:latest
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "4000:4000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - SECRET_KEY_BASE=${SECRET_KEY_BASE}
      - PHX_HOST=${PHX_HOST}
    depends_on:
      db:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/nginx/certs:ro
    depends_on:
      - app
    restart: unless-stopped

volumes:
  pgdata:
```

## Building and Running

```bash
# Build the image
docker build -t snippetbox:latest .

# Run with environment variables
docker run -d \
  --name snippetbox \
  -p 4000:4000 \
  -e DATABASE_URL="ecto://user:pass@db/snippetbox" \
  -e SECRET_KEY_BASE="your-secret-key" \
  -e PHX_HOST="example.com" \
  snippetbox:latest

# Run migrations
docker exec snippetbox bin/snippetbox eval "Snippetbox.Release.migrate()"

# View logs
docker logs -f snippetbox

# Interactive shell
docker exec -it snippetbox bin/snippetbox remote
```

## Docker Compose Commands

```bash
# Development
docker-compose up -d
docker-compose logs -f app
docker-compose exec app mix ecto.migrate
docker-compose exec app iex -S mix

# Production
docker-compose -f docker-compose.prod.yml up -d
docker-compose -f docker-compose.prod.yml exec app bin/snippetbox remote
```

## Optimizing Docker Images

### Layer Caching

```dockerfile
# Good: Dependencies cached separately
COPY mix.exs mix.lock ./
RUN mix deps.get --only prod
RUN mix deps.compile

# Then copy source
COPY lib lib
COPY priv priv

# Changes to source don't invalidate deps cache
```

### .dockerignore

```gitignore
# File: .dockerignore

# Git
.git
.gitignore

# Elixir/Phoenix build artifacts
_build
deps
*.ez

# Generated files
/assets/node_modules
/priv/static/assets

# Development
.elixir_ls
.iex.exs

# Test
/cover
/test

# Docker
Dockerfile*
docker-compose*

# Documentation
/doc
README.md
```

### Smaller Base Images

```dockerfile
# Alpine-based (smaller but may have compatibility issues)
FROM hexpm/elixir:1.16.0-erlang-26.2-alpine-3.18.4 as builder
FROM alpine:3.18

# Debian slim (good balance)
FROM hexpm/elixir:1.16.0-erlang-26.2-debian-bookworm-20231009-slim as builder
FROM debian:bookworm-slim
```

## Health Checks

```dockerfile
# In Dockerfile
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:4000/health || exit 1
```

```elixir
# Health check endpoint
# lib/snippetbox_web/controllers/health_controller.ex

defmodule SnippetboxWeb.HealthController do
  use SnippetboxWeb, :controller

  def check(conn, _params) do
    with :ok <- check_database() do
      json(conn, %{status: "ok"})
    else
      {:error, reason} ->
        conn
        |> put_status(:service_unavailable)
        |> json(%{status: "error", reason: reason})
    end
  end

  defp check_database do
    case Ecto.Adapters.SQL.query(Snippetbox.Repo, "SELECT 1", []) do
      {:ok, _} -> :ok
      {:error, _} -> {:error, "database unavailable"}
    end
  end
end
```

## Container Registry

### GitHub Container Registry

```yaml
# .github/workflows/docker.yml

name: Build and Push Docker

on:
  push:
    branches: [main]
    tags: ['v*']

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}
```

## Clustering in Docker

```yaml
# docker-compose.cluster.yml

version: "3.8"

services:
  app1:
    image: snippetbox:latest
    environment:
      - RELEASE_NODE=snippetbox@app1
      - RELEASE_COOKIE=secret_cookie
    networks:
      - cluster

  app2:
    image: snippetbox:latest
    environment:
      - RELEASE_NODE=snippetbox@app2
      - RELEASE_COOKIE=secret_cookie
    networks:
      - cluster

networks:
  cluster:
    driver: bridge
```

```elixir
# config/runtime.exs
config :libcluster,
  topologies: [
    docker: [
      strategy: Cluster.Strategy.Epmd,
      config: [hosts: [:"snippetbox@app1", :"snippetbox@app2"]]
    ]
  ]
```

> **FP Concept: Immutable Containers**
>
> Docker containers embody immutability:
>
> ```bash
> # Image is immutable snapshot
> docker build -t myapp:v1 .
>
> # Containers are ephemeral instances
> docker run myapp:v1  # Instance 1
> docker run myapp:v1  # Instance 2
>
> # Updates = new image, new containers
> docker build -t myapp:v2 .
> docker stop old && docker run myapp:v2
> ```
>
> No in-place updates, just replace with new versions.

## Summary

In this chapter, we learned:

- Phoenix Dockerfile structure
- Multi-stage builds
- Docker Compose for development and production
- Building and running containers
- Optimizing Docker images
- Health checks
- Container registries
- Clustering in Docker

In the next chapter, we'll explore deploying to Fly.io.
