# Chapter 17.5: LiveView Exercises

These exercises reinforce concepts from Chapter 12 covering LiveView basics, forms, components, and real-time features.

## Exercise 1: Real-Time Counter with Persistence

Create a counter that persists across page refreshes and syncs across browsers.

```elixir
# File: lib/snippetbox_web/live/persistent_counter_live.ex

defmodule SnippetboxWeb.PersistentCounterLive do
  use SnippetboxWeb, :live_view

  # Requirements:
  # - Counter value stored in database
  # - All connected clients see the same value
  # - Updates broadcast to all viewers
  # - Show number of viewers
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.PersistentCounterLive do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Counters
  alias SnippetboxWeb.Presence

  @topic "counter"

  @impl true
  def mount(_params, _session, socket) do
    if connected?(socket) do
      Phoenix.PubSub.subscribe(Snippetbox.PubSub, @topic)
      Presence.track(self(), @topic, socket.id, %{})
    end

    counter = Counters.get_counter("main")

    {:ok,
     socket
     |> assign(:count, counter.value)
     |> assign(:viewers, count_viewers())}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="text-center">
      <p class="text-sm text-gray-500 mb-4"><%= @viewers %> watching</p>
      <h1 class="text-6xl font-bold mb-8"><%= @count %></h1>
      <div class="space-x-4">
        <.button phx-click="decrement">-</.button>
        <.button phx-click="increment">+</.button>
      </div>
    </div>
    """
  end

  @impl true
  def handle_event("increment", _params, socket) do
    {:ok, counter} = Counters.increment("main")
    broadcast_update(counter.value)
    {:noreply, assign(socket, :count, counter.value)}
  end

  def handle_event("decrement", _params, socket) do
    {:ok, counter} = Counters.decrement("main")
    broadcast_update(counter.value)
    {:noreply, assign(socket, :count, counter.value)}
  end

  @impl true
  def handle_info({:counter_updated, value}, socket) do
    {:noreply, assign(socket, :count, value)}
  end

  def handle_info(%Phoenix.Socket.Broadcast{event: "presence_diff"}, socket) do
    {:noreply, assign(socket, :viewers, count_viewers())}
  end

  defp broadcast_update(value) do
    Phoenix.PubSub.broadcast(Snippetbox.PubSub, @topic, {:counter_updated, value})
  end

  defp count_viewers do
    Presence.list(@topic) |> map_size()
  end
end
```
</details>

## Exercise 2: Autocomplete Component

Build an autocomplete input component.

```elixir
# File: lib/snippetbox_web/live/components/autocomplete_component.ex

defmodule SnippetboxWeb.AutocompleteComponent do
  use SnippetboxWeb, :live_component

  # Requirements:
  # - Debounced search (300ms)
  # - Show dropdown with results
  # - Keyboard navigation (up/down/enter)
  # - Click to select
  # - Close on blur/escape
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.AutocompleteComponent do
  use SnippetboxWeb, :live_component

  @impl true
  def mount(socket) do
    {:ok,
     socket
     |> assign(:query, "")
     |> assign(:results, [])
     |> assign(:selected_index, -1)
     |> assign(:show_results, false)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="relative" phx-click-away="close" phx-target={@myself}>
      <input
        type="text"
        value={@query}
        phx-keyup="search"
        phx-keydown="navigate"
        phx-debounce="300"
        phx-target={@myself}
        placeholder={@placeholder}
        class="w-full px-4 py-2 border rounded-lg"
        autocomplete="off"
      />

      <ul
        :if={@show_results and @results != []}
        class="absolute z-10 w-full mt-1 bg-white border rounded-lg shadow-lg max-h-60 overflow-auto"
      >
        <li
          :for={{result, index} <- Enum.with_index(@results)}
          phx-click="select"
          phx-value-index={index}
          phx-target={@myself}
          class={[
            "px-4 py-2 cursor-pointer",
            index == @selected_index && "bg-blue-100"
          ]}
        >
          <%= render_result(result) %>
        </li>
      </ul>
    </div>
    """
  end

  @impl true
  def handle_event("search", %{"value" => query}, socket) do
    results =
      if String.length(query) >= 2 do
        socket.assigns.search_fn.(query)
      else
        []
      end

    {:noreply,
     socket
     |> assign(:query, query)
     |> assign(:results, results)
     |> assign(:selected_index, -1)
     |> assign(:show_results, true)}
  end

  def handle_event("navigate", %{"key" => "ArrowDown"}, socket) do
    max_index = length(socket.assigns.results) - 1
    new_index = min(socket.assigns.selected_index + 1, max_index)
    {:noreply, assign(socket, :selected_index, new_index)}
  end

  def handle_event("navigate", %{"key" => "ArrowUp"}, socket) do
    new_index = max(socket.assigns.selected_index - 1, 0)
    {:noreply, assign(socket, :selected_index, new_index)}
  end

  def handle_event("navigate", %{"key" => "Enter"}, socket) do
    if socket.assigns.selected_index >= 0 do
      result = Enum.at(socket.assigns.results, socket.assigns.selected_index)
      send(self(), {:autocomplete_select, socket.assigns.id, result})
    end
    {:noreply, assign(socket, :show_results, false)}
  end

  def handle_event("navigate", %{"key" => "Escape"}, socket) do
    {:noreply, assign(socket, :show_results, false)}
  end

  def handle_event("navigate", _params, socket), do: {:noreply, socket}

  def handle_event("select", %{"index" => index}, socket) do
    result = Enum.at(socket.assigns.results, String.to_integer(index))
    send(self(), {:autocomplete_select, socket.assigns.id, result})

    {:noreply,
     socket
     |> assign(:query, result.name)
     |> assign(:show_results, false)}
  end

  def handle_event("close", _params, socket) do
    {:noreply, assign(socket, :show_results, false)}
  end

  defp render_result(result), do: result.name
end
```
</details>

## Exercise 3: Infinite Scroll

Implement infinite scroll for a list of items.

```elixir
# File: lib/snippetbox_web/live/infinite_scroll_live.ex

defmodule SnippetboxWeb.InfiniteScrollLive do
  use SnippetboxWeb, :live_view

  # Requirements:
  # - Load items in batches of 20
  # - Load more when user scrolls near bottom
  # - Show loading indicator
  # - Handle empty state
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.InfiniteScrollLive do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Snippets

  @page_size 20

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |> assign(:page, 1)
     |> assign(:loading, false)
     |> assign(:end_of_list, false)
     |> stream(:snippets, Snippets.list_snippets(limit: @page_size))}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div id="infinite-scroll" phx-hook="InfiniteScroll" data-page={@page}>
      <div id="snippets" phx-update="stream" class="space-y-4">
        <div :for={{dom_id, snippet} <- @streams.snippets} id={dom_id} class="p-4 border rounded">
          <h3 class="font-bold"><%= snippet.title %></h3>
          <p class="text-sm text-gray-500"><%= snippet.language %></p>
        </div>
      </div>

      <div :if={@loading} class="text-center py-4">
        <.spinner />
      </div>

      <div :if={@end_of_list} class="text-center py-4 text-gray-500">
        No more items
      </div>

      <div id="scroll-sentinel" phx-hook="ScrollSentinel" class="h-4"></div>
    </div>
    """
  end

  @impl true
  def handle_event("load-more", _params, socket) do
    if socket.assigns.loading or socket.assigns.end_of_list do
      {:noreply, socket}
    else
      {:noreply, load_more(socket)}
    end
  end

  defp load_more(socket) do
    page = socket.assigns.page
    offset = page * @page_size

    socket = assign(socket, :loading, true)
    send(self(), {:load_page, offset})
    socket
  end

  @impl true
  def handle_info({:load_page, offset}, socket) do
    snippets = Snippets.list_snippets(limit: @page_size, offset: offset)
    end_of_list = length(snippets) < @page_size

    {:noreply,
     socket
     |> stream(:snippets, snippets)
     |> assign(:page, socket.assigns.page + 1)
     |> assign(:loading, false)
     |> assign(:end_of_list, end_of_list)}
  end
end

# JavaScript Hook (assets/js/hooks.js)
# ScrollSentinel = {
#   mounted() {
#     const observer = new IntersectionObserver((entries) => {
#       if (entries[0].isIntersecting) {
#         this.pushEvent("load-more", {})
#       }
#     })
#     observer.observe(this.el)
#   }
# }
```
</details>

## Exercise 4: Sortable List

Create a drag-and-drop sortable list.

```elixir
# File: lib/snippetbox_web/live/sortable_live.ex

defmodule SnippetboxWeb.SortableLive do
  use SnippetboxWeb, :live_view

  # Requirements:
  # - Drag items to reorder
  # - Persist order to database
  # - Optimistic updates
  # - Handle errors gracefully
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.SortableLive do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Lists

  @impl true
  def mount(%{"id" => list_id}, _session, socket) do
    list = Lists.get_list_with_items!(list_id)

    {:ok,
     socket
     |> assign(:list, list)
     |> stream(:items, list.items)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div>
      <h1 class="text-2xl font-bold mb-4"><%= @list.name %></h1>

      <ul
        id="sortable-items"
        phx-hook="Sortable"
        phx-update="stream"
        class="space-y-2"
      >
        <li
          :for={{dom_id, item} <- @streams.items}
          id={dom_id}
          data-id={item.id}
          class="p-4 bg-white border rounded shadow cursor-move"
        >
          <div class="flex items-center gap-2">
            <.icon name="hero-bars-3" class="text-gray-400" />
            <span><%= item.content %></span>
          </div>
        </li>
      </ul>
    </div>
    """
  end

  @impl true
  def handle_event("reorder", %{"ids" => ids}, socket) do
    case Lists.reorder_items(socket.assigns.list, ids) do
      {:ok, items} ->
        {:noreply, stream(socket, :items, items, reset: true)}

      {:error, _} ->
        {:noreply, put_flash(socket, :error, "Failed to save order")}
    end
  end
end

# JavaScript Hook
# Sortable = {
#   mounted() {
#     new Sortable(this.el, {
#       animation: 150,
#       onEnd: (evt) => {
#         const ids = Array.from(this.el.children).map(el => el.dataset.id)
#         this.pushEvent("reorder", { ids })
#       }
#     })
#   }
# }
```
</details>

## Exercise 5: Real-Time Notifications

Build a notification system with toast messages.

```elixir
# File: lib/snippetbox_web/live/notification_live.ex

defmodule SnippetboxWeb.NotificationLive do
  use SnippetboxWeb, :live_view

  # Requirements:
  # - Subscribe to user-specific notifications
  # - Show toast messages that auto-dismiss
  # - Support different types (info, success, error)
  # - Allow manual dismiss
  # - Stack multiple notifications
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.NotificationLive do
  use SnippetboxWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    if connected?(socket) do
      user_id = socket.assigns.current_user.id
      Phoenix.PubSub.subscribe(Snippetbox.PubSub, "user:#{user_id}:notifications")
    end

    {:ok, assign(socket, :notifications, [])}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="fixed top-4 right-4 z-50 space-y-2 w-80">
      <div
        :for={notif <- @notifications}
        id={"notification-#{notif.id}"}
        class={[
          "p-4 rounded-lg shadow-lg transition-all transform",
          notification_class(notif.type),
          notif.leaving && "opacity-0 translate-x-full"
        ]}
        phx-click="dismiss"
        phx-value-id={notif.id}
      >
        <div class="flex items-start gap-3">
          <.icon name={notification_icon(notif.type)} class="h-5 w-5" />
          <div class="flex-1">
            <p class="font-medium"><%= notif.title %></p>
            <p :if={notif.message} class="text-sm opacity-90"><%= notif.message %></p>
          </div>
          <button class="opacity-50 hover:opacity-100">&times;</button>
        </div>
      </div>
    </div>
    """
  end

  @impl true
  def handle_info({:notification, type, title, message}, socket) do
    notif = %{
      id: System.unique_integer([:positive]),
      type: type,
      title: title,
      message: message,
      leaving: false
    }

    # Auto-dismiss after 5 seconds
    Process.send_after(self(), {:auto_dismiss, notif.id}, 5000)

    {:noreply, update(socket, :notifications, &[notif | &1])}
  end

  def handle_info({:auto_dismiss, id}, socket) do
    {:noreply, dismiss_notification(socket, id)}
  end

  @impl true
  def handle_event("dismiss", %{"id" => id}, socket) do
    {:noreply, dismiss_notification(socket, String.to_integer(id))}
  end

  defp dismiss_notification(socket, id) do
    notifications =
      socket.assigns.notifications
      |> Enum.map(fn
        %{id: ^id} = n -> %{n | leaving: true}
        n -> n
      end)

    # Remove after animation
    Process.send_after(self(), {:remove, id}, 300)

    assign(socket, :notifications, notifications)
  end

  def handle_info({:remove, id}, socket) do
    notifications = Enum.reject(socket.assigns.notifications, &(&1.id == id))
    {:noreply, assign(socket, :notifications, notifications)}
  end

  defp notification_class(:info), do: "bg-blue-500 text-white"
  defp notification_class(:success), do: "bg-green-500 text-white"
  defp notification_class(:error), do: "bg-red-500 text-white"
  defp notification_class(:warning), do: "bg-yellow-500 text-black"

  defp notification_icon(:info), do: "hero-information-circle"
  defp notification_icon(:success), do: "hero-check-circle"
  defp notification_icon(:error), do: "hero-x-circle"
  defp notification_icon(:warning), do: "hero-exclamation-triangle"
end
```
</details>

## Exercise 6: Collaborative Editor

Build a simple collaborative text editor.

```elixir
# File: lib/snippetbox_web/live/collaborative_editor_live.ex

defmodule SnippetboxWeb.CollaborativeEditorLive do
  use SnippetboxWeb, :live_view

  # Requirements:
  # - Multiple users can edit same document
  # - Show cursors of other users
  # - Real-time sync (debounced)
  # - Show list of active editors
end
```

This is an advanced exercise combining presence, PubSub, and real-time updates.

## Challenge: Build a Kanban Board

Create a Kanban board with:

1. Multiple columns (To Do, In Progress, Done)
2. Drag cards between columns
3. Real-time updates for all viewers
4. Card editing inline
5. User assignment to cards

This comprehensive exercise tests all LiveView concepts together.
