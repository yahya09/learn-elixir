# Chapter 12.3: Live Components

Live Components provide encapsulation and reusability for LiveView. In this chapter, we'll explore stateful and stateless components.

## Stateless Function Components

Simple, reusable presentation components:

```elixir
# File: lib/snippetbox_web/components/snippet_components.ex

defmodule SnippetboxWeb.SnippetComponents do
  use Phoenix.Component

  attr :snippet, :map, required: true

  def snippet_card(assigns) do
    ~H"""
    <div class="border rounded-lg p-4 hover:shadow-lg transition">
      <h3 class="font-bold text-lg"><%= @snippet.title %></h3>
      <p class="text-sm text-gray-500"><%= @snippet.language %></p>
      <pre class="mt-2 bg-gray-100 p-2 rounded overflow-auto">
        <code><%= @snippet.content %></code>
      </pre>
    </div>
    """
  end

  attr :snippets, :list, required: true
  attr :on_click, :any, default: nil

  def snippet_list(assigns) do
    ~H"""
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <%= for snippet <- @snippets do %>
        <div phx-click={@on_click && @on_click.(snippet)}>
          <.snippet_card snippet={snippet} />
        </div>
      <% end %>
    </div>
    """
  end
end
```

## Stateful Live Components

Components with their own state and event handling:

```elixir
# File: lib/snippetbox_web/live/components/comment_form_component.ex

defmodule SnippetboxWeb.CommentFormComponent do
  use SnippetboxWeb, :live_component

  alias Snippetbox.Comments

  @impl true
  def render(assigns) do
    ~H"""
    <div>
      <.form
        for={@form}
        id="comment-form"
        phx-target={@myself}
        phx-change="validate"
        phx-submit="save"
      >
        <.input
          field={@form[:content]}
          type="textarea"
          label="Comment"
          rows={3}
        />
        <.button class="mt-2">Post Comment</.button>
      </.form>
    </div>
    """
  end

  @impl true
  def update(assigns, socket) do
    changeset = Comments.change_comment(%Comment{})

    {:ok,
     socket
     |> assign(assigns)
     |> assign_form(changeset)}
  end

  @impl true
  def handle_event("validate", %{"comment" => params}, socket) do
    changeset =
      %Comment{}
      |> Comments.change_comment(params)
      |> Map.put(:action, :validate)

    {:noreply, assign_form(socket, changeset)}
  end

  def handle_event("save", %{"comment" => params}, socket) do
    params = Map.put(params, "snippet_id", socket.assigns.snippet_id)

    case Comments.create_comment(params) do
      {:ok, comment} ->
        send(self(), {:comment_created, comment})
        {:noreply, assign_form(socket, Comments.change_comment(%Comment{}))}

      {:error, changeset} ->
        {:noreply, assign_form(socket, changeset)}
    end
  end

  defp assign_form(socket, changeset) do
    assign(socket, :form, to_form(changeset))
  end
end
```

## Using Live Components

```heex
<%# In parent LiveView template %>

<%# Stateless function component %>
<.snippet_card snippet={@snippet} />

<%# Stateful live component %>
<.live_component
  module={SnippetboxWeb.CommentFormComponent}
  id="comment-form"
  snippet_id={@snippet.id}
/>

<%# With update callback %>
<.live_component
  module={SnippetboxWeb.SnippetLive.FormComponent}
  id={@snippet.id || :new}
  title={@page_title}
  action={@live_action}
  snippet={@snippet}
  patch={~p"/snippets"}
/>
```

## Component Communication

### Child → Parent

```elixir
# In child component
defp notify_parent(msg) do
  send(self(), {__MODULE__, msg})
end

def handle_event("save", params, socket) do
  case create_item(params) do
    {:ok, item} ->
      notify_parent({:saved, item})
      {:noreply, socket}
  end
end

# In parent LiveView
@impl true
def handle_info({SnippetboxWeb.FormComponent, {:saved, item}}, socket) do
  {:noreply, stream_insert(socket, :items, item)}
end
```

### Parent → Child

```elixir
# Parent sends data via assigns
<.live_component
  module={FormComponent}
  id="form"
  item={@selected_item}
  mode={@form_mode}
/>

# Child receives in update/2
@impl true
def update(%{item: item, mode: mode} = assigns, socket) do
  {:ok,
   socket
   |> assign(assigns)
   |> assign_form(change_item(item))}
end
```

### send_update

```elixir
# Parent can send updates to child
send_update(FormComponent, id: "form", reset: true)

# Child handles in update/2
@impl true
def update(%{reset: true} = assigns, socket) do
  {:ok,
   socket
   |> assign(assigns)
   |> assign_form(change_item(%Item{}))}
end
```

## Component with Slots

```elixir
# File: lib/snippetbox_web/components/modal_component.ex

defmodule SnippetboxWeb.Components.Modal do
  use Phoenix.Component

  attr :id, :string, required: true
  attr :show, :boolean, default: false
  attr :on_cancel, JS, default: %JS{}
  slot :inner_block, required: true

  def modal(assigns) do
    ~H"""
    <div
      id={@id}
      phx-mounted={@show && show_modal(@id)}
      phx-remove={hide_modal(@id)}
      data-cancel={JS.exec(@on_cancel, "phx-remove")}
      class="relative z-50 hidden"
    >
      <div
        id={"#{@id}-bg"}
        class="bg-zinc-50/90 fixed inset-0 transition-opacity"
        aria-hidden="true"
      />
      <div
        class="fixed inset-0 overflow-y-auto"
        aria-labelledby={"#{@id}-title"}
        aria-describedby={"#{@id}-description"}
        role="dialog"
        aria-modal="true"
        tabindex="0"
      >
        <div class="flex min-h-full items-center justify-center">
          <div class="w-full max-w-3xl p-4 sm:p-6 lg:py-8">
            <.focus_wrap
              id={"#{@id}-container"}
              phx-window-keydown={JS.exec("data-cancel", to: "##{@id}")}
              phx-key="escape"
              phx-click-away={JS.exec("data-cancel", to: "##{@id}")}
              class="shadow-zinc-700/10 ring-zinc-700/10 relative hidden rounded-2xl bg-white p-14 shadow-lg ring-1 transition"
            >
              <div class="absolute top-6 right-5">
                <button
                  phx-click={JS.exec("data-cancel", to: "##{@id}")}
                  type="button"
                  class="-m-3 flex-none p-3 opacity-20 hover:opacity-40"
                >
                  <.icon name="hero-x-mark-solid" class="h-5 w-5" />
                </button>
              </div>
              <div id={"#{@id}-content"}>
                <%= render_slot(@inner_block) %>
              </div>
            </.focus_wrap>
          </div>
        </div>
      </div>
    </div>
    """
  end

  defp show_modal(js \\ %JS{}, id) do
    js
    |> JS.show(to: "##{id}")
    |> JS.show(
      to: "##{id}-bg",
      transition: {"transition-all ease-out duration-300", "opacity-0", "opacity-100"}
    )
    |> JS.show(
      to: "##{id}-container",
      transition: {"transition-all ease-out duration-300", "opacity-0 translate-y-4", "opacity-100 translate-y-0"}
    )
    |> JS.focus_first(to: "##{id}-content")
  end

  defp hide_modal(js \\ %JS{}, id) do
    js
    |> JS.hide(
      to: "##{id}-bg",
      transition: {"transition-all ease-in duration-200", "opacity-100", "opacity-0"}
    )
    |> JS.hide(
      to: "##{id}-container",
      transition: {"transition-all ease-in duration-200", "opacity-100 translate-y-0", "opacity-0 translate-y-4"}
    )
    |> JS.hide(to: "##{id}", transition: {"block", "block", "hidden"})
    |> JS.pop_focus()
  end
end
```

## Reusable Table Component

```elixir
# File: lib/snippetbox_web/components/data_table.ex

defmodule SnippetboxWeb.Components.DataTable do
  use Phoenix.Component

  attr :id, :string, required: true
  attr :rows, :list, required: true
  attr :row_id, :any, default: nil
  attr :row_click, :any, default: nil

  slot :col, required: true do
    attr :label, :string
    attr :class, :string
  end

  slot :action

  def data_table(assigns) do
    assigns =
      with %{rows: %Phoenix.LiveView.LiveStream{}} <- assigns do
        assign(assigns, row_id: assigns.row_id || fn {id, _item} -> id end)
      end

    ~H"""
    <div class="overflow-x-auto">
      <table class="w-full">
        <thead class="text-sm text-left text-zinc-500 border-b">
          <tr>
            <th :for={col <- @col} class={["p-3 font-medium", col[:class]]}>
              <%= col[:label] %>
            </th>
            <th :if={@action != []} class="p-3">
              <span class="sr-only">Actions</span>
            </th>
          </tr>
        </thead>
        <tbody
          id={@id}
          phx-update={match?(%Phoenix.LiveView.LiveStream{}, @rows) && "stream"}
          class="text-sm divide-y divide-zinc-100"
        >
          <tr
            :for={row <- @rows}
            id={@row_id && @row_id.(row)}
            class="hover:bg-zinc-50"
          >
            <td
              :for={{col, i} <- Enum.with_index(@col)}
              phx-click={@row_click && @row_click.(row)}
              class={["p-3", col[:class], @row_click && "cursor-pointer"]}
            >
              <%= render_slot(col, @row_id && elem(row, 1) || row) %>
            </td>
            <td :if={@action != []} class="p-3 text-right">
              <span :for={action <- @action}>
                <%= render_slot(action, @row_id && elem(row, 1) || row) %>
              </span>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    """
  end
end
```

### Usage

```heex
<.data_table id="snippets" rows={@streams.snippets} row_click={fn {_id, s} -> JS.navigate(~p"/snippets/#{s}") end}>
  <:col :let={snippet} label="Title"><%= snippet.title %></:col>
  <:col :let={snippet} label="Language"><%= snippet.language %></:col>
  <:col :let={snippet} label="Created" class="text-gray-500">
    <%= format_date(snippet.inserted_at) %>
  </:col>
  <:action :let={snippet}>
    <.link patch={~p"/snippets/#{snippet}/edit"}>Edit</.link>
  </:action>
</.data_table>
```

## Component Lifecycle

```elixir
defmodule SnippetboxWeb.TimerComponent do
  use SnippetboxWeb, :live_component

  @impl true
  def mount(socket) do
    # Called once when component is first mounted
    {:ok, assign(socket, count: 0)}
  end

  @impl true
  def update(assigns, socket) do
    # Called on initial mount and when parent sends new assigns
    {:ok, assign(socket, assigns)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div>
      Count: <%= @count %>
      <button phx-click="tick" phx-target={@myself}>Tick</button>
    </div>
    """
  end

  @impl true
  def handle_event("tick", _params, socket) do
    {:noreply, update(socket, :count, &(&1 + 1))}
  end
end
```

> **FP Concept: Component as Isolated State Machine**
>
> Each Live Component is an isolated state machine:
>
> ```elixir
> # State: socket.assigns
> # Events: handle_event/3
> # Transitions: return {:noreply, updated_socket}
>
> # Components are isolated:
> # - Their own state
> # - Their own event handlers
> # - Communication through explicit messages
> ```
>
> This isolation makes components predictable and testable.

## Summary

In this chapter, we learned:

- Stateless function components
- Stateful live components
- Component communication patterns
- Components with slots
- Reusable table components
- Component lifecycle

In the next chapter, we'll explore real-time features.
