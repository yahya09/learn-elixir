# Chapter 2.6: Project Structure and Organization

Understanding Phoenix's project structure is essential for navigating and extending your application. In this chapter, we'll explore how Phoenix organizes code and the reasoning behind its conventions.

## The Phoenix Project Layout

When you create a new Phoenix application, you get this structure:

```
snippetbox/
├── _build/              # Compiled files (gitignored)
├── assets/              # Frontend assets
│   ├── css/
│   ├── js/
│   └── vendor/
├── config/              # Configuration files
│   ├── config.exs       # Shared configuration
│   ├── dev.exs          # Development config
│   ├── prod.exs         # Production config
│   ├── runtime.exs      # Runtime config
│   └── test.exs         # Test config
├── deps/                # Dependencies (gitignored)
├── lib/                 # Application source code
│   ├── snippetbox/      # Core business logic
│   │   ├── application.ex
│   │   └── repo.ex
│   └── snippetbox_web/  # Web interface
│       ├── components/
│       ├── controllers/
│       ├── endpoint.ex
│       ├── router.ex
│       └── telemetry.ex
├── priv/                # Resources
│   ├── gettext/         # Translations
│   ├── repo/            # Database files
│   │   ├── migrations/
│   │   └── seeds.exs
│   └── static/          # Static assets
├── test/                # Tests
│   ├── snippetbox/
│   ├── snippetbox_web/
│   └── support/
├── .formatter.exs       # Code formatter config
├── .gitignore
├── mix.exs              # Project definition
├── mix.lock             # Dependency lock
└── README.md
```

## The lib/ Directory - Your Application Code

The most important directory is `lib/`. Phoenix splits your application into two main parts:

### lib/snippetbox/ - Core Application

This directory contains your business logic, independent of the web interface:

```
lib/snippetbox/
├── application.ex       # OTP application supervisor
├── repo.ex              # Database repository
├── snippets/            # Snippets context
│   ├── snippet.ex       # Snippet schema
│   └── snippets.ex      # Snippets API
└── accounts/            # Accounts context
    ├── user.ex          # User schema
    └── accounts.ex      # Accounts API
```

**Key principle**: Code in `lib/snippetbox/` should NOT know about HTTP, controllers, or web concepts. It's pure business logic.

### lib/snippetbox_web/ - Web Interface

This directory contains everything web-related:

```
lib/snippetbox_web/
├── components/          # Reusable UI components
│   ├── core_components.ex
│   └── layouts/
│       ├── app.html.heex
│       └── root.html.heex
├── controllers/         # Request handlers
│   ├── error_html.ex
│   ├── error_json.ex
│   ├── page_controller.ex
│   ├── page_html.ex
│   └── page_html/
│       └── home.html.heex
├── endpoint.ex          # HTTP entry point
├── gettext.ex           # Internationalization
├── router.ex            # URL routing
└── telemetry.ex         # Metrics/monitoring
```

## Why Two Directories?

This separation follows the **Hexagonal Architecture** (also called Ports and Adapters):

```
                    ┌─────────────────┐
                    │   Web (HTTP)    │
                    │ snippetbox_web  │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │  Core Business  │
                    │   snippetbox    │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │    Database     │
                    │   (via Ecto)    │
                    └─────────────────┘
```

Benefits:
- **Testability**: Test business logic without web layer
- **Reusability**: Same core can power web, CLI, API
- **Clarity**: Clear boundaries between concerns
- **Maintainability**: Changes in one layer don't ripple through

## Understanding Contexts

Phoenix encourages organizing business logic into **contexts** - modules that group related functionality:

```elixir
# File: lib/snippetbox/snippets.ex

defmodule Snippetbox.Snippets do
  @moduledoc """
  The Snippets context - public API for snippet operations.
  """

  alias Snippetbox.Repo
  alias Snippetbox.Snippets.Snippet

  def list_snippets do
    Repo.all(Snippet)
  end

  def get_snippet!(id) do
    Repo.get!(Snippet, id)
  end

  def create_snippet(attrs \\ %{}) do
    %Snippet{}
    |> Snippet.changeset(attrs)
    |> Repo.insert()
  end

  def update_snippet(%Snippet{} = snippet, attrs) do
    snippet
    |> Snippet.changeset(attrs)
    |> Repo.update()
  end

  def delete_snippet(%Snippet{} = snippet) do
    Repo.delete(snippet)
  end
end
```

Contexts provide:
- **Encapsulation**: Internal implementation hidden
- **Clear API**: Well-defined public functions
- **Organization**: Related code grouped together

### Context vs Model

If you're coming from Rails/Django, contexts replace the "fat model" pattern:

```ruby
# Rails: Fat model
class Snippet < ApplicationRecord
  def self.recent
    where('created_at > ?', 1.week.ago)
  end

  def publish!
    update!(published: true)
    NotificationMailer.published(self).deliver_later
  end
end
```

```elixir
# Phoenix: Thin schema + context
# File: lib/snippetbox/snippets/snippet.ex
defmodule Snippetbox.Snippets.Snippet do
  use Ecto.Schema
  import Ecto.Changeset

  schema "snippets" do
    field :title, :string
    field :content, :string
    timestamps()
  end

  def changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content])
    |> validate_required([:title, :content])
  end
end

# File: lib/snippetbox/snippets.ex
defmodule Snippetbox.Snippets do
  def recent_snippets do
    # Query logic here
  end

  def publish_snippet(snippet) do
    # Business logic here
    # Can call other contexts for notifications
  end
end
```

## The config/ Directory

Configuration files for different environments:

```
config/
├── config.exs      # Loaded first, shared config
├── dev.exs         # Development overrides
├── test.exs        # Test overrides
├── prod.exs        # Production defaults
└── runtime.exs     # Runtime config (env vars)
```

Loading order:
1. `config.exs` - always loaded
2. `dev.exs`/`test.exs`/`prod.exs` - based on `MIX_ENV`
3. `runtime.exs` - at application start (can use env vars)

Example configuration:

```elixir
# File: config/config.exs
import Config

config :snippetbox,
  ecto_repos: [Snippetbox.Repo]

config :snippetbox, SnippetboxWeb.Endpoint,
  url: [host: "localhost"],
  secret_key_base: "..."

# Import environment specific config
import_config "#{config_env()}.exs"
```

```elixir
# File: config/dev.exs
import Config

config :snippetbox, Snippetbox.Repo,
  database: "snippetbox_dev",
  hostname: "localhost",
  pool_size: 10
```

```elixir
# File: config/runtime.exs
import Config

if config_env() == :prod do
  config :snippetbox, Snippetbox.Repo,
    url: System.get_env("DATABASE_URL")

  config :snippetbox, SnippetboxWeb.Endpoint,
    secret_key_base: System.fetch_env!("SECRET_KEY_BASE")
end
```

## The priv/ Directory

Resources needed at runtime but not compiled:

```
priv/
├── gettext/             # Translation files
│   └── en/LC_MESSAGES/
├── repo/
│   ├── migrations/      # Database migrations
│   │   ├── 20240101000000_create_snippets.exs
│   │   └── 20240102000000_create_users.exs
│   └── seeds.exs        # Seed data
└── static/              # Static assets (compiled)
    ├── images/
    ├── assets/
    └── favicon.ico
```

Access `priv/` files in your code:

```elixir
# Get path to a file in priv/
path = Application.app_dir(:snippetbox, "priv/static/images/logo.png")

# Or use :code.priv_dir
path = :code.priv_dir(:snippetbox) |> Path.join("static/images/logo.png")
```

## The test/ Directory

Test files mirror your lib/ structure:

```
test/
├── snippetbox/                    # Core logic tests
│   ├── snippets_test.exs
│   └── accounts_test.exs
├── snippetbox_web/                # Web tests
│   ├── controllers/
│   │   └── snippet_controller_test.exs
│   └── live/
│       └── snippet_live_test.exs
├── support/                       # Test helpers
│   ├── conn_case.ex
│   ├── data_case.ex
│   └── fixtures/
│       └── snippets_fixtures.ex
└── test_helper.exs                # Test configuration
```

## File Naming Conventions

Phoenix follows these naming conventions:

| Type | Module Name | File Name |
|------|-------------|-----------|
| Controller | `SnippetController` | `snippet_controller.ex` |
| View | `SnippetHTML` | `snippet_html.ex` |
| Template | - | `snippet_html/show.html.heex` |
| Schema | `Snippet` | `snippet.ex` |
| Context | `Snippets` | `snippets.ex` |
| Live View | `SnippetLive.Index` | `snippet_live/index.ex` |

## Creating New Files

When adding features, follow this structure:

**Adding a new context (e.g., Comments):**

```
lib/snippetbox/
└── comments/
    ├── comment.ex       # Schema
    └── comments.ex      # Context API (or inline in comment.ex)

# Or generate it:
$ mix phx.gen.context Comments Comment comments content:text snippet_id:references:snippets
```

**Adding a new controller:**

```
lib/snippetbox_web/controllers/
├── comment_controller.ex
├── comment_html.ex
└── comment_html/
    ├── index.html.heex
    ├── show.html.heex
    └── new.html.heex

# Or generate it:
$ mix phx.gen.html Comments Comment comments content:text
```

## Understanding the Application Module

The application supervisor starts your app:

```elixir
# File: lib/snippetbox/application.ex

defmodule Snippetbox.Application do
  use Application

  @impl true
  def start(_type, _args) do
    children = [
      # Start the Telemetry supervisor
      SnippetboxWeb.Telemetry,
      # Start the Ecto repository
      Snippetbox.Repo,
      # Start PubSub for real-time features
      {Phoenix.PubSub, name: Snippetbox.PubSub},
      # Start the Endpoint (HTTP server)
      SnippetboxWeb.Endpoint
    ]

    opts = [strategy: :one_for_one, name: Snippetbox.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

> **FP Concept: Supervision Trees**
>
> In Elixir/OTP, applications are organized as supervision trees. Each "child" is a process (lightweight thread) that the supervisor monitors:
>
> ```
> Application Supervisor
> ├── Telemetry (metrics)
> ├── Repo (database connections)
> ├── PubSub (message broadcasting)
> └── Endpoint (HTTP server)
> ```
>
> If a child crashes, the supervisor restarts it. This is the "let it crash" philosophy - don't try to handle every error, let processes fail and restart cleanly.
>
> Benefits:
> - **Fault tolerance**: Crashes are isolated
> - **Self-healing**: Failed processes restart automatically
> - **Predictable**: Defined restart strategies
>
> **Further Reading**:
> - [OTP Supervisors](https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html)
> - [GenServer](https://hexdocs.pm/elixir/GenServer.html)

## Summary

In this chapter, we learned:

- Phoenix's project directory structure
- The separation between `lib/app/` (core) and `lib/app_web/` (web)
- How contexts organize business logic
- Configuration file organization
- File naming conventions
- The supervision tree structure

In the next chapter, we'll explore HTML templating with EEx.

---

## Additional Information

### Comparing to Other Frameworks

**Rails**:
```
app/
├── controllers/
├── models/
├── views/
└── helpers/
```

**Django**:
```
myapp/
├── views.py
├── models.py
├── urls.py
└── templates/
```

**Laravel**:
```
app/
├── Http/Controllers/
├── Models/
└── Providers/
```

**Phoenix**:
```
lib/
├── myapp/           # Business logic (like models)
└── myapp_web/       # Web layer (like controllers/views)
```

Phoenix's separation is more explicit than other frameworks, making the boundary between business logic and web interface clearer.

### When to Create a New Context

Create a new context when:
- You have a new business domain (e.g., Notifications, Billing)
- Code is growing too large in existing context
- You want clear API boundaries

Don't over-contextualize:
- Start with fewer, larger contexts
- Split when natural boundaries emerge
- One-entity contexts are usually too granular
