# Chapter 12.4: Real-Time Features

LiveView excels at real-time features. In this chapter, we'll explore PubSub, presence, and live updates.

## Phoenix PubSub

PubSub enables message broadcasting across processes:

```elixir
# Subscribe to a topic
Phoenix.PubSub.subscribe(Snippetbox.PubSub, "snippets")

# Broadcast to all subscribers
Phoenix.PubSub.broadcast(Snippetbox.PubSub, "snippets", {:snippet_created, snippet})
```

## Real-Time Snippet Updates

### Broadcasting Changes

```elixir
# File: lib/snippetbox/snippets.ex

defmodule Snippetbox.Snippets do
  alias Snippetbox.Snippets.Snippet
  alias Snippetbox.Repo

  @pubsub Snippetbox.PubSub
  @topic "snippets"

  def subscribe do
    Phoenix.PubSub.subscribe(@pubsub, @topic)
  end

  def subscribe(snippet_id) do
    Phoenix.PubSub.subscribe(@pubsub, "#{@topic}:#{snippet_id}")
  end

  def create_snippet(attrs \\ %{}) do
    %Snippet{}
    |> Snippet.changeset(attrs)
    |> Repo.insert()
    |> broadcast(:snippet_created)
  end

  def update_snippet(%Snippet{} = snippet, attrs) do
    snippet
    |> Snippet.changeset(attrs)
    |> Repo.update()
    |> broadcast(:snippet_updated)
  end

  def delete_snippet(%Snippet{} = snippet) do
    snippet
    |> Repo.delete()
    |> broadcast(:snippet_deleted)
  end

  defp broadcast({:ok, snippet}, event) do
    Phoenix.PubSub.broadcast(@pubsub, @topic, {event, snippet})
    Phoenix.PubSub.broadcast(@pubsub, "#{@topic}:#{snippet.id}", {event, snippet})
    {:ok, snippet}
  end

  defp broadcast({:error, changeset}, _event), do: {:error, changeset}
end
```

### Receiving Updates in LiveView

```elixir
# File: lib/snippetbox_web/live/snippet_live/index.ex

defmodule SnippetboxWeb.SnippetLive.Index do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Snippets

  @impl true
  def mount(_params, _session, socket) do
    if connected?(socket) do
      Snippets.subscribe()
    end

    {:ok, stream(socket, :snippets, Snippets.list_snippets())}
  end

  @impl true
  def handle_info({:snippet_created, snippet}, socket) do
    {:noreply, stream_insert(socket, :snippets, snippet, at: 0)}
  end

  @impl true
  def handle_info({:snippet_updated, snippet}, socket) do
    {:noreply, stream_insert(socket, :snippets, snippet)}
  end

  @impl true
  def handle_info({:snippet_deleted, snippet}, socket) do
    {:noreply, stream_delete(socket, :snippets, snippet)}
  end
end
```

## Live Notifications

### Notification System

```elixir
# File: lib/snippetbox/notifications.ex

defmodule Snippetbox.Notifications do
  @pubsub Snippetbox.PubSub

  def subscribe(user_id) do
    Phoenix.PubSub.subscribe(@pubsub, "user:#{user_id}:notifications")
  end

  def notify(user_id, notification) do
    Phoenix.PubSub.broadcast(
      @pubsub,
      "user:#{user_id}:notifications",
      {:new_notification, notification}
    )
  end
end
```

### Notification Component

```elixir
# File: lib/snippetbox_web/live/components/notification_live.ex

defmodule SnippetboxWeb.NotificationLive do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Notifications

  @impl true
  def mount(_params, _session, socket) do
    if connected?(socket) do
      user_id = socket.assigns.current_user.id
      Notifications.subscribe(user_id)
    end

    {:ok,
     socket
     |> assign(:notifications, [])
     |> assign(:unread_count, 0)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="relative">
      <button
        phx-click="toggle"
        class="relative p-2 text-gray-600 hover:text-gray-900"
      >
        <.icon name="hero-bell" class="h-6 w-6" />
        <span
          :if={@unread_count > 0}
          class="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center"
        >
          <%= @unread_count %>
        </span>
      </button>

      <div
        :if={@show_panel}
        class="absolute right-0 mt-2 w-80 bg-white rounded-lg shadow-lg z-50"
      >
        <div class="p-4 border-b">
          <h3 class="font-semibold">Notifications</h3>
        </div>

        <div class="max-h-96 overflow-y-auto">
          <div
            :for={notification <- @notifications}
            class={["p-4 border-b hover:bg-gray-50", !notification.read && "bg-blue-50"]}
          >
            <p class="text-sm"><%= notification.message %></p>
            <p class="text-xs text-gray-500 mt-1">
              <%= format_time(notification.inserted_at) %>
            </p>
          </div>

          <p :if={@notifications == []} class="p-4 text-gray-500 text-center">
            No notifications
          </p>
        </div>
      </div>
    </div>
    """
  end

  @impl true
  def handle_event("toggle", _params, socket) do
    {:noreply, update(socket, :show_panel, &(!&1))}
  end

  @impl true
  def handle_info({:new_notification, notification}, socket) do
    {:noreply,
     socket
     |> update(:notifications, &[notification | &1])
     |> update(:unread_count, &(&1 + 1))}
  end

  defp format_time(datetime) do
    # Simple relative time
    diff = NaiveDateTime.diff(NaiveDateTime.utc_now(), datetime)

    cond do
      diff < 60 -> "just now"
      diff < 3600 -> "#{div(diff, 60)}m ago"
      diff < 86400 -> "#{div(diff, 3600)}h ago"
      true -> Calendar.strftime(datetime, "%b %d")
    end
  end
end
```

## Presence

Track who's online in real-time:

### Presence Module

```elixir
# File: lib/snippetbox_web/presence.ex

defmodule SnippetboxWeb.Presence do
  use Phoenix.Presence,
    otp_app: :snippetbox,
    pubsub_server: Snippetbox.PubSub
end
```

### Application Supervisor

```elixir
# File: lib/snippetbox/application.ex

def start(_type, _args) do
  children = [
    # ...
    SnippetboxWeb.Presence
  ]

  opts = [strategy: :one_for_one, name: Snippetbox.Supervisor]
  Supervisor.start_link(children, opts)
end
```

### Tracking Users

```elixir
# File: lib/snippetbox_web/live/snippet_live/show.ex

defmodule SnippetboxWeb.SnippetLive.Show do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Snippets
  alias SnippetboxWeb.Presence

  @impl true
  def mount(%{"id" => id}, _session, socket) do
    snippet = Snippets.get_snippet!(id)
    topic = "snippet:#{id}"

    if connected?(socket) do
      # Subscribe to presence changes
      Phoenix.PubSub.subscribe(Snippetbox.PubSub, topic)

      # Track this user's presence
      Presence.track(self(), topic, socket.assigns.current_user.id, %{
        name: socket.assigns.current_user.name,
        joined_at: DateTime.utc_now()
      })
    end

    presences = Presence.list(topic)

    {:ok,
     socket
     |> assign(:snippet, snippet)
     |> assign(:presences, presences)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div>
      <.header>
        <%= @snippet.title %>
        <:subtitle>
          <span class="flex items-center gap-2">
            <span class="inline-block w-2 h-2 bg-green-500 rounded-full"></span>
            <%= map_size(@presences) %> viewing
          </span>
        </:subtitle>
      </.header>

      <div class="mt-4 flex -space-x-2">
        <%= for {_user_id, %{metas: [meta | _]}} <- @presences do %>
          <div
            class="w-8 h-8 rounded-full bg-blue-500 text-white flex items-center justify-center text-sm border-2 border-white"
            title={meta.name}
          >
            <%= String.first(meta.name) %>
          </div>
        <% end %>
      </div>

      <pre class="mt-6 bg-gray-100 p-4 rounded-lg overflow-auto">
        <code><%= @snippet.content %></code>
      </pre>
    </div>
    """
  end

  @impl true
  def handle_info(%Phoenix.Socket.Broadcast{event: "presence_diff", payload: diff}, socket) do
    presences =
      socket.assigns.presences
      |> Presence.sync_diff(diff)

    {:noreply, assign(socket, :presences, presences)}
  end
end
```

## Live Chat

### Chat Messages

```elixir
# File: lib/snippetbox/chat.ex

defmodule Snippetbox.Chat do
  @pubsub Snippetbox.PubSub

  def subscribe(room_id) do
    Phoenix.PubSub.subscribe(@pubsub, "chat:#{room_id}")
  end

  def send_message(room_id, user, content) do
    message = %{
      id: System.unique_integer([:positive]),
      user: user,
      content: content,
      sent_at: DateTime.utc_now()
    }

    Phoenix.PubSub.broadcast(@pubsub, "chat:#{room_id}", {:new_message, message})
    {:ok, message}
  end
end
```

### Chat LiveView

```elixir
# File: lib/snippetbox_web/live/chat_live.ex

defmodule SnippetboxWeb.ChatLive do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Chat
  alias SnippetboxWeb.Presence

  @impl true
  def mount(%{"room_id" => room_id}, _session, socket) do
    topic = "chat:#{room_id}"

    if connected?(socket) do
      Chat.subscribe(room_id)
      Phoenix.PubSub.subscribe(Snippetbox.PubSub, topic)

      Presence.track(self(), topic, socket.assigns.current_user.id, %{
        name: socket.assigns.current_user.name,
        typing: false
      })
    end

    {:ok,
     socket
     |> assign(:room_id, room_id)
     |> assign(:message, "")
     |> assign(:presences, Presence.list(topic))
     |> stream(:messages, [])}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="flex h-[600px]">
      <%# Messages area %>
      <div class="flex-1 flex flex-col">
        <div
          id="messages"
          phx-update="stream"
          class="flex-1 overflow-y-auto p-4 space-y-4"
        >
          <div
            :for={{dom_id, message} <- @streams.messages}
            id={dom_id}
            class={[
              "flex gap-3",
              message.user.id == @current_user.id && "flex-row-reverse"
            ]}
          >
            <div class="w-8 h-8 rounded-full bg-blue-500 text-white flex items-center justify-center">
              <%= String.first(message.user.name) %>
            </div>
            <div class={[
              "max-w-xs px-4 py-2 rounded-lg",
              message.user.id == @current_user.id && "bg-blue-500 text-white",
              message.user.id != @current_user.id && "bg-gray-200"
            ]}>
              <p class="text-xs font-medium mb-1"><%= message.user.name %></p>
              <p><%= message.content %></p>
            </div>
          </div>
        </div>

        <%# Typing indicator %>
        <div :if={typing_users(@presences, @current_user.id) != []} class="px-4 py-2 text-sm text-gray-500">
          <%= Enum.join(typing_users(@presences, @current_user.id), ", ") %> typing...
        </div>

        <%# Message input %>
        <form phx-submit="send" phx-change="typing" class="p-4 border-t">
          <div class="flex gap-2">
            <input
              type="text"
              name="message"
              value={@message}
              placeholder="Type a message..."
              class="flex-1 rounded-lg border-gray-300"
              autocomplete="off"
            />
            <.button type="submit">Send</.button>
          </div>
        </form>
      </div>

      <%# Online users sidebar %>
      <div class="w-64 border-l p-4">
        <h3 class="font-semibold mb-4">Online (<%= map_size(@presences) %>)</h3>
        <ul class="space-y-2">
          <%= for {_user_id, %{metas: [meta | _]}} <- @presences do %>
            <li class="flex items-center gap-2">
              <span class="w-2 h-2 bg-green-500 rounded-full"></span>
              <%= meta.name %>
            </li>
          <% end %>
        </ul>
      </div>
    </div>
    """
  end

  @impl true
  def handle_event("send", %{"message" => content}, socket) when content != "" do
    Chat.send_message(socket.assigns.room_id, socket.assigns.current_user, content)
    update_typing(socket, false)
    {:noreply, assign(socket, :message, "")}
  end

  def handle_event("send", _params, socket), do: {:noreply, socket}

  def handle_event("typing", %{"message" => message}, socket) do
    is_typing = String.length(message) > 0
    update_typing(socket, is_typing)
    {:noreply, assign(socket, :message, message)}
  end

  @impl true
  def handle_info({:new_message, message}, socket) do
    {:noreply, stream_insert(socket, :messages, message)}
  end

  def handle_info(%Phoenix.Socket.Broadcast{event: "presence_diff", payload: diff}, socket) do
    presences = Presence.sync_diff(socket.assigns.presences, diff)
    {:noreply, assign(socket, :presences, presences)}
  end

  defp update_typing(socket, typing) do
    topic = "chat:#{socket.assigns.room_id}"

    Presence.update(self(), topic, socket.assigns.current_user.id, fn meta ->
      Map.put(meta, :typing, typing)
    end)
  end

  defp typing_users(presences, current_user_id) do
    presences
    |> Enum.filter(fn {user_id, %{metas: [meta | _]}} ->
      user_id != to_string(current_user_id) && meta.typing
    end)
    |> Enum.map(fn {_, %{metas: [meta | _]}} -> meta.name end)
  end
end
```

## Live Dashboard

### Real-Time Metrics

```elixir
# File: lib/snippetbox_web/live/dashboard_live.ex

defmodule SnippetboxWeb.DashboardLive do
  use SnippetboxWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    if connected?(socket) do
      # Update every 5 seconds
      :timer.send_interval(5000, self(), :update_metrics)
    end

    {:ok, assign_metrics(socket)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <.metric_card
        title="Total Snippets"
        value={@total_snippets}
        change={@snippets_change}
      />
      <.metric_card
        title="Active Users"
        value={@active_users}
        change={@users_change}
      />
      <.metric_card
        title="Views Today"
        value={@views_today}
        change={@views_change}
      />
    </div>

    <div class="mt-8">
      <h2 class="text-lg font-semibold mb-4">Recent Activity</h2>
      <div id="activity" phx-update="stream" class="space-y-2">
        <div
          :for={{dom_id, activity} <- @streams.activities}
          id={dom_id}
          class="flex items-center gap-3 p-3 bg-gray-50 rounded"
        >
          <.icon name={activity_icon(activity.type)} class="h-5 w-5 text-gray-500" />
          <span><%= activity.message %></span>
          <span class="ml-auto text-sm text-gray-500"><%= activity.time %></span>
        </div>
      </div>
    </div>
    """
  end

  attr :title, :string, required: true
  attr :value, :integer, required: true
  attr :change, :float, required: true

  defp metric_card(assigns) do
    ~H"""
    <div class="bg-white rounded-lg shadow p-6">
      <h3 class="text-sm font-medium text-gray-500"><%= @title %></h3>
      <div class="mt-2 flex items-baseline gap-2">
        <span class="text-3xl font-bold"><%= @value %></span>
        <span class={[
          "text-sm",
          @change >= 0 && "text-green-600",
          @change < 0 && "text-red-600"
        ]}>
          <%= if @change >= 0, do: "+", else: "" %><%= Float.round(@change, 1) %>%
        </span>
      </div>
    </div>
    """
  end

  @impl true
  def handle_info(:update_metrics, socket) do
    {:noreply, assign_metrics(socket)}
  end

  def handle_info({:new_activity, activity}, socket) do
    {:noreply, stream_insert(socket, :activities, activity, at: 0)}
  end

  defp assign_metrics(socket) do
    socket
    |> assign(:total_snippets, Snippetbox.Snippets.count_snippets())
    |> assign(:snippets_change, calculate_change(:snippets))
    |> assign(:active_users, Snippetbox.Accounts.count_active_users())
    |> assign(:users_change, calculate_change(:users))
    |> assign(:views_today, Snippetbox.Analytics.views_today())
    |> assign(:views_change, calculate_change(:views))
    |> stream(:activities, Snippetbox.Activities.recent(10), reset: true)
  end

  defp calculate_change(_metric) do
    # Calculate percentage change from yesterday
    :rand.uniform() * 20 - 5  # Placeholder
  end

  defp activity_icon(:create), do: "hero-plus-circle"
  defp activity_icon(:update), do: "hero-pencil"
  defp activity_icon(:delete), do: "hero-trash"
  defp activity_icon(_), do: "hero-information-circle"
end
```

## Debounced Search

```elixir
# File: lib/snippetbox_web/live/search_live.ex

defmodule SnippetboxWeb.SearchLive do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Snippets

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |> assign(:query, "")
     |> assign(:results, [])
     |> assign(:loading, false)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="max-w-2xl mx-auto">
      <form phx-change="search" phx-submit="search">
        <div class="relative">
          <input
            type="text"
            name="query"
            value={@query}
            placeholder="Search snippets..."
            phx-debounce="300"
            class="w-full pl-10 pr-4 py-3 rounded-lg border-gray-300 shadow-sm"
          />
          <.icon
            name="hero-magnifying-glass"
            class="absolute left-3 top-3.5 h-5 w-5 text-gray-400"
          />
          <div
            :if={@loading}
            class="absolute right-3 top-3"
          >
            <.spinner />
          </div>
        </div>
      </form>

      <div :if={@query != "" && @results == []} class="mt-8 text-center text-gray-500">
        No results found for "<%= @query %>"
      </div>

      <ul :if={@results != []} class="mt-4 divide-y">
        <li :for={snippet <- @results} class="py-4">
          <.link navigate={~p"/snippets/#{snippet}"} class="block hover:bg-gray-50 -mx-4 px-4 py-2 rounded">
            <h3 class="font-medium"><%= snippet.title %></h3>
            <p class="text-sm text-gray-500 mt-1">
              <%= String.slice(snippet.content, 0, 100) %>...
            </p>
            <div class="flex gap-2 mt-2">
              <span class="text-xs bg-gray-100 px-2 py-1 rounded"><%= snippet.language %></span>
            </div>
          </.link>
        </li>
      </ul>
    </div>
    """
  end

  @impl true
  def handle_event("search", %{"query" => query}, socket) when byte_size(query) >= 2 do
    send(self(), {:search, query})

    {:noreply,
     socket
     |> assign(:query, query)
     |> assign(:loading, true)}
  end

  def handle_event("search", %{"query" => query}, socket) do
    {:noreply,
     socket
     |> assign(:query, query)
     |> assign(:results, [])
     |> assign(:loading, false)}
  end

  @impl true
  def handle_info({:search, query}, socket) do
    results = Snippets.search(query)

    {:noreply,
     socket
     |> assign(:results, results)
     |> assign(:loading, false)}
  end
end
```

## Async Operations

```elixir
# File: lib/snippetbox_web/live/export_live.ex

defmodule SnippetboxWeb.ExportLive do
  use SnippetboxWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |> assign(:status, :idle)
     |> assign(:progress, 0)
     |> assign(:download_url, nil)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="max-w-md mx-auto text-center">
      <h1 class="text-2xl font-bold mb-6">Export Snippets</h1>

      <div :if={@status == :idle}>
        <p class="text-gray-600 mb-4">
          Export all your snippets as a ZIP file.
        </p>
        <.button phx-click="start_export">
          Start Export
        </.button>
      </div>

      <div :if={@status == :processing}>
        <p class="text-gray-600 mb-4">Processing...</p>
        <div class="w-full bg-gray-200 rounded-full h-4">
          <div
            class="bg-blue-600 h-4 rounded-full transition-all duration-300"
            style={"width: #{@progress}%"}
          >
          </div>
        </div>
        <p class="text-sm text-gray-500 mt-2"><%= @progress %>%</p>
      </div>

      <div :if={@status == :complete}>
        <p class="text-green-600 mb-4">Export complete!</p>
        <a
          href={@download_url}
          download
          class="inline-flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg"
        >
          <.icon name="hero-arrow-down-tray" class="h-5 w-5" />
          Download ZIP
        </a>
      </div>
    </div>
    """
  end

  @impl true
  def handle_event("start_export", _params, socket) do
    user_id = socket.assigns.current_user.id
    lv_pid = self()

    # Start async export task
    Task.Supervisor.start_child(Snippetbox.TaskSupervisor, fn ->
      export_snippets(user_id, lv_pid)
    end)

    {:noreply, assign(socket, :status, :processing)}
  end

  @impl true
  def handle_info({:export_progress, progress}, socket) do
    {:noreply, assign(socket, :progress, progress)}
  end

  def handle_info({:export_complete, url}, socket) do
    {:noreply,
     socket
     |> assign(:status, :complete)
     |> assign(:progress, 100)
     |> assign(:download_url, url)}
  end

  defp export_snippets(user_id, lv_pid) do
    snippets = Snippetbox.Snippets.list_user_snippets(user_id)
    total = length(snippets)

    # Process snippets and report progress
    Enum.with_index(snippets, 1)
    |> Enum.each(fn {_snippet, index} ->
      # Simulate processing
      Process.sleep(100)
      progress = round(index / total * 100)
      send(lv_pid, {:export_progress, progress})
    end)

    # Create ZIP and return URL
    url = "/downloads/export-#{user_id}.zip"
    send(lv_pid, {:export_complete, url})
  end
end
```

> **FP Concept: Message Passing**
>
> LiveView real-time features use Erlang's message passing model:
>
> ```elixir
> # Processes communicate via messages
> send(pid, {:event, data})
>
> # Handled in receive/handle_info
> def handle_info({:event, data}, socket) do
>   {:noreply, update_socket(socket, data)}
> end
>
> # PubSub is broadcast messaging
> Phoenix.PubSub.broadcast(pubsub, topic, message)
> # All subscribers receive the message
> ```
>
> This model enables real-time features without shared mutable state.

## Summary

In this chapter, we learned:

- Phoenix PubSub for broadcasting
- Real-time updates with streams
- Presence tracking
- Live chat implementation
- Live dashboards
- Debounced search
- Async operations with progress

This completes the LiveView chapter. In the next chapter, we'll explore testing Phoenix applications.
