# Chapter 14.3: Fly.io Deployment

Fly.io is a platform optimized for Elixir applications with built-in support for clustering and edge deployment. In this chapter, we'll deploy our Phoenix app to Fly.io.

## Getting Started

### Install Fly CLI

```bash
# macOS
brew install flyctl

# Linux
curl -L https://fly.io/install.sh | sh

# Windows
pwsh -Command "iwr https://fly.io/install.ps1 -useb | iex"
```

### Authentication

```bash
# Sign up or log in
fly auth signup
# or
fly auth login
```

## Launching Your App

### Initialize

```bash
# In your Phoenix project directory
fly launch

# This will:
# 1. Detect Phoenix application
# 2. Generate fly.toml configuration
# 3. Create Dockerfile if needed
# 4. Set up PostgreSQL database
# 5. Configure secrets
```

### Generated fly.toml

```toml
# File: fly.toml

app = "snippetbox"
primary_region = "iad"

[build]

[env]
  PHX_HOST = "snippetbox.fly.dev"
  PORT = "8080"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 0
  processes = ["app"]

[[vm]]
  cpu_kind = "shared"
  cpus = 1
  memory_mb = 256
```

### Deploy

```bash
# Deploy the application
fly deploy

# Watch deployment logs
fly logs

# Open in browser
fly open
```

## Database Setup

### PostgreSQL

```bash
# Create Postgres cluster
fly postgres create

# Attach to your app (sets DATABASE_URL secret)
fly postgres attach --app snippetbox snippetbox-db

# Connect to database
fly postgres connect -a snippetbox-db
```

### Running Migrations

```bash
# Run migrations on deploy
fly deploy

# Or manually
fly ssh console -C "/app/bin/snippetbox eval 'Snippetbox.Release.migrate()'"

# Or using flyctl
fly ssh console
/app/bin/snippetbox eval "Snippetbox.Release.migrate()"
```

## Secrets Management

```bash
# Set secrets
fly secrets set SECRET_KEY_BASE=$(mix phx.gen.secret)
fly secrets set POSTMARK_API_KEY=your-api-key

# List secrets
fly secrets list

# Unset secrets
fly secrets unset OLD_SECRET
```

## Configuration

### fly.toml Deep Dive

```toml
# File: fly.toml

app = "snippetbox"
primary_region = "iad"
kill_signal = "SIGTERM"
kill_timeout = "5s"

[build]
  [build.args]
    ELIXIR_VERSION = "1.16.0"
    OTP_VERSION = "26.2"

[deploy]
  release_command = "/app/bin/snippetbox eval 'Snippetbox.Release.migrate()'"

[env]
  PHX_HOST = "snippetbox.fly.dev"
  PORT = "8080"
  ECTO_IPV6 = "true"
  ERL_AFLAGS = "-proto_dist inet6_tcp"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 1
  processes = ["app"]

  [http_service.concurrency]
    type = "connections"
    hard_limit = 1000
    soft_limit = 1000

[[services]]
  protocol = "tcp"
  internal_port = 8080

  [[services.ports]]
    port = 80
    handlers = ["http"]

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]

  [[services.tcp_checks]]
    interval = "15s"
    timeout = "2s"
    grace_period = "5s"

  [[services.http_checks]]
    interval = "10s"
    timeout = "2s"
    grace_period = "5s"
    method = "get"
    path = "/health"

[[vm]]
  cpu_kind = "shared"
  cpus = 1
  memory_mb = 512
```

## Scaling

### Vertical Scaling

```bash
# Scale up VM size
fly scale vm shared-cpu-2x

# Available sizes:
# shared-cpu-1x (256MB)
# shared-cpu-2x (512MB)
# shared-cpu-4x (1GB)
# dedicated-cpu-1x (2GB)
# dedicated-cpu-2x (4GB)
```

### Horizontal Scaling

```bash
# Scale to multiple instances
fly scale count 3

# Scale in specific region
fly scale count 2 --region iad

# Auto-scaling in fly.toml
[http_service]
  min_machines_running = 1
  auto_stop_machines = true
  auto_start_machines = true
```

### Multi-Region

```bash
# Add regions
fly regions add fra lhr sin

# List regions
fly regions list

# Deploy to multiple regions
fly deploy
```

## Clustering

### Configure Clustering

```elixir
# File: config/runtime.exs

if config_env() == :prod do
  app_name =
    System.get_env("FLY_APP_NAME") ||
      raise "FLY_APP_NAME not available"

  config :libcluster,
    topologies: [
      fly6pn: [
        strategy: Cluster.Strategy.DNSPoll,
        config: [
          polling_interval: 5_000,
          query: "#{app_name}.internal",
          node_basename: app_name
        ]
      ]
    ]
end
```

```elixir
# File: lib/snippetbox/application.ex

def start(_type, _args) do
  topologies = Application.get_env(:libcluster, :topologies) || []

  children = [
    {Cluster.Supervisor, [topologies, [name: Snippetbox.ClusterSupervisor]]},
    # ... other children
  ]
end
```

### Verify Clustering

```bash
# SSH into app
fly ssh console

# Check connected nodes
/app/bin/snippetbox remote
iex> Node.list()
[:"snippetbox@fdaa:0:1234:a7b:..."]
```

## Custom Domains

```bash
# Add custom domain
fly certs create snippetbox.com

# Add www subdomain
fly certs create www.snippetbox.com

# Check certificate status
fly certs show snippetbox.com
```

### DNS Configuration

```
# Add these DNS records:

# A record for root domain
snippetbox.com    A    [Fly IP]

# AAAA record for IPv6
snippetbox.com    AAAA [Fly IPv6]

# CNAME for www
www.snippetbox.com CNAME snippetbox.fly.dev
```

## Continuous Deployment

### GitHub Actions

```yaml
# File: .github/workflows/fly.yml

name: Fly Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    name: Deploy app
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - uses: superfly/flyctl-actions/setup-flyctl@master

      - run: flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
```

### Get Deploy Token

```bash
# Create deploy token
fly tokens create deploy -x 999999h

# Add to GitHub secrets as FLY_API_TOKEN
```

## Monitoring

```bash
# View logs
fly logs

# Follow logs
fly logs -f

# Dashboard
fly dashboard

# Status
fly status

# SSH for debugging
fly ssh console
```

## Volumes (Persistent Storage)

```bash
# Create volume
fly volumes create data --size 10 --region iad

# Mount in fly.toml
[mounts]
  source = "data"
  destination = "/app/data"
```

## Rollbacks

```bash
# List releases
fly releases

# Rollback to previous version
fly deploy --image registry.fly.io/snippetbox:deployment-xxxx
```

## Cost Optimization

```toml
# Auto-stop idle machines
[http_service]
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 0

# Use shared CPUs
[[vm]]
  cpu_kind = "shared"
  cpus = 1
  memory_mb = 256
```

> **FP Concept: Stateless by Default**
>
> Fly.io encourages stateless application design:
>
> ```elixir
> # State lives in database, not in memory
> # Machines can stop/start freely
> # Horizontal scaling is trivial
>
> # Good: Query database
> Snippets.list_snippets()
>
> # Bad: Store in process state (lost on restart)
> Agent.update(:cache, &Map.put(&1, key, value))
>
> # Better: Use distributed cache
> Cachex.put(:cache, key, value)
> ```
>
> This aligns with functional programming's preference for explicit state management.

## Summary

In this chapter, we learned:

- Setting up Fly.io
- Deploying Phoenix applications
- Database configuration
- Secrets management
- Scaling (vertical, horizontal, multi-region)
- Clustering configuration
- Custom domains and SSL
- Continuous deployment
- Monitoring and debugging

In the next chapter, we'll explore production configuration.
