# Chapter 3.1: Managing Configuration

Phoenix uses Elixir's built-in configuration system with a clear file structure. In this chapter, we'll explore how configuration works and how to manage settings across environments.

## Configuration File Structure

A Phoenix project has these configuration files:

```
config/
├── config.exs      # Base configuration (loaded first)
├── dev.exs         # Development overrides
├── test.exs        # Test overrides
├── prod.exs        # Production defaults
└── runtime.exs     # Runtime config (env vars)
```

## The Base Configuration (config.exs)

This file contains configuration shared across all environments:

```elixir
# File: config/config.exs

import Config

# Application-wide settings
config :snippetbox,
  ecto_repos: [Snippetbox.Repo],
  generators: [timestamp_type: :utc_datetime]

# Endpoint configuration
config :snippetbox, SnippetboxWeb.Endpoint,
  url: [host: "localhost"],
  adapter: Bandit.PhoenixAdapter,
  render_errors: [
    formats: [html: SnippetboxWeb.ErrorHTML, json: SnippetboxWeb.ErrorJSON],
    layout: false
  ],
  pubsub_server: Snippetbox.PubSub,
  live_view: [signing_salt: "abc123xyz"]

# Logger configuration
config :logger, :console,
  format: "$time $metadata[$level] $message\n",
  metadata: [:request_id]

# Phoenix configuration
config :phoenix, :json_library, Jason

# Import environment-specific config
import_config "#{config_env()}.exs"
```

Key points:
- `import Config` loads the configuration module
- `config :app, key: value` sets app-level config
- `config :app, Module, key: value` sets module-specific config
- `import_config` loads environment-specific files

## Development Configuration (dev.exs)

Settings optimized for development:

```elixir
# File: config/dev.exs

import Config

# Database configuration
config :snippetbox, Snippetbox.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "snippetbox_dev",
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 10

# Endpoint configuration for development
config :snippetbox, SnippetboxWeb.Endpoint,
  http: [ip: {127, 0, 0, 1}, port: 4000],
  check_origin: false,
  code_reloader: true,
  debug_errors: true,
  secret_key_base: "dev-secret-key-at-least-64-bytes-long-for-development-only!!!!",
  watchers: [
    esbuild: {Esbuild, :install_and_run, [:default, ~w(--sourcemap=inline --watch)]},
    tailwind: {Tailwind, :install_and_run, [:default, ~w(--watch)]}
  ]

# Live reload for development
config :snippetbox, SnippetboxWeb.Endpoint,
  live_reload: [
    patterns: [
      ~r"priv/static/(?!uploads/).*(js|css|png|jpeg|jpg|gif|svg)$",
      ~r"priv/gettext/.*(po)$",
      ~r"lib/snippetbox_web/(controllers|live|components)/.*(ex|heex)$"
    ]
  ]

# More detailed logging in development
config :logger, :console, format: "[$level] $message\n"

# Disable Swoosh (email) in dev, use local adapter
config :snippetbox, Snippetbox.Mailer, adapter: Swoosh.Adapters.Local

# Phoenix dev tools
config :phoenix, :plug_init_mode, :runtime
config :phoenix_live_view, :debug_heex_annotations, true
```

Development settings include:
- Local database connection
- Debug error pages
- Code reloading
- Live reload on file changes
- Verbose logging

## Test Configuration (test.exs)

Optimized for running tests quickly:

```elixir
# File: config/test.exs

import Config

# Test database configuration
config :snippetbox, Snippetbox.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "snippetbox_test#{System.get_env("MIX_TEST_PARTITION")}",
  pool: Ecto.Adapters.SQL.Sandbox,
  pool_size: System.schedulers_online() * 2

# Minimal endpoint config for tests
config :snippetbox, SnippetboxWeb.Endpoint,
  http: [ip: {127, 0, 0, 1}, port: 4002],
  secret_key_base: "test-secret-key-at-least-64-bytes-long-for-testing-purposes-only!",
  server: false

# Reduce logging noise in tests
config :logger, level: :warning

# Speed up password hashing in tests
config :bcrypt_elixir, :log_rounds, 1

# Disable email sending in tests
config :snippetbox, Snippetbox.Mailer, adapter: Swoosh.Adapters.Test
```

Test settings include:
- Separate test database (with partition support)
- Sandbox pool for isolated tests
- Server disabled (tests use conn directly)
- Minimal logging
- Fast bcrypt for quick tests

## Production Configuration (prod.exs)

Secure defaults for production:

```elixir
# File: config/prod.exs

import Config

# Production endpoint
config :snippetbox, SnippetboxWeb.Endpoint,
  cache_static_manifest: "priv/static/cache_manifest.json",
  force_ssl: [rewrite_on: [:x_forwarded_proto]]

# Production logging
config :logger, level: :info

# Production mailer (configured at runtime)
config :snippetbox, Snippetbox.Mailer, adapter: Swoosh.Adapters.SMTP
```

Note: `prod.exs` contains minimal configuration. Sensitive values like database URLs and secret keys are in `runtime.exs`.

## Runtime Configuration (runtime.exs)

For configuration that needs environment variables:

```elixir
# File: config/runtime.exs

import Config

# Only configure in production
if config_env() == :prod do
  # Database configuration from DATABASE_URL
  database_url =
    System.get_env("DATABASE_URL") ||
      raise """
      environment variable DATABASE_URL is missing.
      For example: ecto://USER:PASS@HOST/DATABASE
      """

  config :snippetbox, Snippetbox.Repo,
    url: database_url,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),
    ssl: true,
    ssl_opts: [verify: :verify_none]

  # Secret key base for sessions/tokens
  secret_key_base =
    System.get_env("SECRET_KEY_BASE") ||
      raise """
      environment variable SECRET_KEY_BASE is missing.
      You can generate one by calling: mix phx.gen.secret
      """

  # Host configuration
  host = System.get_env("PHX_HOST") || "example.com"
  port = String.to_integer(System.get_env("PORT") || "4000")

  config :snippetbox, SnippetboxWeb.Endpoint,
    url: [host: host, port: 443, scheme: "https"],
    http: [
      ip: {0, 0, 0, 0, 0, 0, 0, 0},
      port: port
    ],
    secret_key_base: secret_key_base

  # Optional: Configure email
  if smtp_host = System.get_env("SMTP_HOST") do
    config :snippetbox, Snippetbox.Mailer,
      adapter: Swoosh.Adapters.SMTP,
      relay: smtp_host,
      username: System.get_env("SMTP_USERNAME"),
      password: System.get_env("SMTP_PASSWORD"),
      port: String.to_integer(System.get_env("SMTP_PORT") || "587")
  end
end
```

Key patterns:
- Check `config_env()` to apply only in specific environments
- Use `System.get_env/1` for environment variables
- Raise helpful errors for required variables
- Provide sensible defaults with `||`

## Accessing Configuration

### At Runtime

```elixir
# Get application config
Application.get_env(:snippetbox, :some_key)
Application.get_env(:snippetbox, :some_key, "default")

# Get module config
Application.get_env(:snippetbox, Snippetbox.Repo)
# Returns: [username: "postgres", password: "postgres", ...]

# Get specific key from module config
Application.get_env(:snippetbox, Snippetbox.Repo)[:pool_size]

# Fetch (raises if missing)
Application.fetch_env!(:snippetbox, :required_key)
```

### In Modules

```elixir
defmodule Snippetbox.SomeModule do
  # At compile time (for module attributes)
  @api_url Application.compile_env(:snippetbox, :api_url)

  # At runtime (recommended)
  def api_url do
    Application.get_env(:snippetbox, :api_url)
  end
end
```

### Compile-time vs Runtime

```elixir
# Compile-time: Value is baked in at compile
@value Application.compile_env(:app, :key)

# Runtime: Value is read when function is called
def value do
  Application.get_env(:app, :key)
end
```

Use runtime for values that might change; compile-time for optimization.

## Custom Configuration

Add your own configuration:

```elixir
# File: config/config.exs

# Application settings
config :snippetbox,
  snippet_expiry_days: 7,
  max_snippet_size: 100_000,
  allowed_languages: ~w(elixir ruby python javascript go rust)

# Feature flags
config :snippetbox, :features,
  syntax_highlighting: true,
  user_registration: true,
  api_enabled: false
```

Access in your code:

```elixir
defmodule Snippetbox.Snippets do
  def max_size do
    Application.get_env(:snippetbox, :max_snippet_size, 50_000)
  end

  def expiry_days do
    Application.get_env(:snippetbox, :snippet_expiry_days, 7)
  end

  def feature_enabled?(feature) do
    features = Application.get_env(:snippetbox, :features, %{})
    Map.get(features, feature, false)
  end
end
```

## Configuration for Libraries

Configure third-party libraries:

```elixir
# File: config/config.exs

# Timezone database
config :elixir, :time_zone_database, Tzdata.TimeZoneDatabase

# JSON library
config :phoenix, :json_library, Jason

# Ecto timestamps
config :snippetbox, Snippetbox.Repo,
  migration_timestamps: [type: :utc_datetime]

# HTTP client
config :snippetbox, :http_client,
  adapter: Finch,
  pool_size: 25,
  timeout: 30_000
```

## Environment-Specific Overrides

Override per environment:

```elixir
# File: config/config.exs
config :snippetbox, :features,
  syntax_highlighting: true,
  experimental_feature: false

# File: config/dev.exs
config :snippetbox, :features,
  experimental_feature: true  # Enable in dev only
```

The dev.exs value overrides the config.exs value.

## Validating Configuration

Create a module to validate configuration at startup:

```elixir
# File: lib/snippetbox/config.ex

defmodule Snippetbox.Config do
  @moduledoc """
  Application configuration with validation.
  """

  def snippet_expiry_days do
    get_env!(:snippet_expiry_days)
  end

  def max_snippet_size do
    get_env!(:max_snippet_size)
  end

  def validate! do
    # Validate required config exists
    _ = snippet_expiry_days()
    _ = max_snippet_size()

    # Validate values are sensible
    if snippet_expiry_days() < 1 do
      raise "snippet_expiry_days must be at least 1"
    end

    if max_snippet_size() < 1000 do
      raise "max_snippet_size must be at least 1000 bytes"
    end

    :ok
  end

  defp get_env!(key) do
    Application.get_env(:snippetbox, key) ||
      raise "Missing configuration: config :snippetbox, #{inspect(key)}"
  end
end
```

Call from application startup:

```elixir
# File: lib/snippetbox/application.ex

def start(_type, _args) do
  # Validate configuration before starting
  Snippetbox.Config.validate!()

  children = [
    # ...
  ]

  opts = [strategy: :one_for_one, name: Snippetbox.Supervisor]
  Supervisor.start_link(children, opts)
end
```

> **FP Concept: Configuration as Data**
>
> In Elixir, configuration is just data - maps and keyword lists:
>
> ```elixir
> config :snippetbox, Snippetbox.Repo,
>   username: "postgres",
>   pool_size: 10
>
> # This creates:
> # %{Snippetbox.Repo => [username: "postgres", pool_size: 10]}
> ```
>
> Benefits:
> - **Inspectable**: Print config with `IO.inspect/1`
> - **Transformable**: Use `Keyword` and `Map` functions
> - **Testable**: Override config in tests easily
> - **No Magic**: What you see is what you get
>
> **Further Reading**:
> - [Elixir Config](https://hexdocs.pm/elixir/Config.html)
> - [Phoenix Configuration Guide](https://hexdocs.pm/phoenix/deployment.html)

## Summary

In this chapter, we learned:

- Phoenix's configuration file structure
- Environment-specific configuration (dev, test, prod)
- Runtime configuration with environment variables
- Accessing configuration in code
- Creating custom configuration
- Validating configuration at startup

In the next chapter, we'll explore how to work with environment variables and secrets.

---

## Additional Information

### Generate Secret Key Base

```bash
$ mix phx.gen.secret
# Outputs a random 64-byte secret key
```

### Configuration in Releases

For releases, configuration is evaluated at release build time except for `runtime.exs`. To change config after building:

```elixir
# Use runtime.exs for all environment-dependent config
# Or use releases config providers
```

### Comparing to Other Frameworks

**Rails (YAML-based)**:
```yaml
# config/database.yml
development:
  adapter: postgresql
  database: app_dev
```

**Django (Python)**:
```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
    }
}
```

**Laravel (PHP)**:
```php
// config/database.php
return [
    'default' => env('DB_CONNECTION', 'mysql'),
];
```

**Phoenix (Elixir)**:
```elixir
# config/dev.exs
config :snippetbox, Snippetbox.Repo,
  database: "snippetbox_dev"
```

Phoenix's approach is more explicit and type-safe, with clear compile-time vs runtime distinction.
