# Chapter 13.4: LiveView Testing

LiveView provides built-in testing utilities for testing real-time components. In this chapter, we'll explore LiveView-specific testing patterns.

## LiveView Test Setup

```elixir
# File: test/support/conn_case.ex

defmodule SnippetboxWeb.ConnCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      @endpoint SnippetboxWeb.Endpoint

      use SnippetboxWeb, :verified_routes

      import Plug.Conn
      import Phoenix.ConnTest
      import Phoenix.LiveViewTest
      import SnippetboxWeb.ConnCase
    end
  end

  # ... rest of setup
end
```

## Basic LiveView Tests

```elixir
# File: test/snippetbox_web/live/counter_live_test.exs

defmodule SnippetboxWeb.CounterLiveTest do
  use SnippetboxWeb.ConnCase

  import Phoenix.LiveViewTest

  describe "counter" do
    test "renders initial count", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/counter")

      assert html =~ "0"
    end

    test "increments count", %{conn: conn} do
      {:ok, view, _html} = live(conn, ~p"/counter")

      assert view
             |> element("button", "+")
             |> render_click() =~ "1"
    end

    test "decrements count", %{conn: conn} do
      {:ok, view, _html} = live(conn, ~p"/counter")

      # First increment to 1
      view |> element("button", "+") |> render_click()

      # Then decrement
      assert view
             |> element("button", "-")
             |> render_click() =~ "0"
    end
  end
end
```

## Testing LiveView Events

### Click Events

```elixir
describe "click events" do
  test "handles button click", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets")

    # Click by selector
    view |> element("#delete-btn") |> render_click()

    # Click with phx-value
    view
    |> element("button[phx-click=delete]", "Delete")
    |> render_click(%{"id" => "123"})

    # Direct event push
    view |> render_click("delete", %{"id" => "123"})
  end
end
```

### Form Events

```elixir
describe "form events" do
  setup [:register_and_log_in_user]

  test "validates form on change", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets/new")

    assert view
           |> form("#snippet-form", snippet: %{title: ""})
           |> render_change() =~ "can&#39;t be blank"
  end

  test "submits form", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets/new")

    {:ok, conn} =
      view
      |> form("#snippet-form", snippet: %{title: "Test", content: "code", language: "elixir"})
      |> render_submit()
      |> follow_redirect(conn)

    assert html_response(conn, 200) =~ "Test"
  end

  test "shows validation error on submit", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets/new")

    assert view
           |> form("#snippet-form", snippet: %{title: ""})
           |> render_submit() =~ "can&#39;t be blank"
  end
end
```

### Key Events

```elixir
describe "key events" do
  test "handles escape key", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets")

    # Open modal
    view |> element("button", "New") |> render_click()
    assert has_element?(view, "#modal")

    # Press escape
    view |> render_keydown(%{"key" => "Escape"})
    refute has_element?(view, "#modal")
  end

  test "handles enter key in search", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets")

    view
    |> element("#search-input")
    |> render_keyup(%{"key" => "Enter", "value" => "elixir"})

    assert has_element?(view, "#search-results")
  end
end
```

## Testing LiveView Navigation

```elixir
describe "navigation" do
  test "patches to edit route", %{conn: conn, user: user} do
    snippet = snippet_fixture(%{user_id: user.id})
    {:ok, view, _html} = live(conn, ~p"/snippets")

    view
    |> element("a", "Edit")
    |> render_click()

    assert_patch(view, ~p"/snippets/#{snippet}/edit")
  end

  test "navigates to show page", %{conn: conn} do
    snippet = snippet_fixture()
    {:ok, view, _html} = live(conn, ~p"/snippets")

    {:ok, conn} =
      view
      |> element("a", snippet.title)
      |> render_click()
      |> follow_redirect(conn, ~p"/snippets/#{snippet}")

    assert html_response(conn, 200) =~ snippet.title
  end

  test "handles params change", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets?page=1")

    view
    |> element("a", "Next")
    |> render_click()

    assert_patch(view, ~p"/snippets?page=2")
  end
end
```

## Testing Streams

```elixir
describe "streams" do
  test "stream inserts new item", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets")

    # Create snippet which broadcasts to PubSub
    snippet = snippet_fixture(%{title: "New Snippet"})

    # Simulate broadcast
    send(view.pid, {:snippet_created, snippet})

    assert has_element?(view, "#snippets-#{snippet.id}")
    assert render(view) =~ "New Snippet"
  end

  test "stream deletes item", %{conn: conn, user: user} do
    snippet = snippet_fixture(%{user_id: user.id})
    {:ok, view, _html} = live(conn, ~p"/snippets")

    assert has_element?(view, "#snippets-#{snippet.id}")

    view
    |> element("#snippets-#{snippet.id} button", "Delete")
    |> render_click()

    refute has_element?(view, "#snippets-#{snippet.id}")
  end
end
```

## Testing Live Components

```elixir
# File: test/snippetbox_web/live/components/snippet_form_component_test.exs

defmodule SnippetboxWeb.SnippetLive.FormComponentTest do
  use SnippetboxWeb.ConnCase

  import Phoenix.LiveViewTest
  import Snippetbox.SnippetsFixtures

  describe "new snippet" do
    setup [:register_and_log_in_user]

    test "renders form", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/snippets/new")

      assert html =~ "New Snippet"
      assert has_element?(view, "form#snippet-form")
    end

    test "saves new snippet", %{conn: conn} do
      {:ok, view, _html} = live(conn, ~p"/snippets/new")

      {:ok, conn} =
        view
        |> form("#snippet-form", snippet: %{
          title: "Test Snippet",
          content: "code",
          language: "elixir"
        })
        |> render_submit()
        |> follow_redirect(conn)

      assert html_response(conn, 200) =~ "Snippet created"
    end
  end

  describe "edit snippet" do
    setup [:register_and_log_in_user]

    test "updates snippet", %{conn: conn, user: user} do
      snippet = snippet_fixture(%{user_id: user.id})
      {:ok, view, _html} = live(conn, ~p"/snippets/#{snippet}/edit")

      {:ok, conn} =
        view
        |> form("#snippet-form", snippet: %{title: "Updated"})
        |> render_submit()
        |> follow_redirect(conn)

      assert html_response(conn, 200) =~ "Updated"
    end
  end
end
```

## Testing PubSub Updates

```elixir
describe "real-time updates" do
  test "receives snippet created broadcast", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets")

    # Simulate another process creating a snippet
    snippet = snippet_fixture(%{title: "From Another User"})
    Phoenix.PubSub.broadcast(
      Snippetbox.PubSub,
      "snippets",
      {:snippet_created, snippet}
    )

    # Give time for message to arrive
    assert render(view) =~ "From Another User"
  end

  test "receives snippet updated broadcast", %{conn: conn} do
    snippet = snippet_fixture(%{title: "Original"})
    {:ok, view, _html} = live(conn, ~p"/snippets")

    updated_snippet = %{snippet | title: "Updated Title"}
    Phoenix.PubSub.broadcast(
      Snippetbox.PubSub,
      "snippets",
      {:snippet_updated, updated_snippet}
    )

    assert render(view) =~ "Updated Title"
    refute render(view) =~ "Original"
  end
end
```

## Testing Presence

```elixir
describe "presence" do
  test "shows online users", %{conn: conn, user: user} do
    {:ok, view, _html} = live(conn, ~p"/snippets/123")

    assert render(view) =~ "1 viewing"
    assert has_element?(view, "[data-user-id='#{user.id}']")
  end

  test "updates when user joins", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets/123")

    # Simulate another user joining
    other_user = user_fixture()
    Phoenix.PubSub.broadcast(
      Snippetbox.PubSub,
      "snippet:123",
      %Phoenix.Socket.Broadcast{
        event: "presence_diff",
        payload: %{
          joins: %{other_user.id => %{metas: [%{name: other_user.name}]}},
          leaves: %{}
        }
      }
    )

    assert render(view) =~ "2 viewing"
  end
end
```

## Testing File Uploads

```elixir
describe "file uploads" do
  setup [:register_and_log_in_user]

  test "renders upload form", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets/import")

    assert has_element?(view, "input[type=file]")
  end

  test "validates file type", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets/import")

    file_input = file_input(view, "#upload-form", :file, [
      %{
        last_modified: 1_594_171_879_000,
        name: "image.png",
        content: "...",
        type: "image/png"
      }
    ])

    assert render_upload(file_input, "image.png") =~ "not accepted"
  end

  test "uploads file successfully", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/snippets/import")

    file_input = file_input(view, "#upload-form", :file, [
      %{
        last_modified: 1_594_171_879_000,
        name: "snippet.ex",
        content: "defmodule Test do\nend",
        type: "text/plain"
      }
    ])

    render_upload(file_input, "snippet.ex")

    assert view
           |> form("#upload-form")
           |> render_submit() =~ "imported"
  end
end
```

## Testing Async Operations

```elixir
describe "async operations" do
  test "shows loading state", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/export")

    view |> element("button", "Start Export") |> render_click()

    assert has_element?(view, ".loading-spinner")
  end

  test "shows progress updates", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/export")

    view |> element("button", "Start Export") |> render_click()

    # Simulate progress update
    send(view.pid, {:export_progress, 50})

    assert render(view) =~ "50%"
  end

  test "shows completion", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/export")

    view |> element("button", "Start Export") |> render_click()

    send(view.pid, {:export_complete, "/downloads/export.zip"})

    assert has_element?(view, "a[href='/downloads/export.zip']")
    assert render(view) =~ "Download"
  end
end
```

## Testing Hooks

```elixir
describe "JavaScript hooks" do
  test "initializes hook on mount", %{conn: conn} do
    {:ok, view, html} = live(conn, ~p"/editor")

    # Hook elements should have phx-hook attribute
    assert html =~ "phx-hook=\"CodeEditor\""
  end

  test "handles hook events", %{conn: conn} do
    {:ok, view, _html} = live(conn, ~p"/editor")

    # Push event from JavaScript
    view
    |> render_hook("cursor_moved", %{"line" => 10, "column" => 5})

    assert render(view) =~ "Line: 10, Col: 5"
  end
end
```

## Assertions

```elixir
# Element presence
assert has_element?(view, "#my-element")
refute has_element?(view, ".hidden-element")

# Text content
assert render(view) =~ "Expected text"

# Specific element
assert element(view, "h1") |> render() =~ "Title"

# Navigation
assert_redirect(view, "/path")
assert_patch(view, "/path")

# Events
assert_push_event(view, "event_name", %{})
```

> **FP Concept: Process-Based Testing**
>
> LiveView tests interact with actual Elixir processes:
>
> ```elixir
> # view.pid is the LiveView process
> {:ok, view, html} = live(conn, "/path")
>
> # Events are sent to the process
> view |> render_click("event")
>
> # Messages can be sent directly
> send(view.pid, {:custom_message, data})
>
> # State changes are observed through re-renders
> assert render(view) =~ "Updated content"
> ```
>
> This tests real process behavior, not mocks.

## Summary

In this chapter, we learned:

- LiveView test setup
- Testing click, form, and key events
- Testing navigation and params
- Testing streams
- Testing live components
- Testing PubSub and presence
- Testing file uploads
- Testing async operations

In the next chapter, we'll explore database testing.
