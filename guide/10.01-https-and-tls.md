# Chapter 10.1: HTTPS and TLS

HTTPS encrypts communication between browsers and servers. In this chapter, we'll explore how to configure HTTPS in Phoenix.

## Why HTTPS?

HTTPS provides:

- **Encryption**: Data can't be read in transit
- **Integrity**: Data can't be modified in transit
- **Authentication**: Proves server identity
- **SEO Benefits**: Google ranks HTTPS sites higher
- **Required for Features**: HTTP/2, service workers, many APIs

## Development HTTPS

### Generating Self-Signed Certificates

```bash
# Create certificates directory
mkdir -p priv/cert

# Generate self-signed certificate
openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 \
  -subj "/C=US/ST=State/L=City/O=Dev/CN=localhost" \
  -keyout priv/cert/selfsigned_key.pem \
  -out priv/cert/selfsigned.pem
```

### Development Configuration

```elixir
# File: config/dev.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  https: [
    port: 4001,
    cipher_suite: :strong,
    keyfile: "priv/cert/selfsigned_key.pem",
    certfile: "priv/cert/selfsigned.pem"
  ],
  http: [port: 4000]
```

### Using Phoenix Built-in Certificate

Phoenix can generate certificates automatically:

```elixir
# File: config/dev.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  https: [
    port: 4001,
    cipher_suite: :strong,
    certfile: "priv/cert/selfsigned.pem",
    keyfile: "priv/cert/selfsigned_key.pem"
  ]

# Or use Phoenix.Endpoint.Cowboy2Adapter to auto-generate
```

## Production HTTPS

### Option 1: Reverse Proxy (Recommended)

Let nginx/Caddy handle TLS:

```
[Browser] --HTTPS--> [Nginx/Caddy] --HTTP--> [Phoenix]
```

#### Nginx Configuration

```nginx
# /etc/nginx/sites-available/snippetbox

upstream phoenix {
    server 127.0.0.1:4000;
}

server {
    listen 80;
    server_name snippetbox.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name snippetbox.com;

    ssl_certificate /etc/letsencrypt/live/snippetbox.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/snippetbox.com/privkey.pem;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    ssl_prefer_server_ciphers off;

    # Security headers
    add_header Strict-Transport-Security "max-age=63072000" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;

    location / {
        proxy_pass http://phoenix;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    end
}
```

#### Phoenix Behind Proxy

```elixir
# File: config/prod.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  url: [host: "snippetbox.com", port: 443, scheme: "https"],
  http: [
    port: 4000,
    transport_options: [socket_opts: [:inet6]]
  ],
  force_ssl: [rewrite_on: [:x_forwarded_proto]]
```

### Option 2: Direct TLS Termination

Phoenix handles TLS directly:

```elixir
# File: config/prod.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  url: [host: "snippetbox.com", port: 443],
  https: [
    port: 443,
    cipher_suite: :strong,
    certfile: System.get_env("SSL_CERT_PATH"),
    keyfile: System.get_env("SSL_KEY_PATH"),
    # For Let's Encrypt
    cacertfile: System.get_env("SSL_CACERT_PATH")
  ]
```

### Let's Encrypt with Certbot

```bash
# Install certbot
sudo apt install certbot

# Get certificate (standalone mode)
sudo certbot certonly --standalone -d snippetbox.com

# Auto-renewal
sudo certbot renew --dry-run
```

## Force HTTPS

### Using force_ssl

```elixir
# File: config/prod.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  force_ssl: [
    hsts: true,
    rewrite_on: [:x_forwarded_proto],
    host: nil  # Use request host
  ]
```

### Custom HTTPS Redirect Plug

```elixir
# File: lib/snippetbox_web/plugs/force_ssl.ex

defmodule SnippetboxWeb.Plugs.ForceSSL do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    if secure?(conn) do
      conn
    else
      conn
      |> put_resp_header("location", redirect_url(conn))
      |> send_resp(301, "")
      |> halt()
    end
  end

  defp secure?(conn) do
    conn.scheme == :https ||
      get_req_header(conn, "x-forwarded-proto") == ["https"]
  end

  defp redirect_url(conn) do
    "https://#{conn.host}#{conn.request_path}"
  end
end
```

## HSTS (HTTP Strict Transport Security)

HSTS tells browsers to always use HTTPS:

```elixir
# Enabled by default with force_ssl
config :snippetbox, SnippetboxWeb.Endpoint,
  force_ssl: [hsts: true]

# Custom HSTS configuration
force_ssl: [
  hsts: true,
  expires: 63_072_000,  # 2 years
  subdomains: true,
  preload: true
]
```

### HSTS Header

```
Strict-Transport-Security: max-age=63072000; includeSubDomains; preload
```

## TLS Configuration

### Cipher Suites

```elixir
# File: config/prod.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  https: [
    port: 443,
    cipher_suite: :strong,  # Phoenix default strong ciphers
    # Or custom ciphers:
    ciphers: [
      'ECDHE-ECDSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-ECDSA-AES128-GCM-SHA256',
      'ECDHE-RSA-AES128-GCM-SHA256'
    ],
    versions: [:"tlsv1.2", :"tlsv1.3"],
    honor_cipher_order: true
  ]
```

### Cipher Suite Options

| Option | Description |
|--------|-------------|
| `:strong` | Modern browsers, TLS 1.2+ |
| `:compatible` | Older browsers, TLS 1.0+ |
| Custom list | Fine-grained control |

## Certificate Management

### Certificate Renewal

```elixir
# File: lib/snippetbox/cert_watcher.ex

defmodule Snippetbox.CertWatcher do
  use GenServer
  require Logger

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def init(state) do
    schedule_check()
    {:ok, state}
  end

  def handle_info(:check_certs, state) do
    check_certificate_expiry()
    schedule_check()
    {:noreply, state}
  end

  defp schedule_check do
    # Check daily
    Process.send_after(self(), :check_certs, 24 * 60 * 60 * 1000)
  end

  defp check_certificate_expiry do
    cert_path = System.get_env("SSL_CERT_PATH")

    case File.read(cert_path) do
      {:ok, pem} ->
        [cert_entry | _] = :public_key.pem_decode(pem)
        cert = :public_key.pem_entry_decode(cert_entry)
        validity = elem(cert, 2)
        not_after = elem(validity, 2)

        days_until_expiry = calculate_days(not_after)

        if days_until_expiry < 30 do
          Logger.warning("SSL certificate expires in #{days_until_expiry} days!")
          # Send alert notification
        end

      {:error, reason} ->
        Logger.error("Could not read certificate: #{reason}")
    end
  end

  defp calculate_days(_not_after) do
    # Calculate days until expiry
    30  # Simplified
  end
end
```

## Mixed Content

Ensure all resources use HTTPS:

```heex
<%# Bad - mixed content %>
<script src="http://example.com/script.js"></script>

<%# Good - protocol-relative (deprecated) %>
<script src="//example.com/script.js"></script>

<%# Best - explicit HTTPS %>
<script src="https://example.com/script.js"></script>

<%# Or use local assets %>
<script src={~p"/assets/app.js"}></script>
```

### Content Security Policy

```elixir
# Enforce HTTPS for all resources
plug :put_secure_browser_headers, %{
  "content-security-policy" => "upgrade-insecure-requests"
}
```

## Testing HTTPS

### SSL Labs Test

Test your TLS configuration at:
https://www.ssllabs.com/ssltest/

### Local Testing

```bash
# Test TLS connection
openssl s_client -connect localhost:4001

# Check certificate
openssl x509 -in priv/cert/selfsigned.pem -text -noout
```

> **FP Concept: Security as Configuration**
>
> Phoenix treats security as declarative configuration:
>
> ```elixir
> config :snippetbox, SnippetboxWeb.Endpoint,
>   force_ssl: [hsts: true],
>   https: [cipher_suite: :strong]
> ```
>
> Rather than imperative security code scattered throughout, security is centralized in configuration, making it easier to audit and maintain.

## Summary

In this chapter, we learned:

- Why HTTPS is essential
- Development HTTPS setup
- Production HTTPS options
- Reverse proxy configuration
- Force HTTPS with redirects
- HSTS configuration
- TLS cipher suite selection
- Certificate management

In the next chapter, we'll explore CSRF protection.
