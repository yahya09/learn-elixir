# Chapter 11.2: User Registration

User registration is the entry point to your application. In this chapter, we'll implement a complete registration flow.

## Registration Controller

```elixir
# File: lib/snippetbox_web/controllers/user_registration_controller.ex

defmodule SnippetboxWeb.UserRegistrationController do
  use SnippetboxWeb, :controller

  alias Snippetbox.Accounts
  alias Snippetbox.Accounts.User

  def new(conn, _params) do
    changeset = Accounts.change_user_registration(%User{})
    render(conn, :new, changeset: changeset)
  end

  def create(conn, %{"user" => user_params}) do
    case Accounts.register_user(user_params) do
      {:ok, user} ->
        conn
        |> put_flash(:info, "Account created successfully!")
        |> SnippetboxWeb.UserAuth.log_in_user(user)

      {:error, %Ecto.Changeset{} = changeset} ->
        render(conn, :new, changeset: changeset)
    end
  end
end
```

## Registration Template

```heex
<%# File: lib/snippetbox_web/controllers/user_registration_html/new.html.heex %>

<div class="mx-auto max-w-md">
  <.header class="text-center">
    Create Account
    <:subtitle>
      Already have an account?
      <.link navigate={~p"/login"} class="font-semibold text-brand hover:underline">
        Log in
      </.link>
    </:subtitle>
  </.header>

  <.form for={@changeset} action={~p"/register"} class="mt-8">
    <.error :if={@changeset.action}>
      Oops, something went wrong! Please check the errors below.
    </.error>

    <div class="space-y-4">
      <.input field={@form[:name]} type="text" label="Name" required />
      <.input field={@form[:email]} type="email" label="Email" required />
      <.input field={@form[:password]} type="password" label="Password" required />
      <.input
        field={@form[:password_confirmation]}
        type="password"
        label="Confirm Password"
        required
      />
    </div>

    <div class="mt-6">
      <.button class="w-full">Create Account</.button>
    </div>
  </.form>
</div>
```

## Context Functions

```elixir
# File: lib/snippetbox/accounts.ex

defmodule Snippetbox.Accounts do
  alias Snippetbox.Repo
  alias Snippetbox.Accounts.User

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking user changes.
  """
  def change_user_registration(%User{} = user, attrs \\ %{}) do
    User.registration_changeset(user, attrs, hash_password: false)
  end

  @doc """
  Registers a new user.

  ## Examples

      iex> register_user(%{email: "user@example.com", password: "password123"})
      {:ok, %User{}}

      iex> register_user(%{email: "bad"})
      {:error, %Ecto.Changeset{}}
  """
  def register_user(attrs) do
    %User{}
    |> User.registration_changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Gets a user by email.
  """
  def get_user_by_email(email) when is_binary(email) do
    Repo.get_by(User, email: email)
  end

  @doc """
  Gets a user by ID.
  """
  def get_user!(id) do
    Repo.get!(User, id)
  end
end
```

## Enhanced User Schema

```elixir
# File: lib/snippetbox/accounts/user.ex

defmodule Snippetbox.Accounts.User do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :email, :string
    field :name, :string
    field :password, :string, virtual: true, redact: true
    field :password_confirmation, :string, virtual: true, redact: true
    field :hashed_password, :string, redact: true

    timestamps()
  end

  def registration_changeset(user, attrs, opts \\ []) do
    user
    |> cast(attrs, [:email, :name, :password, :password_confirmation])
    |> validate_required([:email, :name, :password])
    |> validate_email()
    |> validate_name()
    |> validate_password(opts)
    |> validate_password_confirmation()
  end

  defp validate_email(changeset) do
    changeset
    |> validate_format(:email, ~r/^[^\s]+@[^\s]+\.[^\s]+$/,
         message: "must be a valid email address")
    |> validate_length(:email, max: 160)
    |> unsafe_validate_unique(:email, Snippetbox.Repo)
    |> unique_constraint(:email)
    |> update_change(:email, &String.downcase/1)
  end

  defp validate_name(changeset) do
    changeset
    |> validate_length(:name, min: 2, max: 100)
    |> validate_format(:name, ~r/^[a-zA-Z\s]+$/,
         message: "can only contain letters and spaces")
  end

  defp validate_password(changeset, opts) do
    changeset
    |> validate_required([:password])
    |> validate_length(:password, min: 12, max: 72)
    |> validate_password_strength()
    |> maybe_hash_password(opts)
  end

  defp validate_password_strength(changeset) do
    validate_change(changeset, :password, fn :password, password ->
      errors = []

      errors =
        if String.match?(password, ~r/[a-z]/),
          do: errors,
          else: [{:password, "must contain a lowercase letter"} | errors]

      errors =
        if String.match?(password, ~r/[A-Z]/),
          do: errors,
          else: [{:password, "must contain an uppercase letter"} | errors]

      errors =
        if String.match?(password, ~r/[0-9]/),
          do: errors,
          else: [{:password, "must contain a number"} | errors]

      errors
    end)
  end

  defp validate_password_confirmation(changeset) do
    password = get_change(changeset, :password)
    confirmation = get_change(changeset, :password_confirmation)

    if password && confirmation && password != confirmation do
      add_error(changeset, :password_confirmation, "does not match password")
    else
      changeset
    end
  end

  defp maybe_hash_password(changeset, opts) do
    hash_password? = Keyword.get(opts, :hash_password, true)
    password = get_change(changeset, :password)

    if hash_password? && password && changeset.valid? do
      changeset
      |> put_change(:hashed_password, Argon2.hash_pwd_salt(password))
      |> delete_change(:password)
      |> delete_change(:password_confirmation)
    else
      changeset
    end
  end
end
```

## Router Setup

```elixir
# File: lib/snippetbox_web/router.ex

scope "/", SnippetboxWeb do
  pipe_through [:browser, :redirect_if_user_is_authenticated]

  get "/register", UserRegistrationController, :new
  post "/register", UserRegistrationController, :create
end
```

## Redirect If Authenticated

```elixir
# File: lib/snippetbox_web/user_auth.ex

defmodule SnippetboxWeb.UserAuth do
  import Plug.Conn
  import Phoenix.Controller

  alias Snippetbox.Accounts

  @doc """
  Redirects authenticated users away from registration/login pages.
  """
  def redirect_if_user_is_authenticated(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
      |> redirect(to: signed_in_path(conn))
      |> halt()
    else
      conn
    end
  end

  defp signed_in_path(_conn), do: ~p"/"
end
```

## Registration With Email Confirmation

For applications requiring email verification:

```elixir
def create(conn, %{"user" => user_params}) do
  case Accounts.register_user(user_params) do
    {:ok, user} ->
      {:ok, _} =
        Accounts.deliver_user_confirmation_instructions(
          user,
          &url(~p"/confirm/#{&1}")
        )

      conn
      |> put_flash(:info, "Account created! Please check your email to confirm.")
      |> redirect(to: ~p"/login")

    {:error, %Ecto.Changeset{} = changeset} ->
      render(conn, :new, changeset: changeset)
  end
end
```

## Terms of Service

```heex
<div class="mt-4">
  <label class="flex items-start gap-2">
    <input
      type="checkbox"
      name={@form[:terms_accepted].name}
      value="true"
      required
      class="mt-1"
    />
    <span class="text-sm text-gray-600">
      I agree to the
      <.link href={~p"/terms"} target="_blank" class="text-brand hover:underline">
        Terms of Service
      </.link>
      and
      <.link href={~p"/privacy"} target="_blank" class="text-brand hover:underline">
        Privacy Policy
      </.link>
    </span>
  </label>
</div>
```

```elixir
# In changeset
def registration_changeset(user, attrs, opts \\ []) do
  user
  |> cast(attrs, [:email, :name, :password, :terms_accepted])
  |> validate_acceptance(:terms_accepted, message: "you must accept the terms")
  # ... other validations
end
```

## Rate Limiting Registration

```elixir
# File: lib/snippetbox_web/plugs/rate_limit.ex

defmodule SnippetboxWeb.Plugs.RateLimit do
  import Plug.Conn
  import Phoenix.Controller

  def rate_limit_registration(conn, _opts) do
    ip = to_string(:inet.ntoa(conn.remote_ip))
    key = "registration:#{ip}"

    case Hammer.check_rate(key, 3600_000, 5) do  # 5 per hour
      {:allow, _count} ->
        conn

      {:deny, _limit} ->
        conn
        |> put_flash(:error, "Too many registration attempts. Please try again later.")
        |> redirect(to: ~p"/register")
        |> halt()
    end
  end
end
```

## Testing Registration

```elixir
# File: test/snippetbox_web/controllers/user_registration_controller_test.exs

defmodule SnippetboxWeb.UserRegistrationControllerTest do
  use SnippetboxWeb.ConnCase

  describe "GET /register" do
    test "renders registration page", %{conn: conn} do
      conn = get(conn, ~p"/register")
      html = html_response(conn, 200)

      assert html =~ "Create Account"
      assert html =~ "Email"
      assert html =~ "Password"
    end

    test "redirects if already logged in", %{conn: conn} do
      conn = conn |> log_in_user(user_fixture()) |> get(~p"/register")
      assert redirected_to(conn) == ~p"/"
    end
  end

  describe "POST /register" do
    test "creates account and logs in", %{conn: conn} do
      email = unique_user_email()

      conn =
        post(conn, ~p"/register", %{
          "user" => %{
            "name" => "Test User",
            "email" => email,
            "password" => "ValidPass123!",
            "password_confirmation" => "ValidPass123!"
          }
        })

      assert get_session(conn, :user_token)
      assert redirected_to(conn) == ~p"/"

      # Verify user created
      assert Snippetbox.Accounts.get_user_by_email(email)
    end

    test "renders errors for invalid data", %{conn: conn} do
      conn =
        post(conn, ~p"/register", %{
          "user" => %{
            "email" => "invalid",
            "password" => "short"
          }
        })

      html = html_response(conn, 200)
      assert html =~ "must be a valid email"
      assert html =~ "should be at least 12 character"
    end

    test "renders errors for duplicate email", %{conn: conn} do
      user = user_fixture()

      conn =
        post(conn, ~p"/register", %{
          "user" => valid_user_attributes(email: user.email)
        })

      html = html_response(conn, 200)
      assert html =~ "has already been taken"
    end
  end
end
```

> **FP Concept: Validation Pipeline**
>
> Registration follows a validation pipeline:
>
> ```elixir
> attrs
> |> cast_fields()
> |> validate_email()
> |> validate_password()
> |> hash_password()
> |> insert_user()
> ```
>
> Each step transforms the changeset, accumulating errors. The pipeline either succeeds completely or returns all validation errors.

## Summary

In this chapter, we learned:

- Creating registration controller and templates
- User schema with password confirmation
- Email validation and normalization
- Terms of service acceptance
- Rate limiting registration
- Redirecting authenticated users
- Testing registration flow

In the next chapter, we'll implement login and logout.
