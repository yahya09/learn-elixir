# Chapter 12.2: LiveView Forms

LiveView forms provide real-time validation and a smooth user experience. In this chapter, we'll explore form handling in LiveView.

## Basic LiveView Form

```elixir
# File: lib/snippetbox_web/live/snippet_live/form_component.ex

defmodule SnippetboxWeb.SnippetLive.FormComponent do
  use SnippetboxWeb, :live_component

  alias Snippetbox.Snippets

  @impl true
  def render(assigns) do
    ~H"""
    <div>
      <.header>
        <%= @title %>
        <:subtitle>Manage snippet details</:subtitle>
      </.header>

      <.simple_form
        for={@form}
        id="snippet-form"
        phx-target={@myself}
        phx-change="validate"
        phx-submit="save"
      >
        <.input field={@form[:title]} type="text" label="Title" />
        <.input field={@form[:content]} type="textarea" label="Content" />
        <.input
          field={@form[:language]}
          type="select"
          label="Language"
          prompt="Select language"
          options={~w(elixir javascript python ruby go rust)}
        />
        <.input field={@form[:public]} type="checkbox" label="Public" />

        <:actions>
          <.button phx-disable-with="Saving...">Save Snippet</.button>
        </:actions>
      </.simple_form>
    </div>
    """
  end

  @impl true
  def update(%{snippet: snippet} = assigns, socket) do
    changeset = Snippets.change_snippet(snippet)

    {:ok,
     socket
     |> assign(assigns)
     |> assign_form(changeset)}
  end

  @impl true
  def handle_event("validate", %{"snippet" => snippet_params}, socket) do
    changeset =
      socket.assigns.snippet
      |> Snippets.change_snippet(snippet_params)
      |> Map.put(:action, :validate)

    {:noreply, assign_form(socket, changeset)}
  end

  def handle_event("save", %{"snippet" => snippet_params}, socket) do
    save_snippet(socket, socket.assigns.action, snippet_params)
  end

  defp save_snippet(socket, :edit, snippet_params) do
    case Snippets.update_snippet(socket.assigns.snippet, snippet_params) do
      {:ok, snippet} ->
        notify_parent({:saved, snippet})

        {:noreply,
         socket
         |> put_flash(:info, "Snippet updated successfully")
         |> push_patch(to: socket.assigns.patch)}

      {:error, %Ecto.Changeset{} = changeset} ->
        {:noreply, assign_form(socket, changeset)}
    end
  end

  defp save_snippet(socket, :new, snippet_params) do
    case Snippets.create_snippet(snippet_params) do
      {:ok, snippet} ->
        notify_parent({:saved, snippet})

        {:noreply,
         socket
         |> put_flash(:info, "Snippet created successfully")
         |> push_patch(to: socket.assigns.patch)}

      {:error, %Ecto.Changeset{} = changeset} ->
        {:noreply, assign_form(socket, changeset)}
    end
  end

  defp assign_form(socket, %Ecto.Changeset{} = changeset) do
    assign(socket, :form, to_form(changeset))
  end

  defp notify_parent(msg), do: send(self(), {__MODULE__, msg})
end
```

## Real-Time Validation

### Debounced Input

```heex
<.input
  field={@form[:title]}
  type="text"
  label="Title"
  phx-debounce="300"
/>
```

### Blur Validation

```heex
<.input
  field={@form[:email]}
  type="email"
  label="Email"
  phx-debounce="blur"
/>
```

### Instant Validation

```heex
<.input
  field={@form[:public]}
  type="checkbox"
  label="Public"
  phx-debounce="0"
/>
```

## Form Events

### phx-change

Fires on every input change:

```elixir
def handle_event("validate", %{"snippet" => params}, socket) do
  changeset =
    socket.assigns.snippet
    |> Snippets.change_snippet(params)
    |> Map.put(:action, :validate)

  {:noreply, assign_form(socket, changeset)}
end
```

### phx-submit

Fires on form submission:

```elixir
def handle_event("save", %{"snippet" => params}, socket) do
  case Snippets.create_snippet(params) do
    {:ok, snippet} ->
      {:noreply,
       socket
       |> put_flash(:info, "Created!")
       |> push_navigate(to: ~p"/snippets/#{snippet}")}

    {:error, changeset} ->
      {:noreply, assign_form(socket, changeset)}
  end
end
```

## File Uploads

### Configuration

```elixir
@impl true
def mount(_params, _session, socket) do
  {:ok,
   socket
   |> assign(:uploaded_files, [])
   |> allow_upload(:avatar,
       accept: ~w(.jpg .jpeg .png),
       max_entries: 1,
       max_file_size: 5_000_000
     )}
end
```

### Template

```heex
<form phx-submit="save" phx-change="validate">
  <.live_file_input upload={@uploads.avatar} />

  <%# Preview %>
  <%= for entry <- @uploads.avatar.entries do %>
    <article class="upload-entry">
      <figure>
        <.live_img_preview entry={entry} />
        <figcaption><%= entry.client_name %></figcaption>
      </figure>

      <%# Progress bar %>
      <progress value={entry.progress} max="100"><%= entry.progress %>%</progress>

      <%# Cancel button %>
      <button type="button" phx-click="cancel-upload" phx-value-ref={entry.ref}>
        &times;
      </button>

      <%# Errors %>
      <%= for err <- upload_errors(@uploads.avatar, entry) do %>
        <p class="text-red-600"><%= error_to_string(err) %></p>
      <% end %>
    </article>
  <% end %>

  <button type="submit">Upload</button>
</form>
```

### Handling Upload

```elixir
def handle_event("save", _params, socket) do
  uploaded_files =
    consume_uploaded_entries(socket, :avatar, fn %{path: path}, entry ->
      dest = Path.join("priv/static/uploads", entry.client_name)
      File.cp!(path, dest)
      {:ok, ~p"/uploads/#{Path.basename(dest)}"}
    end)

  {:noreply, update(socket, :uploaded_files, &(&1 ++ uploaded_files))}
end

def handle_event("cancel-upload", %{"ref" => ref}, socket) do
  {:noreply, cancel_upload(socket, :avatar, ref)}
end

defp error_to_string(:too_large), do: "File too large"
defp error_to_string(:not_accepted), do: "File type not accepted"
defp error_to_string(:too_many_files), do: "Too many files"
```

## Multi-Step Forms

```elixir
defmodule SnippetboxWeb.WizardLive do
  use SnippetboxWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |> assign(:step, 1)
     |> assign(:form_data, %{})
     |> assign_form(changeset_for_step(1, %{}))}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="wizard">
      <div class="steps">
        <.step_indicator current={@step} total={3} />
      </div>

      <.form for={@form} phx-submit="next">
        <%= case @step do %>
          <% 1 -> %>
            <.step_one form={@form} />
          <% 2 -> %>
            <.step_two form={@form} />
          <% 3 -> %>
            <.step_three form={@form} />
        <% end %>

        <div class="flex gap-4 mt-6">
          <.button :if={@step > 1} type="button" phx-click="prev">Back</.button>
          <.button type="submit">
            <%= if @step == 3, do: "Submit", else: "Next" %>
          </.button>
        </div>
      </.form>
    </div>
    """
  end

  @impl true
  def handle_event("next", %{"wizard" => params}, socket) do
    current_step = socket.assigns.step
    form_data = Map.merge(socket.assigns.form_data, params)

    case validate_step(current_step, params) do
      {:ok, _} when current_step < 3 ->
        {:noreply,
         socket
         |> assign(:step, current_step + 1)
         |> assign(:form_data, form_data)
         |> assign_form(changeset_for_step(current_step + 1, form_data))}

      {:ok, _} ->
        # Final step - submit
        submit_wizard(socket, form_data)

      {:error, changeset} ->
        {:noreply, assign_form(socket, changeset)}
    end
  end

  def handle_event("prev", _params, socket) do
    new_step = max(1, socket.assigns.step - 1)

    {:noreply,
     socket
     |> assign(:step, new_step)
     |> assign_form(changeset_for_step(new_step, socket.assigns.form_data))}
  end

  defp changeset_for_step(step, data) do
    # Return appropriate changeset for each step
  end

  defp validate_step(step, params) do
    # Validate params for specific step
  end

  defp submit_wizard(socket, form_data) do
    # Process complete form data
  end
end
```

## Dynamic Form Fields

```elixir
defmodule SnippetboxWeb.DynamicFormLive do
  use SnippetboxWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    {:ok, assign(socket, tags: [""], next_id: 1)}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <.form for={%{}} phx-submit="save">
      <div id="tags" phx-update="stream">
        <%= for {id, tag} <- Enum.with_index(@tags) do %>
          <div id={"tag-#{id}"} class="flex gap-2 mb-2">
            <input type="text" name="tags[]" value={tag} />
            <button type="button" phx-click="remove-tag" phx-value-index={id}>
              Remove
            </button>
          </div>
        <% end %>
      </div>

      <button type="button" phx-click="add-tag">Add Tag</button>
      <.button type="submit">Save</.button>
    </.form>
    """
  end

  @impl true
  def handle_event("add-tag", _params, socket) do
    {:noreply, update(socket, :tags, &(&1 ++ [""]))}
  end

  def handle_event("remove-tag", %{"index" => index}, socket) do
    index = String.to_integer(index)
    tags = List.delete_at(socket.assigns.tags, index)
    {:noreply, assign(socket, :tags, tags)}
  end

  def handle_event("save", %{"tags" => tags}, socket) do
    # Process tags
    {:noreply, socket}
  end
end
```

## Form with Associations

```elixir
defmodule SnippetboxWeb.SnippetLive.FormWithTags do
  use SnippetboxWeb, :live_component

  @impl true
  def render(assigns) do
    ~H"""
    <.simple_form for={@form} phx-target={@myself} phx-submit="save">
      <.input field={@form[:title]} label="Title" />
      <.input field={@form[:content]} type="textarea" label="Content" />

      <div class="mt-4">
        <label class="block text-sm font-medium">Tags</label>
        <.inputs_for :let={tag_form} field={@form[:tags]}>
          <div class="flex gap-2 mt-2">
            <input type="hidden" name="snippet[tags_sort][]" value={tag_form.index} />
            <.input field={tag_form[:name]} placeholder="Tag name" />
            <button
              type="button"
              name="snippet[tags_drop][]"
              value={tag_form.index}
              phx-click={JS.dispatch("change")}
            >
              Remove
            </button>
          </div>
        </.inputs_for>

        <input type="hidden" name="snippet[tags_drop][]" />

        <button
          type="button"
          name="snippet[tags_sort][]"
          value="new"
          phx-click={JS.dispatch("change")}
          class="mt-2"
        >
          Add Tag
        </button>
      </div>

      <:actions>
        <.button>Save</.button>
      </:actions>
    </.simple_form>
    """
  end

  @impl true
  def update(%{snippet: snippet} = assigns, socket) do
    changeset = Snippets.change_snippet(snippet)
    {:ok, socket |> assign(assigns) |> assign_form(changeset)}
  end

  @impl true
  def handle_event("validate", %{"snippet" => params}, socket) do
    changeset =
      socket.assigns.snippet
      |> Snippets.change_snippet(params)
      |> Map.put(:action, :validate)

    {:noreply, assign_form(socket, changeset)}
  end

  def handle_event("save", %{"snippet" => params}, socket) do
    # Handle save
  end
end
```

> **FP Concept: Form as Data Transformation**
>
> LiveView forms follow a data transformation pattern:
>
> ```elixir
> # Initial: empty changeset
> changeset = change_snippet(%Snippet{})
>
> # On each change: params → changeset → form
> changeset = change_snippet(snippet, params)
> form = to_form(changeset)
>
> # On submit: params → changeset → insert/update
> case create_snippet(params) do
>   {:ok, snippet} -> success
>   {:error, changeset} -> show errors
> end
> ```
>
> The same changeset pattern works for both real-time validation and final submission.

## Summary

In this chapter, we learned:

- Basic LiveView form setup
- Real-time validation with phx-change
- Debounced and blur validation
- File uploads with progress
- Multi-step wizard forms
- Dynamic form fields
- Forms with associations

In the next chapter, we'll explore Live Components.
