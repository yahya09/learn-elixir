# Chapter 6: Plugs and Middleware

Plugs are Phoenix's middleware system. In this chapter, we'll learn how plugs work, how to create custom plugs, and how to use them for cross-cutting concerns like authentication, logging, and request transformation.

## What You'll Learn

- Understanding the Plug specification
- How Phoenix uses plugs in pipelines
- Creating function and module plugs
- Common plug patterns
- Building authentication plugs
- Request/response transformation

## What is a Plug?

A plug is a module or function that:

1. **Receives** a connection (`Plug.Conn`)
2. **Transforms** the connection somehow
3. **Returns** the (possibly modified) connection

```elixir
# Function plug
def my_plug(conn, _opts) do
  assign(conn, :user_agent, get_req_header(conn, "user-agent"))
end

# Module plug
defmodule MyPlug do
  def init(opts), do: opts
  def call(conn, _opts), do: conn
end
```

## The Plug Pipeline

Every Phoenix request flows through plugs:

```
Request
   │
   ▼
┌─────────────┐
│  Endpoint   │ (Plug.Static, Plug.RequestId, ...)
└─────────────┘
   │
   ▼
┌─────────────┐
│   Router    │ (pipeline plugs, route matching)
└─────────────┘
   │
   ▼
┌─────────────┐
│ Controller  │ (action plugs, action)
└─────────────┘
   │
   ▼
Response
```

## Chapter Structure

This chapter covers:

- **6.1 Understanding Plugs** - The Plug specification
- **6.2 Phoenix Pipelines** - Router pipelines and plug_through
- **6.3 Creating Custom Plugs** - Function and module plugs
- **6.4 Common Plug Patterns** - Authentication, logging, rate limiting
- **6.5 Testing Plugs** - Unit testing plug modules

Let's start by understanding the Plug specification.
