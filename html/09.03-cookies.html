<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Cookies &mdash; Let's Build with Elixir and Phoenix</title>
    <link rel="stylesheet" type="text/css" href="assets/css/main.css">
</head>
<body>
    <header>
        <div class="wrapper">
            <div>
                <a href="index.html">Let's Build with Elixir and Phoenix</a>
                <span class="crumbs">&rsaquo; Cookies</span>
            </div>
            <div>
                &lsaquo; <a href="09.02-flash-messages.html">Previous</a> &middot;
                <a href="00.01-contents.html">Contents</a>
                &middot; <a href="09.04-ets-and-caching.html">Next</a> &rsaquo;
            </div>
        </div>
    </header>
    <main class="wrapper text">
        <div class="chapter">Chapter 9.3</div>
        <h1>Chapter 9.3: Cookies</h1>

<p>Cookies store small pieces of data in the user's browser. In this chapter, we'll explore cookie handling in Phoenix.</p>

<h2>Cookie Basics</h2>

<h3>How Cookies Work</h3>

<figure class="code"><pre><code>Browser                          Server
<p>   │                               │</p>
<p>   │  Request                      │</p>
<p>   │──────────────────────────────>│</p>
<p>   │                               │</p>
<p>   │  Response                     │</p>
<p>   │  Set-Cookie: theme=dark       │</p>
<p>   │<──────────────────────────────│</p>
<p>   │                               │</p>
<p>   │  Cookie stored in browser     │</p>
<p>   │                               │</p>
<p>   │  Subsequent Request           │</p>
<p>   │  Cookie: theme=dark           │</p>
<p>   │──────────────────────────────>│</p>
<p>   │                               │</p>
</code></pre></figure>

<h3>Cookie Characteristics</h3>

<p>| Property | Description |</p>
<p>|----------|-------------|</p>
<p>| Size | Max ~4KB per cookie |</p>
<p>| Quantity | ~50 cookies per domain |</p>
<p>| Sent | With every request to domain |</p>
<p>| Storage | Client-side (browser) |</p>
<p>| Visibility | User can see/modify |</p>

<h2>Reading Cookies</h2>

<h3>Basic Reading</h3>

<figure class="code"><figcaption>File: lib/snippetbox_web/controllers/page_controller.ex</figcaption><pre><code class="language-elixir">
<p>def home(conn, _params) do</p>
<p>  # Read a specific cookie</p>
<p>  theme = conn.cookies["theme"] || "light"</p>

<p>  # Read all cookies</p>
<p>  all_cookies = conn.cookies</p>

<p>  render(conn, :home, theme: theme)</p>
<p>end</p>
</code></pre></figure>

<h3>In Plugs</h3>

<figure class="code"><figcaption>File: lib/snippetbox_web/plugs/theme.ex</figcaption><pre><code class="language-elixir">
<p>defmodule SnippetboxWeb.Plugs.Theme do</p>
<p>  import Plug.Conn</p>

<p>  def init(opts), do: opts</p>

<p>  def call(conn, _opts) do</p>
<p>    theme = conn.cookies["theme"] || "light"</p>
<p>    assign(conn, :theme, theme)</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Writing Cookies</h2>

<h3>Basic Cookie</h3>

<figure class="code"><pre><code>def set_theme(conn, %{"theme" => theme}) do
<p>  conn</p>
<p>  |> put_resp_cookie("theme", theme)</p>
<p>  |> redirect(to: ~p"/")</p>
<p>end</p>
</code></pre></figure>

<h3>Cookie with Options</h3>

<figure class="code"><pre><code>def set_preferences(conn, %{"language" => lang}) do
<p>  conn</p>
<p>  |> put_resp_cookie("language", lang,</p>
<p>       max_age: 60 <em> 60 </em> 24 * 365,  # 1 year</p>
<p>       http_only: true,</p>
<p>       secure: true,</p>
<p>       same_site: "Lax"</p>
<p>     )</p>
<p>  |> redirect(to: ~p"/settings")</p>
<p>end</p>
</code></pre></figure>

<h3>Cookie Options</h3>

<p>| Option | Description | Default |</p>
<p>|--------|-------------|---------|</p>
<p>| <code>:max_age</code> | Lifetime in seconds | Session |</p>
<p>| <code>:expires</code> | Specific expiry datetime | None |</p>
<p>| <code>:path</code> | URL path scope | <code>"/"</code> |</p>
<p>| <code>:domain</code> | Domain scope | Current |</p>
<p>| <code>:secure</code> | HTTPS only | <code>false</code> |</p>
<p>| <code>:http_only</code> | Not accessible via JS | <code>true</code> |</p>
<p>| <code>:same_site</code> | CSRF protection | <code>"Lax"</code> |</p>

<h2>Deleting Cookies</h2>

<figure class="code"><pre><code>def clear_preferences(conn, _params) do
<p>  conn</p>
<p>  |> delete_resp_cookie("theme")</p>
<p>  |> delete_resp_cookie("language")</p>
<p>  |> redirect(to: ~p"/settings")</p>
<p>end</p>

<h1>With path option (must match set path)</h1>
<p>|> delete_resp_cookie("theme", path: "/app")</p>
</code></pre></figure>

<h2>Signed Cookies</h2>

<p>Signed cookies prevent tampering:</p>

<figure class="code"><figcaption>File: lib/snippetbox_web/controllers/preferences_controller.ex</figcaption><pre><code class="language-elixir">
<p>@cookie_signing_salt "preferences_salt"</p>

<p>def set_user_preferences(conn, %{"prefs" => prefs}) do</p>
<p>  # Encode and sign</p>
<p>  signed_value = sign_cookie(conn, prefs)</p>

<p>  conn</p>
<p>  |> put_resp_cookie("user_prefs", signed_value, max_age: 60 <em> 60 </em> 24 * 30)</p>
<p>  |> redirect(to: ~p"/")</p>
<p>end</p>

<p>def get_user_preferences(conn) do</p>
<p>  case conn.cookies["user_prefs"] do</p>
<p>    nil -> %{}</p>
<p>    signed_value -> verify_cookie(conn, signed_value)</p>
<p>  end</p>
<p>end</p>

<p>defp sign_cookie(conn, data) do</p>
<p>  data</p>
<p>  |> Jason.encode!()</p>
<p>  |> Phoenix.Token.sign(conn, @cookie_signing_salt)</p>
<p>end</p>

<p>defp verify_cookie(conn, signed_value) do</p>
<p>  case Phoenix.Token.verify(conn, @cookie_signing_salt, signed_value, max_age: 60 <em> 60 </em> 24 * 30) do</p>
<p>    {:ok, json} -> Jason.decode!(json)</p>
<p>    {:error, _} -> %{}</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Encrypted Cookies</h2>

<p>For sensitive data, use encryption:</p>

<figure class="code"><pre><code>defmodule SnippetboxWeb.EncryptedCookie do
<p>  @secret_key_base Application.compile_env(:snippetbox, SnippetboxWeb.Endpoint)[:secret_key_base]</p>

<p>  def encrypt(data) do</p>
<p>    :crypto.strong_rand_bytes(16)</p>
<p>    |> then(fn iv -></p>
<p>      key = :crypto.hash(:sha256, @secret_key_base)</p>
<p>      plaintext = Jason.encode!(data)</p>
<p>      ciphertext = :crypto.crypto_one_time(:aes_256_gcm, key, iv, plaintext, true)</p>
<p>      Base.url_encode64(iv <> ciphertext)</p>
<p>    end)</p>
<p>  end</p>

<p>  def decrypt(encrypted) do</p>
<p>    with {:ok, binary} <- Base.url_decode64(encrypted),</p>
<p>         <<iv::binary-16, ciphertext::binary>> <- binary do</p>
<p>      key = :crypto.hash(:sha256, @secret_key_base)</p>
<p>      plaintext = :crypto.crypto_one_time(:aes_256_gcm, key, iv, ciphertext, false)</p>
<p>      Jason.decode!(plaintext)</p>
<p>    else</p>
<p>      _ -> nil</p>
<p>    end</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Cookie Patterns</h2>

<h3>Remember Me</h3>

<figure class="code"><figcaption>File: lib/snippetbox_web/controllers/session_controller.ex</figcaption><pre><code class="language-elixir">
<p>def create(conn, %{"email" => email, "password" => password, "remember_me" => remember}) do</p>
<p>  case Accounts.authenticate(email, password) do</p>
<p>    {:ok, user} -></p>
<p>      conn = put_session(conn, :user_id, user.id)</p>

<p>      conn =</p>
<p>        if remember == "true" do</p>
<p>          token = Accounts.generate_remember_token(user)</p>
<p>          put_resp_cookie(conn, "remember_token", token,</p>
<p>            max_age: 60 <em> 60 </em> 24 * 30,  # 30 days</p>
<p>            http_only: true,</p>
<p>            secure: Mix.env() == :prod</p>
<p>          )</p>
<p>        else</p>
<p>          conn</p>
<p>        end</p>

<p>      redirect(conn, to: ~p"/")</p>

<p>    {:error, _} -></p>
<p>      render(conn, :new, error: "Invalid credentials")</p>
<p>  end</p>
<p>end</p>

<h1>Plug to restore session from remember token</h1>
<p>def restore_session(conn, _opts) do</p>
<p>  if get_session(conn, :user_id) do</p>
<p>    conn</p>
<p>  else</p>
<p>    case conn.cookies["remember_token"] do</p>
<p>      nil -> conn</p>
<p>      token -></p>
<p>        case Accounts.get_user_by_remember_token(token) do</p>
<p>          nil -></p>
<p>            delete_resp_cookie(conn, "remember_token")</p>

<p>          user -></p>
<p>            conn</p>
<p>            |> put_session(:user_id, user.id)</p>
<p>            |> assign(:current_user, user)</p>
<p>        end</p>
<p>    end</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h3>User Preferences</h3>

<figure class="code"><figcaption>File: lib/snippetbox_web/plugs/preferences.ex</figcaption><pre><code class="language-elixir">
<p>defmodule SnippetboxWeb.Plugs.Preferences do</p>
<p>  import Plug.Conn</p>

<p>  @defaults %{</p>
<p>    "theme" => "light",</p>
<p>    "language" => "en",</p>
<p>    "timezone" => "UTC",</p>
<p>    "items_per_page" => "20"</p>
<p>  }</p>

<p>  def init(opts), do: opts</p>

<p>  def call(conn, _opts) do</p>
<p>    preferences =</p>
<p>      @defaults</p>
<p>      |> Enum.map(fn {key, default} -></p>
<p>        {key, conn.cookies["pref_#{key}"] || default}</p>
<p>      end)</p>
<p>      |> Map.new()</p>

<p>    assign(conn, :preferences, preferences)</p>
<p>  end</p>
<p>end</p>

<h1>Controller to update preferences</h1>
<p>defmodule SnippetboxWeb.PreferencesController do</p>
<p>  use SnippetboxWeb, :controller</p>

<p>  def update(conn, %{"preferences" => prefs}) do</p>
<p>    conn =</p>
<p>      Enum.reduce(prefs, conn, fn {key, value}, conn -></p>
<p>        put_resp_cookie(conn, "pref_#{key}", value,</p>
<p>          max_age: 60 <em> 60 </em> 24 * 365,</p>
<p>          http_only: true</p>
<p>        )</p>
<p>      end)</p>

<p>    conn</p>
<p>    |> put_flash(:info, "Preferences saved!")</p>
<p>    |> redirect(to: ~p"/settings")</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h3>Consent Cookie</h3>

<figure class="code"><figcaption>File: lib/snippetbox_web/controllers/consent_controller.ex</figcaption><pre><code class="language-elixir">
<p>defmodule SnippetboxWeb.ConsentController do</p>
<p>  use SnippetboxWeb, :controller</p>

<p>  def accept(conn, _params) do</p>
<p>    conn</p>
<p>    |> put_resp_cookie("cookie_consent", "accepted",</p>
<p>         max_age: 60 <em> 60 </em> 24 * 365,</p>
<p>         http_only: false  # Allow JS to read</p>
<p>       )</p>
<p>    |> json(%{status: "ok"})</p>
<p>  end</p>
<p>end</p>

<h1>Plug to check consent</h1>
<p>defmodule SnippetboxWeb.Plugs.CookieConsent do</p>
<p>  import Plug.Conn</p>

<p>  def init(opts), do: opts</p>

<p>  def call(conn, _opts) do</p>
<p>    consent = conn.cookies["cookie_consent"] == "accepted"</p>
<p>    assign(conn, :cookie_consent, consent)</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h3>Tracking Cookies (with Consent)</h3>

<figure class="code"><pre><code># Only set tracking if consent given
<p>def maybe_track(conn, _opts) do</p>
<p>  if conn.assigns[:cookie_consent] do</p>
<p>    visitor_id = conn.cookies["visitor_id"] || generate_visitor_id()</p>

<p>    conn</p>
<p>    |> put_resp_cookie("visitor_id", visitor_id,</p>
<p>         max_age: 60 <em> 60 </em> 24 * 365</p>
<p>       )</p>
<p>    |> assign(:visitor_id, visitor_id)</p>
<p>  else</p>
<p>    conn</p>
<p>  end</p>
<p>end</p>

<p>defp generate_visitor_id do</p>
<p>  :crypto.strong_rand_bytes(16) |> Base.url_encode64()</p>
<p>end</p>
</code></pre></figure>

<h2>Cookie Security</h2>

<h3>Secure Defaults</h3>

<figure class="code"><pre><code>defp secure_cookie(conn, name, value, opts \\ []) do
<p>  defaults = [</p>
<p>    http_only: true,</p>
<p>    secure: Mix.env() == :prod,</p>
<p>    same_site: "Lax"</p>
<p>  ]</p>

<p>  put_resp_cookie(conn, name, value, Keyword.merge(defaults, opts))</p>
<p>end</p>
</code></pre></figure>

<h3>SameSite Attribute</h3>

<p>| Value | Behavior |</p>
<p>|-------|----------|</p>
<p>| <code>"Strict"</code> | Only sent on same-site requests |</p>
<p>| <code>"Lax"</code> | Sent on same-site + top-level navigation |</p>
<p>| <code>"None"</code> | Sent on all requests (requires <code>secure: true</code>) |</p>

<figure class="code"><pre><code># For authentication cookies
<p>put_resp_cookie(conn, "session", value, same_site: "Lax")</p>

<h1>For cross-site cookies (e.g., embedded widgets)</h1>
<p>put_resp_cookie(conn, "widget_pref", value,</p>
<p>  same_site: "None",</p>
<p>  secure: true</p>
<p>)</p>
</code></pre></figure>

<blockquote class="fp-concept">
<strong>FP Concept: Explicit Data Flow</strong>
</blockquote>
<p>></p>
<blockquote>
<p>Phoenix makes cookie handling explicit:</p>
</blockquote>
<p>></p>
<blockquote>
<figure class="code"><pre><code>> # Read: explicit access
<p>value = conn.cookies["key"]</p>
</blockquote>
<p>></p>
<blockquote>
<p># Write: returns new conn</p>
<p>conn = put_resp_cookie(conn, "key", "value")</p>
</blockquote>
<p>></p>
<blockquote>
<p># Delete: returns new conn</p>
<p>conn = delete_resp_cookie(conn, "key")</p>
</code></pre></figure>
</blockquote>
<p>></p>
<blockquote>
<p>Unlike frameworks with implicit cookie access, Phoenix requires explicit read/write operations, making data flow clear and predictable.</p>
</blockquote>

<h2>Summary</h2>

<p>In this chapter, we learned:</p>

<ul>
<li>How cookies work in HTTP</li>
<li>Reading cookies from requests</li>
<li>Writing cookies with various options</li>
<li>Deleting cookies</li>
<li>Signed and encrypted cookies</li>
<li>Common patterns (remember me, preferences)</li>
<li>Cookie security best practices</li>
</ul>

<p>In the next chapter, we'll explore ETS and caching.</p>

    </main>
    <footer>
        <div class="wrapper">
            <div>
                &lsaquo; <a href="09.02-flash-messages.html">Previous</a>
            </div>
            <div>
                <a href="00.01-contents.html">Contents</a>
            </div>
            <div>
                <a href="09.04-ets-and-caching.html">Next</a> &rsaquo;
            </div>
        </div>
    </footer>
</body>
</html>
