# Chapter 2.4: Customizing HTTP Headers

HTTP headers carry metadata about requests and responses. In this chapter, we'll learn how to read request headers and set custom response headers in Phoenix.

## Understanding HTTP Headers

Headers are key-value pairs sent with HTTP requests and responses:

```
GET /snippets HTTP/1.1
Host: localhost:4000
Accept: text/html
User-Agent: Mozilla/5.0
Cookie: session_id=abc123
```

Response headers:
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=3600
X-Request-Id: abc-123-def
```

## Reading Request Headers

In Phoenix, request headers are available in the `conn` struct:

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

defmodule SnippetboxWeb.SnippetController do
  use SnippetboxWeb, :controller

  def show(conn, %{"id" => id}) do
    # Get a specific header
    user_agent = get_req_header(conn, "user-agent")

    # Headers are returned as a list (can have multiple values)
    case user_agent do
      [agent | _] ->
        IO.puts("User agent: #{agent}")
      [] ->
        IO.puts("No user agent header")
    end

    text(conn, "Snippet #{id}")
  end
end
```

The `get_req_header/2` function returns a list because HTTP allows multiple headers with the same name.

### Common Request Headers

```elixir
def debug_headers(conn, _params) do
  # Content type of request body
  content_type = get_req_header(conn, "content-type")

  # Accepted response formats
  accept = get_req_header(conn, "accept")

  # Client information
  user_agent = get_req_header(conn, "user-agent")

  # Authentication
  authorization = get_req_header(conn, "authorization")

  # Cookies
  cookies = get_req_header(conn, "cookie")

  # Client IP (may be set by proxy)
  forwarded_for = get_req_header(conn, "x-forwarded-for")

  # Log all headers
  IO.inspect(conn.req_headers, label: "All request headers")

  text(conn, "Headers logged")
end
```

## Setting Response Headers

Use `put_resp_header/3` to add response headers:

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def show(conn, %{"id" => id}) do
  conn
  |> put_resp_header("x-snippet-id", id)
  |> put_resp_header("cache-control", "public, max-age=3600")
  |> text("Snippet #{id}")
end
```

### Setting Content-Type

Phoenix sets `Content-Type` automatically based on the response format, but you can override it:

```elixir
def download(conn, %{"id" => id}) do
  conn
  |> put_resp_content_type("text/plain")
  |> put_resp_header("content-disposition", "attachment; filename=\"snippet-#{id}.txt\"")
  |> send_resp(200, "Snippet content here")
end
```

For common content types, use the helper:

```elixir
# These are equivalent
put_resp_content_type(conn, "application/json")
put_resp_header(conn, "content-type", "application/json; charset=utf-8")
```

### Setting Multiple Headers

Chain multiple header operations:

```elixir
def api_response(conn, _params) do
  conn
  |> put_resp_header("x-api-version", "1.0")
  |> put_resp_header("x-request-id", generate_request_id())
  |> put_resp_header("cache-control", "no-store")
  |> put_resp_header("x-content-type-options", "nosniff")
  |> json(%{status: "ok"})
end

defp generate_request_id do
  :crypto.strong_rand_bytes(16) |> Base.encode16(case: :lower)
end
```

## Setting Status Codes

Use `put_status/2` to set the HTTP status code:

```elixir
def not_found(conn, _params) do
  conn
  |> put_status(:not_found)  # 404
  |> text("Resource not found")
end

def created(conn, _params) do
  conn
  |> put_status(:created)  # 201
  |> put_resp_header("location", "/snippets/123")
  |> json(%{id: 123})
end
```

### Common Status Codes

Phoenix supports atom shortcuts for status codes:

```elixir
:ok                    # 200
:created               # 201
:accepted              # 202
:no_content            # 204
:moved_permanently     # 301
:found                 # 302
:see_other             # 303
:not_modified          # 304
:bad_request           # 400
:unauthorized          # 401
:forbidden             # 403
:not_found             # 404
:unprocessable_entity  # 422
:internal_server_error # 500
:service_unavailable   # 503
```

Or use integers directly:

```elixir
put_status(conn, 418)  # I'm a teapot
```

## Deleting Headers

Remove a header from the response:

```elixir
def minimal_response(conn, _params) do
  conn
  |> delete_resp_header("x-frame-options")
  |> text("Minimal response")
end
```

## Security Headers

Set common security headers:

```elixir
def secure_page(conn, _params) do
  conn
  |> put_resp_header("x-frame-options", "DENY")
  |> put_resp_header("x-content-type-options", "nosniff")
  |> put_resp_header("x-xss-protection", "1; mode=block")
  |> put_resp_header("referrer-policy", "strict-origin-when-cross-origin")
  |> put_resp_header("content-security-policy", "default-src 'self'")
  |> render(:secure_page)
end
```

> **Note**: Phoenix's default `:browser` pipeline already sets several security headers via `put_secure_browser_headers/2`. We'll cover this in detail in Chapter 6 (Plugs).

## Cache Control Headers

Control how browsers and proxies cache responses:

```elixir
# Don't cache (for private/dynamic content)
def private_data(conn, _params) do
  conn
  |> put_resp_header("cache-control", "no-store, private")
  |> json(%{secret: "data"})
end

# Cache for 1 hour (for public/static content)
def public_data(conn, _params) do
  conn
  |> put_resp_header("cache-control", "public, max-age=3600")
  |> put_resp_header("vary", "Accept-Encoding")
  |> json(%{data: "public"})
end

# Cache with revalidation
def cached_data(conn, _params) do
  etag = generate_etag(data)

  conn
  |> put_resp_header("cache-control", "public, max-age=0, must-revalidate")
  |> put_resp_header("etag", etag)
  |> json(%{data: "cached"})
end
```

## CORS Headers

For APIs accessed from browsers on different domains:

```elixir
def api_endpoint(conn, _params) do
  conn
  |> put_resp_header("access-control-allow-origin", "*")
  |> put_resp_header("access-control-allow-methods", "GET, POST, PUT, DELETE")
  |> put_resp_header("access-control-allow-headers", "Content-Type, Authorization")
  |> json(%{status: "ok"})
end

# Handle preflight OPTIONS request
def options(conn, _params) do
  conn
  |> put_resp_header("access-control-allow-origin", "*")
  |> put_resp_header("access-control-allow-methods", "GET, POST, PUT, DELETE")
  |> put_resp_header("access-control-allow-headers", "Content-Type, Authorization")
  |> put_resp_header("access-control-max-age", "86400")
  |> send_resp(204, "")
end
```

> **Tip**: For production CORS handling, use a library like `cors_plug` which handles this properly.

## Practical Example: Content Negotiation

Handle different response formats based on the `Accept` header:

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def show(conn, %{"id" => id}) do
  snippet = %{id: id, title: "Example", content: "Hello World"}

  case get_format(conn) do
    "json" ->
      json(conn, snippet)

    "html" ->
      render(conn, :show, snippet: snippet)

    _ ->
      conn
      |> put_status(:not_acceptable)
      |> text("Supported formats: HTML, JSON")
  end
end
```

Phoenix handles content negotiation through the router's `accepts` plug:

```elixir
# File: lib/snippetbox_web/router.ex

pipeline :browser do
  plug :accepts, ["html"]  # Only accept HTML
end

pipeline :api do
  plug :accepts, ["json"]  # Only accept JSON
end
```

## Inspecting Headers in IEx

Debug headers interactively:

```elixir
# Start your app
$ iex -S mix phx.server

# In another terminal, make a request
$ curl -v http://localhost:4000/snippets/1

# View request headers in your controller
def show(conn, params) do
  IO.inspect(conn.req_headers, label: "Request Headers")
  # ...
end
```

> **FP Concept: Immutable Transformations**
>
> Notice how we chain header operations:
>
> ```elixir
> conn
> |> put_status(200)
> |> put_resp_header("x-custom", "value")
> |> put_resp_header("cache-control", "no-store")
> |> json(%{ok: true})
> ```
>
> Each function returns a **new** conn struct with the modification. The original `conn` is never mutated. This is the pipe operator pattern - data flows through a series of transformations.
>
> In imperative code, you might write:
> ```python
> # Python/Flask
> response.status_code = 200
> response.headers["X-Custom"] = "value"
> response.headers["Cache-Control"] = "no-store"
> return jsonify({"ok": True})
> ```
>
> The functional approach:
> - Makes the transformation sequence explicit
> - Each step is a pure function
> - Easy to insert/remove/reorder steps
> - No hidden state mutations
>
> **Further Reading**:
> - [Plug.Conn documentation](https://hexdocs.pm/plug/Plug.Conn.html)

## Summary

In this chapter, we learned:

- How to read request headers with `get_req_header/2`
- How to set response headers with `put_resp_header/3`
- How to set status codes with `put_status/2`
- Common header patterns (security, caching, CORS)
- Content negotiation basics

In the next chapter, we'll explore URL query strings and path parameters in more detail.

---

## Additional Information

### Header Case Sensitivity

HTTP header names are case-insensitive. Phoenix normalizes them to lowercase:

```elixir
# All equivalent:
get_req_header(conn, "content-type")
get_req_header(conn, "Content-Type")
get_req_header(conn, "CONTENT-TYPE")
```

### Multiple Values for Same Header

Some headers can appear multiple times (like `Set-Cookie`):

```elixir
# Setting multiple cookies
conn
|> put_resp_cookie("session", "abc123")
|> put_resp_cookie("preferences", "dark_mode")
```

### Comparing to Other Frameworks

**Express (Node.js)**:
```javascript
res.set('X-Custom-Header', 'value');
res.status(200).json({ok: true});
```

**Django (Python)**:
```python
response = JsonResponse({'ok': True})
response['X-Custom-Header'] = 'value'
return response
```

**Laravel (PHP)**:
```php
return response()->json(['ok' => true])
    ->header('X-Custom-Header', 'value');
```

**Phoenix (Elixir)**:
```elixir
conn
|> put_resp_header("x-custom-header", "value")
|> json(%{ok: true})
```
