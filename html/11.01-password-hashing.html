<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Password Hashing &mdash; Let's Build with Elixir and Phoenix</title>
    <link rel="stylesheet" type="text/css" href="assets/css/main.css">
</head>
<body>
    <header>
        <div class="wrapper">
            <div>
                <a href="index.html">Let's Build with Elixir and Phoenix</a>
                <span class="crumbs">&rsaquo; Password Hashing</span>
            </div>
            <div>
                &lsaquo; <a href="11.00-authentication.html">Previous</a> &middot;
                <a href="00.01-contents.html">Contents</a>
                &middot; <a href="11.02-user-registration.html">Next</a> &rsaquo;
            </div>
        </div>
    </header>
    <main class="wrapper text">
        <div class="chapter">Chapter 11.1</div>
        <h1>Chapter 11.1: Password Hashing</h1>

<p>Secure password storage is fundamental to authentication. In this chapter, we'll explore password hashing algorithms and their implementation.</p>

<h2>Why Hash Passwords?</h2>

<p>If passwords are stored in plaintext:</p>

<figure class="code"><pre><code>Database breach → All passwords exposed → Users compromised everywhere
</code></pre></figure>

<p>With proper hashing:</p>

<figure class="code"><pre><code>Database breach → Only hashes exposed → Passwords still protected
</code></pre></figure>

<h2>Hashing vs Encryption</h2>

<p>| | Hashing | Encryption |</p>
<p>|--|---------|------------|</p>
<p>| Direction | One-way | Two-way |</p>
<p>| Reversible | No | Yes (with key) |</p>
<p>| Purpose | Verification | Data protection |</p>
<p>| For passwords | ✅ Yes | ❌ No |</p>

<h2>Recommended Algorithms</h2>

<h3>Argon2 (Recommended)</h3>

<figure class="code"><pre><code># Add to mix.exs
<p>{:argon2_elixir, "~> 3.0"}</p>
</code></pre></figure>

<figure class="code"><pre><code># Hash a password
<p>hash = Argon2.hash_pwd_salt("password123")</p>
<h1>=> "$argon2id$v=19$m=65536,t=3,p=4$..."</h1>

<h1>Verify a password</h1>
<p>Argon2.verify_pass("password123", hash)</p>
<h1>=> true</h1>

<p>Argon2.verify_pass("wrong", hash)</p>
<h1>=> false</h1>
</code></pre></figure>

<h3>Bcrypt (Alternative)</h3>

<figure class="code"><pre><code># Add to mix.exs
<p>{:bcrypt_elixir, "~> 3.0"}</p>
</code></pre></figure>

<figure class="code"><pre><code># Hash a password
<p>hash = Bcrypt.hash_pwd_salt("password123")</p>
<h1>=> "$2b$12$..."</h1>

<h1>Verify a password</h1>
<p>Bcrypt.verify_pass("password123", hash)</p>
<h1>=> true</h1>
</code></pre></figure>

<h2>User Schema</h2>

<figure class="code"><figcaption>File: lib/snippetbox/accounts/user.ex</figcaption><pre><code class="language-elixir">
<p>defmodule Snippetbox.Accounts.User do</p>
<p>  use Ecto.Schema</p>
<p>  import Ecto.Changeset</p>

<p>  schema "users" do</p>
<p>    field :email, :string</p>
<p>    field :name, :string</p>
<p>    field :password, :string, virtual: true, redact: true</p>
<p>    field :hashed_password, :string, redact: true</p>

<p>    timestamps()</p>
<p>  end</p>

<p>  @doc """</p>
<p>  Changeset for user registration.</p>
<p>  """</p>
<p>  def registration_changeset(user, attrs, opts \\ []) do</p>
<p>    user</p>
<p>    |> cast(attrs, [:email, :name, :password])</p>
<p>    |> validate_email()</p>
<p>    |> validate_password(opts)</p>
<p>  end</p>

<p>  defp validate_email(changeset) do</p>
<p>    changeset</p>
<p>    |> validate_required([:email])</p>
<p>    |> validate_format(:email, ~r/^[^\s]+@[^\s]+$/, message: "must be a valid email")</p>
<p>    |> validate_length(:email, max: 160)</p>
<p>    |> unsafe_validate_unique(:email, Snippetbox.Repo)</p>
<p>    |> unique_constraint(:email)</p>
<p>  end</p>

<p>  defp validate_password(changeset, opts) do</p>
<p>    changeset</p>
<p>    |> validate_required([:password])</p>
<p>    |> validate_length(:password, min: 12, max: 72)</p>
<p>    |> validate_password_strength()</p>
<p>    |> maybe_hash_password(opts)</p>
<p>  end</p>

<p>  defp validate_password_strength(changeset) do</p>
<p>    validate_change(changeset, :password, fn :password, password -></p>
<p>      cond do</p>
<p>        not String.match?(password, ~r/[a-z]/) -></p>
<p>          [password: "must contain a lowercase letter"]</p>
<p>        not String.match?(password, ~r/[A-Z]/) -></p>
<p>          [password: "must contain an uppercase letter"]</p>
<p>        not String.match?(password, ~r/[0-9]/) -></p>
<p>          [password: "must contain a number"]</p>
<p>        true -></p>
<p>          []</p>
<p>      end</p>
<p>    end)</p>
<p>  end</p>

<p>  defp maybe_hash_password(changeset, opts) do</p>
<p>    hash_password? = Keyword.get(opts, :hash_password, true)</p>
<p>    password = get_change(changeset, :password)</p>

<p>    if hash_password? && password && changeset.valid? do</p>
<p>      changeset</p>
<p>      |> validate_length(:password, max: 72, count: :bytes)</p>
<p>      |> put_change(:hashed_password, Argon2.hash_pwd_salt(password))</p>
<p>      |> delete_change(:password)</p>
<p>    else</p>
<p>      changeset</p>
<p>    end</p>
<p>  end</p>

<p>  @doc """</p>
<p>  Verifies the password against the hashed password.</p>
<p>  """</p>
<p>  def valid_password?(%__MODULE__{hashed_password: hashed_password}, password)</p>
<p>      when is_binary(hashed_password) and byte_size(password) > 0 do</p>
<p>    Argon2.verify_pass(password, hashed_password)</p>
<p>  end</p>

<p>  def valid_password?(_, _) do</p>
<p>    # Prevent timing attacks by always running hash</p>
<p>    Argon2.no_user_verify()</p>
<p>    false</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Migration</h2>

<figure class="code"><figcaption>File: priv/repo/migrations/YYYYMMDDHHMMSS_create_users.exs</figcaption><pre><code class="language-elixir">
<p>defmodule Snippetbox.Repo.Migrations.CreateUsers do</p>
<p>  use Ecto.Migration</p>

<p>  def change do</p>
<p>    create table(:users) do</p>
<p>      add :email, :citext, null: false</p>
<p>      add :name, :string, null: false</p>
<p>      add :hashed_password, :string, null: false</p>

<p>      timestamps()</p>
<p>    end</p>

<p>    create unique_index(:users, [:email])</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<p>Enable citext extension:</p>

<figure class="code"><figcaption>File: priv/repo/migrations/YYYYMMDDHHMMSS_enable_citext.exs</figcaption><pre><code class="language-elixir">
<p>defmodule Snippetbox.Repo.Migrations.EnableCitext do</p>
<p>  use Ecto.Migration</p>

<p>  def change do</p>
<p>    execute "CREATE EXTENSION IF NOT EXISTS citext", ""</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Password Hashing Options</h2>

<h3>Argon2 Configuration</h3>

<figure class="code"><pre><code># config/config.exs
<p>config :argon2_elixir,</p>
<p>  t_cost: 3,        # Time cost (iterations)</p>
<p>  m_cost: 16,       # Memory cost (2^16 = 64MB)</p>
<p>  parallelism: 4    # Parallel threads</p>
</code></pre></figure>

<h3>Bcrypt Configuration</h3>

<figure class="code"><pre><code># config/config.exs
<p>config :bcrypt_elixir,</p>
<p>  log_rounds: 12    # 2^12 iterations</p>
</code></pre></figure>

<h3>Development vs Production</h3>

<figure class="code"><pre><code># config/test.exs - Faster for tests
<p>config :argon2_elixir,</p>
<p>  t_cost: 1,</p>
<p>  m_cost: 8</p>

<h1>config/prod.exs - Stronger for production</h1>
<p>config :argon2_elixir,</p>
<p>  t_cost: 4,</p>
<p>  m_cost: 17,</p>
<p>  parallelism: 4</p>
</code></pre></figure>

<h2>Timing Attack Prevention</h2>

<h3>The Problem</h3>

<figure class="code"><pre><code># VULNERABLE - timing leak
<p>def authenticate(email, password) do</p>
<p>  user = Repo.get_by(User, email: email)</p>

<p>  if user && Argon2.verify_pass(password, user.hashed_password) do</p>
<p>    {:ok, user}</p>
<p>  else</p>
<p>    {:error, :invalid_credentials}</p>
<p>  end</p>
<p>end</p>
<h1>If no user exists, returns immediately</h1>
<h1>Attacker can detect which emails exist</h1>
</code></pre></figure>

<h3>The Solution</h3>

<figure class="code"><pre><code># SECURE - constant time
<p>def authenticate(email, password) do</p>
<p>  user = Repo.get_by(User, email: email)</p>

<p>  if user do</p>
<p>    if Argon2.verify_pass(password, user.hashed_password) do</p>
<p>      {:ok, user}</p>
<p>    else</p>
<p>      {:error, :invalid_credentials}</p>
<p>    end</p>
<p>  else</p>
<p>    # Run hash anyway to prevent timing attack</p>
<p>    Argon2.no_user_verify()</p>
<p>    {:error, :invalid_credentials}</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Password Change</h2>

<figure class="code"><figcaption>File: lib/snippetbox/accounts/user.ex</figcaption><pre><code class="language-elixir">
<p>def password_changeset(user, attrs, opts \\ []) do</p>
<p>  user</p>
<p>  |> cast(attrs, [:password])</p>
<p>  |> validate_required([:password])</p>
<p>  |> validate_length(:password, min: 12, max: 72)</p>
<p>  |> validate_password_strength()</p>
<p>  |> maybe_hash_password(opts)</p>
<p>end</p>

<p>def validate_current_password(changeset, current_password) do</p>
<p>  if valid_password?(changeset.data, current_password) do</p>
<p>    changeset</p>
<p>  else</p>
<p>    add_error(changeset, :current_password, "is not valid")</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Context Functions</h2>

<figure class="code"><figcaption>File: lib/snippetbox/accounts.ex</figcaption><pre><code class="language-elixir">
<p>defmodule Snippetbox.Accounts do</p>
<p>  alias Snippetbox.Repo</p>
<p>  alias Snippetbox.Accounts.User</p>

<p>  @doc """</p>
<p>  Creates a new user.</p>
<p>  """</p>
<p>  def register_user(attrs) do</p>
<p>    %User{}</p>
<p>    |> User.registration_changeset(attrs)</p>
<p>    |> Repo.insert()</p>
<p>  end</p>

<p>  @doc """</p>
<p>  Authenticates a user by email and password.</p>
<p>  """</p>
<p>  def authenticate_by_email_and_password(email, password) do</p>
<p>    user = Repo.get_by(User, email: email)</p>

<p>    cond do</p>
<p>      user && User.valid_password?(user, password) -></p>
<p>        {:ok, user}</p>
<p>      user -></p>
<p>        {:error, :invalid_password}</p>
<p>      true -></p>
<p>        Argon2.no_user_verify()</p>
<p>        {:error, :user_not_found}</p>
<p>    end</p>
<p>  end</p>

<p>  @doc """</p>
<p>  Changes user password.</p>
<p>  """</p>
<p>  def update_user_password(user, current_password, attrs) do</p>
<p>    changeset =</p>
<p>      user</p>
<p>      |> User.password_changeset(attrs)</p>
<p>      |> User.validate_current_password(current_password)</p>

<p>    Repo.update(changeset)</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Testing Password Hashing</h2>

<figure class="code"><figcaption>File: test/snippetbox/accounts/user_test.exs</figcaption><pre><code class="language-elixir">
<p>defmodule Snippetbox.Accounts.UserTest do</p>
<p>  use Snippetbox.DataCase</p>

<p>  alias Snippetbox.Accounts.User</p>

<p>  describe "registration_changeset/2" do</p>
<p>    test "hashes password" do</p>
<p>      changeset = User.registration_changeset(%User{}, %{</p>
<p>        email: "test@example.com",</p>
<p>        name: "Test",</p>
<p>        password: "ValidPass123!"</p>
<p>      })</p>

<p>      assert changeset.valid?</p>
<p>      assert changeset.changes.hashed_password</p>
<p>      refute Map.has_key?(changeset.changes, :password)</p>
<p>    end</p>

<p>    test "requires minimum password length" do</p>
<p>      changeset = User.registration_changeset(%User{}, %{</p>
<p>        email: "test@example.com",</p>
<p>        password: "short"</p>
<p>      })</p>

<p>      refute changeset.valid?</p>
<p>      assert "should be at least 12 character(s)" in errors_on(changeset).password</p>
<p>    end</p>
<p>  end</p>

<p>  describe "valid_password?/2" do</p>
<p>    test "validates correct password" do</p>
<p>      user = user_fixture()</p>
<p>      assert User.valid_password?(user, "ValidPass123!")</p>
<p>    end</p>

<p>    test "rejects incorrect password" do</p>
<p>      user = user_fixture()</p>
<p>      refute User.valid_password?(user, "wrong")</p>
<p>    end</p>

<p>    test "rejects empty password" do</p>
<p>      user = user_fixture()</p>
<p>      refute User.valid_password?(user, "")</p>
<p>    end</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<blockquote class="fp-concept">
<strong>FP Concept: Pure Password Verification</strong>
</blockquote>
<p>></p>
<blockquote>
<p>Password verification is a pure function:</p>
</blockquote>
<p>></p>
<blockquote>
<figure class="code"><pre><code>> valid_password?(user, password) :: boolean()
</blockquote>
<p>></p>
<blockquote>
<p># Same inputs → same output</p>
<p># No side effects</p>
<p># Easy to test</p>
</code></pre></figure>
</blockquote>
<p>></p>
<blockquote>
<p>The hashing is done at write time; verification is a simple comparison.</p>
</blockquote>

<h2>Summary</h2>

<p>In this chapter, we learned:</p>

<ul>
<li>Why passwords must be hashed</li>
<li>Argon2 vs Bcrypt algorithms</li>
<li>Implementing password hashing in schemas</li>
<li>Password validation rules</li>
<li>Timing attack prevention</li>
<li>Password change functionality</li>
<li>Testing password hashing</li>
</ul>

<p>In the next chapter, we'll implement user registration.</p>

    </main>
    <footer>
        <div class="wrapper">
            <div>
                &lsaquo; <a href="11.00-authentication.html">Previous</a>
            </div>
            <div>
                <a href="00.01-contents.html">Contents</a>
            </div>
            <div>
                <a href="11.02-user-registration.html">Next</a> &rsaquo;
            </div>
        </div>
    </footer>
</body>
</html>
