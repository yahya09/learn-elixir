# Chapter 6.1: Understanding Plugs

Plugs are the foundation of Phoenix's request handling. In this chapter, we'll understand the Plug specification and how the connection struct works.

## The Plug Specification

A plug must implement one of two patterns:

### Function Plug

```elixir
def my_plug(conn, opts) do
  # Transform conn
  conn
end
```

### Module Plug

```elixir
defmodule MyPlug do
  @behaviour Plug

  @impl true
  def init(opts) do
    # Called at compile time
    # Process options and return them
    opts
  end

  @impl true
  def call(conn, opts) do
    # Called at runtime for every request
    # Transform and return conn
    conn
  end
end
```

## The Connection Struct

`Plug.Conn` carries all request and response data:

```elixir
%Plug.Conn{
  # Request data (read-only)
  host: "localhost",
  port: 4000,
  method: "GET",
  path_info: ["snippets", "123"],
  request_path: "/snippets/123",
  query_string: "format=json",
  req_headers: [{"accept", "text/html"}, ...],
  remote_ip: {127, 0, 0, 1},
  scheme: :http,

  # Parameters (merged)
  params: %{"id" => "123", "format" => "json"},
  path_params: %{"id" => "123"},
  query_params: %{"format" => "json"},
  body_params: %{},

  # Assigns (your data)
  assigns: %{},

  # Response data (mutable through functions)
  status: nil,
  resp_headers: [{"cache-control", "max-age=0, private, must-revalidate"}],
  resp_body: nil,
  state: :unset,

  # Private data (Phoenix internal)
  private: %{
    phoenix_action: :show,
    phoenix_controller: SnippetController,
    phoenix_endpoint: SnippetboxWeb.Endpoint,
    phoenix_format: "html",
    phoenix_router: SnippetboxWeb.Router,
    ...
  }
}
```

## Reading from the Connection

```elixir
def my_plug(conn, _opts) do
  # Read request info
  method = conn.method                    # "GET"
  path = conn.request_path                # "/snippets/123"
  host = conn.host                        # "localhost"

  # Read headers
  [user_agent | _] = get_req_header(conn, "user-agent")

  # Read params
  id = conn.params["id"]                  # "123"

  # Read assigns
  user = conn.assigns[:current_user]      # nil or %User{}

  conn
end
```

## Modifying the Connection

All modifications return a **new** connection:

```elixir
def my_plug(conn, _opts) do
  conn
  |> assign(:request_time, DateTime.utc_now())
  |> put_resp_header("x-custom", "value")
  |> put_status(200)
end
```

### Common Modification Functions

```elixir
# Assigns (your custom data)
conn = assign(conn, :key, value)
conn = merge_assigns(conn, %{key1: val1, key2: val2})

# Response headers
conn = put_resp_header(conn, "x-custom", "value")
conn = delete_resp_header(conn, "x-frame-options")
conn = put_resp_content_type(conn, "application/json")

# Status
conn = put_status(conn, :ok)        # 200
conn = put_status(conn, :not_found) # 404
conn = put_status(conn, 418)        # I'm a teapot

# Response body
conn = resp(conn, 200, "body")      # Set body
conn = send_resp(conn)              # Send response

# Sessions
conn = put_session(conn, :user_id, 123)
user_id = get_session(conn, :user_id)
conn = delete_session(conn, :user_id)
conn = clear_session(conn)

# Flash
conn = put_flash(conn, :info, "Success!")
conn = put_flash(conn, :error, "Failed!")
```

## Halting the Pipeline

Use `halt/1` to stop plug execution:

```elixir
def require_admin(conn, _opts) do
  if conn.assigns[:current_user]&.admin do
    conn  # Continue to next plug
  else
    conn
    |> put_status(:forbidden)
    |> put_view(SnippetboxWeb.ErrorHTML)
    |> render("403.html")
    |> halt()  # Stop pipeline!
  end
end
```

After `halt()`, no more plugs run, but the response is sent.

## Plug Execution Flow

```elixir
# Pipeline
plug :plug_a
plug :plug_b
plug :plug_c

# Execution without halt
Request → plug_a → plug_b → plug_c → Controller

# Execution with halt in plug_b
Request → plug_a → plug_b (halt) → Response
                      ↓
                (plug_c never runs)
```

## Simple Plug Examples

### Logging Plug

```elixir
def log_request(conn, _opts) do
  IO.puts("#{conn.method} #{conn.request_path}")
  conn
end
```

### Timing Plug

```elixir
def request_timer(conn, _opts) do
  start = System.monotonic_time()

  Plug.Conn.register_before_send(conn, fn conn ->
    stop = System.monotonic_time()
    diff = System.convert_time_unit(stop - start, :native, :millisecond)
    IO.puts("Request completed in #{diff}ms")
    conn
  end)
end
```

### User Agent Plug

```elixir
def assign_user_agent(conn, _opts) do
  ua = case get_req_header(conn, "user-agent") do
    [ua | _] -> ua
    _ -> "unknown"
  end

  assign(conn, :user_agent, ua)
end
```

## The Conn Lifecycle

```
1. conn.state = :unset
   (Initial state, no response set)

2. conn.state = :set
   (Response set but not sent: resp/3, put_resp_*)

3. conn.state = :sent
   (Response sent: send_resp/1)

4. conn.state = :chunked
   (Streaming response)
```

Check state before operations:

```elixir
def my_plug(conn, _opts) do
  if conn.state == :sent do
    # Response already sent, can't modify
    conn
  else
    put_resp_header(conn, "x-custom", "value")
  end
end
```

> **FP Concept: Immutable Transformations**
>
> The conn is never mutated - each function returns a new conn:
>
> ```elixir
> conn1 = assign(conn, :a, 1)
> conn2 = assign(conn1, :b, 2)  # conn1 unchanged!
> conn3 = put_status(conn2, 200)
>
> # Or with pipe
> conn
> |> assign(:a, 1)
> |> assign(:b, 2)
> |> put_status(200)
> ```
>
> Benefits:
> - No side effects during transformation
> - Easy to trace data flow
> - Thread-safe (important for concurrent requests)
>
> **Further Reading**:
> - [Plug.Conn](https://hexdocs.pm/plug/Plug.Conn.html)

## Summary

In this chapter, we learned:

- The Plug specification (function and module)
- The connection struct and its fields
- Reading request data
- Modifying response data
- Halting the pipeline
- The connection lifecycle

In the next chapter, we'll explore Phoenix router pipelines.
