# Chapter 11.5: Password Reset

Users forget passwords. In this chapter, we'll implement a secure password reset flow via email.

## Password Reset Flow

```
1. User requests reset on /forgot-password
2. Server generates secure token
3. Token emailed to user
4. User clicks link with token
5. User sets new password
6. Token invalidated, user logged in
```

## Token Generation

```elixir
# File: lib/snippetbox/accounts/user_token.ex

@reset_password_validity_in_days 1

@doc """
Builds a token with a hashed counter part.

The non-hashed token is sent to the user email while the
hashed part is stored in the database. The original token cannot
be reconstructed, making it safer for storage.
"""
def build_email_token(user, context) do
  build_hashed_token(user, context, user.email)
end

defp build_hashed_token(user, context, sent_to) do
  token = :crypto.strong_rand_bytes(@rand_size)
  hashed_token = :crypto.hash(@hash_algorithm, token)

  {Base.url_encode64(token, padding: false),
   %__MODULE__{
     token: hashed_token,
     context: context,
     sent_to: sent_to,
     user_id: user.id
   }}
end

@doc """
Checks if the token is valid and returns its underlying lookup query.
"""
def verify_email_token_query(token, context) do
  case Base.url_decode64(token, padding: false) do
    {:ok, decoded_token} ->
      hashed_token = :crypto.hash(@hash_algorithm, decoded_token)
      days = days_for_context(context)

      query =
        from token in by_token_and_context_query(hashed_token, context),
          join: user in assoc(token, :user),
          where: token.inserted_at > ago(^days, "day") and token.sent_to == user.email,
          select: user

      {:ok, query}

    :error ->
      :error
  end
end

defp days_for_context("reset_password"), do: @reset_password_validity_in_days
defp days_for_context("confirm"), do: @confirm_validity_in_days
```

## Context Functions

```elixir
# File: lib/snippetbox/accounts.ex

@doc """
Delivers the reset password email to the given user.
"""
def deliver_user_reset_password_instructions(user, reset_password_url_fun)
    when is_function(reset_password_url_fun, 1) do
  {encoded_token, user_token} = UserToken.build_email_token(user, "reset_password")
  Repo.insert!(user_token)
  UserNotifier.deliver_reset_password_instructions(user, reset_password_url_fun.(encoded_token))
end

@doc """
Gets the user by reset password token.
"""
def get_user_by_reset_password_token(token) do
  with {:ok, query} <- UserToken.verify_email_token_query(token, "reset_password"),
       %User{} = user <- Repo.one(query) do
    user
  else
    _ -> nil
  end
end

@doc """
Resets the user password.
"""
def reset_user_password(user, attrs) do
  Ecto.Multi.new()
  |> Ecto.Multi.update(:user, User.password_changeset(user, attrs))
  |> Ecto.Multi.delete_all(:tokens, UserToken.by_user_and_contexts_query(user, :all))
  |> Repo.transaction()
  |> case do
    {:ok, %{user: user}} -> {:ok, user}
    {:error, :user, changeset, _} -> {:error, changeset}
  end
end
```

## Email Notifier

```elixir
# File: lib/snippetbox/accounts/user_notifier.ex

defmodule Snippetbox.Accounts.UserNotifier do
  import Swoosh.Email

  alias Snippetbox.Mailer

  defp deliver(recipient, subject, body) do
    email =
      new()
      |> to(recipient)
      |> from({"Snippetbox", "noreply@snippetbox.com"})
      |> subject(subject)
      |> text_body(body)

    with {:ok, _metadata} <- Mailer.deliver(email) do
      {:ok, email}
    end
  end

  @doc """
  Deliver instructions to reset a user password.
  """
  def deliver_reset_password_instructions(user, url) do
    deliver(user.email, "Reset your password", """
    Hi #{user.name},

    You can reset your password by visiting the URL below:

    #{url}

    If you didn't request this change, please ignore this email.

    This link will expire in 24 hours.
    """)
  end
end
```

## Controllers

### Forgot Password

```elixir
# File: lib/snippetbox_web/controllers/user_reset_password_controller.ex

defmodule SnippetboxWeb.UserResetPasswordController do
  use SnippetboxWeb, :controller

  alias Snippetbox.Accounts

  plug :get_user_by_reset_password_token when action in [:edit, :update]

  def new(conn, _params) do
    render(conn, :new)
  end

  def create(conn, %{"user" => %{"email" => email}}) do
    if user = Accounts.get_user_by_email(email) do
      Accounts.deliver_user_reset_password_instructions(
        user,
        &url(~p"/reset-password/#{&1}")
      )
    end

    # Always show same message to prevent email enumeration
    conn
    |> put_flash(:info, "If your email is in our system, you will receive password reset instructions shortly.")
    |> redirect(to: ~p"/")
  end

  def edit(conn, _params) do
    render(conn, :edit, changeset: Accounts.change_user_password(conn.assigns.user))
  end

  def update(conn, %{"user" => user_params}) do
    case Accounts.reset_user_password(conn.assigns.user, user_params) do
      {:ok, _} ->
        conn
        |> put_flash(:info, "Password reset successfully.")
        |> redirect(to: ~p"/login")

      {:error, changeset} ->
        render(conn, :edit, changeset: changeset)
    end
  end

  defp get_user_by_reset_password_token(conn, _opts) do
    %{"token" => token} = conn.params

    if user = Accounts.get_user_by_reset_password_token(token) do
      conn |> assign(:user, user) |> assign(:token, token)
    else
      conn
      |> put_flash(:error, "Reset password link is invalid or has expired.")
      |> redirect(to: ~p"/")
      |> halt()
    end
  end
end
```

## Templates

### Request Reset Form

```heex
<%# File: lib/snippetbox_web/controllers/user_reset_password_html/new.html.heex %>

<div class="mx-auto max-w-md">
  <.header class="text-center">
    Forgot your password?
    <:subtitle>We'll send you a link to reset it</:subtitle>
  </.header>

  <.form for={%{}} action={~p"/forgot-password"} as={:user} class="mt-8">
    <.input name="email" type="email" label="Email" required />

    <.button class="mt-6 w-full">Send reset instructions</.button>
  </.form>

  <p class="mt-4 text-center text-sm text-gray-600">
    <.link href={~p"/login"} class="text-brand hover:underline">
      Back to login
    </.link>
  </p>
</div>
```

### Reset Password Form

```heex
<%# File: lib/snippetbox_web/controllers/user_reset_password_html/edit.html.heex %>

<div class="mx-auto max-w-md">
  <.header class="text-center">
    Reset Password
    <:subtitle>Enter your new password below</:subtitle>
  </.header>

  <.form for={@changeset} action={~p"/reset-password/#{@token}"} class="mt-8">
    <.error :if={@changeset.action}>
      Oops, something went wrong! Please check the errors below.
    </.error>

    <div class="space-y-4">
      <.input field={@form[:password]} type="password" label="New password" required />
      <.input
        field={@form[:password_confirmation]}
        type="password"
        label="Confirm new password"
        required
      />
    </div>

    <.button class="mt-6 w-full">Reset password</.button>
  </.form>
</div>
```

## Router

```elixir
# File: lib/snippetbox_web/router.ex

scope "/", SnippetboxWeb do
  pipe_through [:browser, :redirect_if_user_is_authenticated]

  get "/forgot-password", UserResetPasswordController, :new
  post "/forgot-password", UserResetPasswordController, :create
  get "/reset-password/:token", UserResetPasswordController, :edit
  put "/reset-password/:token", UserResetPasswordController, :update
end
```

## Security Measures

### Token Expiration

```elixir
# Tokens expire after 24 hours
@reset_password_validity_in_days 1
```

### One-Time Use

```elixir
# Delete all tokens after password reset
def reset_user_password(user, attrs) do
  Ecto.Multi.new()
  |> Ecto.Multi.update(:user, User.password_changeset(user, attrs))
  |> Ecto.Multi.delete_all(:tokens, UserToken.by_user_and_contexts_query(user, :all))
  |> Repo.transaction()
end
```

### Rate Limiting

```elixir
plug :rate_limit_reset_request when action == :create

defp rate_limit_reset_request(conn, _opts) do
  email = conn.params["user"]["email"]
  key = "password_reset:#{email}"

  case Hammer.check_rate(key, 3600_000, 3) do  # 3 per hour
    {:allow, _} -> conn
    {:deny, _} ->
      conn
      |> put_flash(:info, "If your email is in our system, you will receive instructions.")
      |> redirect(to: ~p"/")
      |> halt()
  end
end
```

### Email Enumeration Prevention

```elixir
def create(conn, %{"user" => %{"email" => email}}) do
  # Always do the lookup
  if user = Accounts.get_user_by_email(email) do
    Accounts.deliver_user_reset_password_instructions(user, &url(~p"/reset-password/#{&1}"))
  end

  # Always show same message - prevents email enumeration
  conn
  |> put_flash(:info, "If your email is in our system, you will receive instructions shortly.")
  |> redirect(to: ~p"/")
end
```

## Testing Password Reset

```elixir
# File: test/snippetbox_web/controllers/user_reset_password_controller_test.exs

defmodule SnippetboxWeb.UserResetPasswordControllerTest do
  use SnippetboxWeb.ConnCase

  alias Snippetbox.Accounts
  import Snippetbox.AccountsFixtures

  setup do
    %{user: user_fixture()}
  end

  describe "POST /forgot-password" do
    test "sends reset email for valid email", %{conn: conn, user: user} do
      conn =
        post(conn, ~p"/forgot-password", %{
          "user" => %{"email" => user.email}
        })

      assert redirected_to(conn) == ~p"/"
      assert Phoenix.Flash.get(conn.assigns.flash, :info) =~ "If your email"
      assert Repo.get_by!(UserToken, user_id: user.id)
    end

    test "does not reveal if email exists", %{conn: conn} do
      conn =
        post(conn, ~p"/forgot-password", %{
          "user" => %{"email" => "unknown@example.com"}
        })

      assert redirected_to(conn) == ~p"/"
      assert Phoenix.Flash.get(conn.assigns.flash, :info) =~ "If your email"
    end
  end

  describe "GET /reset-password/:token" do
    test "renders reset password page", %{conn: conn, user: user} do
      token = extract_reset_token(user)
      conn = get(conn, ~p"/reset-password/#{token}")

      assert html_response(conn, 200) =~ "Reset Password"
    end

    test "redirects for invalid token", %{conn: conn} do
      conn = get(conn, ~p"/reset-password/invalid")

      assert redirected_to(conn) == ~p"/"
      assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ "invalid"
    end
  end

  describe "PUT /reset-password/:token" do
    test "resets password for valid token", %{conn: conn, user: user} do
      token = extract_reset_token(user)

      conn =
        put(conn, ~p"/reset-password/#{token}", %{
          "user" => %{
            "password" => "NewValidPass123!",
            "password_confirmation" => "NewValidPass123!"
          }
        })

      assert redirected_to(conn) == ~p"/login"
      assert Accounts.get_user_by_email_and_password(user.email, "NewValidPass123!")
    end

    test "invalidates token after use", %{conn: conn, user: user} do
      token = extract_reset_token(user)

      put(conn, ~p"/reset-password/#{token}", %{
        "user" => %{
          "password" => "NewValidPass123!",
          "password_confirmation" => "NewValidPass123!"
        }
      })

      # Token should no longer work
      conn = get(conn, ~p"/reset-password/#{token}")
      assert redirected_to(conn) == ~p"/"
    end
  end

  defp extract_reset_token(user) do
    {token, _} = Accounts.UserToken.build_email_token(user, "reset_password")
    token
  end
end
```

> **FP Concept: Secure Token Design**
>
> Password reset uses a split-token pattern:
>
> ```elixir
> # Generate
> token = random_bytes()
> hashed = hash(token)
> store(hashed)
> email(token)
>
> # Verify
> hashed = hash(submitted_token)
> user = lookup(hashed)
> ```
>
> The plaintext token is never storedâ€”only the hash. Even database compromise doesn't expose valid tokens.

## Summary

In this chapter, we learned:

- Password reset flow architecture
- Secure token generation and storage
- Email delivery for reset instructions
- Token validation and expiration
- One-time use token enforcement
- Rate limiting and enumeration prevention
- Testing password reset

In the next chapter, we'll implement email verification.
