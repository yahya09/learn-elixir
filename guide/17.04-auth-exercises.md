# Chapter 17.4: Authentication Exercises

These exercises reinforce concepts from Chapters 9-11 covering sessions, security, and authentication.

## Exercise 1: Custom Session Store

Implement a database-backed session store.

```elixir
# File: lib/snippetbox_web/session/db_store.ex

defmodule SnippetboxWeb.Session.DBStore do
  @behaviour Plug.Session.Store

  # Implement:
  # - init/1
  # - get/3
  # - put/4
  # - delete/3

  # Sessions stored in sessions table with:
  # - id (UUID)
  # - data (binary/JSON)
  # - expires_at (datetime)
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.Session.DBStore do
  @behaviour Plug.Session.Store

  alias Snippetbox.{Repo, Sessions.Session}

  @impl true
  def init(opts) do
    Keyword.get(opts, :table, "sessions")
  end

  @impl true
  def get(_conn, sid, _table) do
    case Repo.get(Session, sid) do
      nil ->
        {nil, %{}}

      session ->
        if DateTime.compare(session.expires_at, DateTime.utc_now()) == :gt do
          {sid, :erlang.binary_to_term(session.data)}
        else
          Repo.delete(session)
          {nil, %{}}
        end
    end
  end

  @impl true
  def put(_conn, nil, data, table) do
    put_new(data, table)
  end

  def put(_conn, sid, data, _table) do
    case Repo.get(Session, sid) do
      nil ->
        put_new(data, sid)

      session ->
        session
        |> Session.changeset(%{data: :erlang.term_to_binary(data)})
        |> Repo.update!()
        sid
    end
  end

  @impl true
  def delete(_conn, sid, _table) do
    case Repo.get(Session, sid) do
      nil -> :ok
      session -> Repo.delete(session)
    end
    :ok
  end

  defp put_new(data, _table) do
    sid = generate_sid()
    expires = DateTime.add(DateTime.utc_now(), 7, :day)

    %Session{}
    |> Session.changeset(%{
      id: sid,
      data: :erlang.term_to_binary(data),
      expires_at: expires
    })
    |> Repo.insert!()

    sid
  end

  defp generate_sid do
    :crypto.strong_rand_bytes(32) |> Base.url_encode64(padding: false)
  end
end
```
</details>

## Exercise 2: Two-Factor Authentication

Implement TOTP-based two-factor authentication.

```elixir
# File: lib/snippetbox/accounts/totp.ex

defmodule Snippetbox.Accounts.TOTP do
  # Implement:
  # - generate_secret/0 - creates new TOTP secret
  # - generate_uri/2 - creates otpauth:// URI for QR code
  # - valid_token?/2 - validates a TOTP token
  # - backup_codes/0 - generates backup codes
end
```

### Hints
- Use the `nimble_totp` library
- Secret should be 20 bytes, base32 encoded
- Allow 30-second window for clock drift

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule Snippetbox.Accounts.TOTP do
  @issuer "Snippetbox"

  def generate_secret do
    NimbleTOTP.secret()
  end

  def generate_uri(secret, user_email) do
    NimbleTOTP.otpauth_uri("#{@issuer}:#{user_email}", secret, issuer: @issuer)
  end

  def valid_token?(secret, token) do
    NimbleTOTP.valid?(secret, token)
  end

  def backup_codes(count \\ 10) do
    for _ <- 1..count do
      :crypto.strong_rand_bytes(4)
      |> Base.encode32(padding: false)
      |> String.downcase()
    end
  end

  def hash_backup_code(code) do
    Bcrypt.hash_pwd_salt(code)
  end

  def valid_backup_code?(code, hashed_codes) do
    Enum.find(hashed_codes, fn hashed ->
      Bcrypt.verify_pass(code, hashed)
    end)
  end
end
```
</details>

## Exercise 3: Password Policy

Create a password policy module with configurable rules.

```elixir
# File: lib/snippetbox/accounts/password_policy.ex

defmodule Snippetbox.Accounts.PasswordPolicy do
  # Implement validation for:
  # - Minimum length (default: 12)
  # - Require uppercase
  # - Require lowercase
  # - Require digit
  # - Require special character
  # - Not in common password list
  # - Not similar to email
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule Snippetbox.Accounts.PasswordPolicy do
  @min_length 12
  @special_chars ~r/[!@#$%^&*(),.?":{}|<>]/

  def validate(password, opts \\ []) do
    email = Keyword.get(opts, :email)

    []
    |> check_length(password)
    |> check_uppercase(password)
    |> check_lowercase(password)
    |> check_digit(password)
    |> check_special(password)
    |> check_common(password)
    |> check_similar_to_email(password, email)
    |> case do
      [] -> :ok
      errors -> {:error, errors}
    end
  end

  defp check_length(errors, password) do
    if String.length(password) >= @min_length do
      errors
    else
      ["must be at least #{@min_length} characters" | errors]
    end
  end

  defp check_uppercase(errors, password) do
    if password =~ ~r/[A-Z]/ do
      errors
    else
      ["must contain at least one uppercase letter" | errors]
    end
  end

  defp check_lowercase(errors, password) do
    if password =~ ~r/[a-z]/ do
      errors
    else
      ["must contain at least one lowercase letter" | errors]
    end
  end

  defp check_digit(errors, password) do
    if password =~ ~r/[0-9]/ do
      errors
    else
      ["must contain at least one digit" | errors]
    end
  end

  defp check_special(errors, password) do
    if password =~ @special_chars do
      errors
    else
      ["must contain at least one special character" | errors]
    end
  end

  defp check_common(errors, password) do
    if password in common_passwords() do
      ["is too common" | errors]
    else
      errors
    end
  end

  defp check_similar_to_email(errors, _password, nil), do: errors
  defp check_similar_to_email(errors, password, email) do
    local_part = email |> String.split("@") |> List.first() |> String.downcase()
    password_lower = String.downcase(password)

    if String.contains?(password_lower, local_part) do
      ["cannot be similar to your email" | errors]
    else
      errors
    end
  end

  defp common_passwords do
    ~w(password123456 123456password qwerty123456 password1234)
  end
end
```
</details>

## Exercise 4: Account Lockout

Implement account lockout after failed login attempts.

```elixir
# File: lib/snippetbox/accounts/lockout.ex

defmodule Snippetbox.Accounts.Lockout do
  # Implement:
  # - record_failed_attempt/1 - records failed login
  # - reset_attempts/1 - clears attempts on success
  # - locked?/1 - checks if account is locked
  # - unlock_at/1 - returns when account unlocks

  # Rules:
  # - Lock after 5 failed attempts
  # - Lock duration increases exponentially
  # - Max lock duration: 24 hours
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule Snippetbox.Accounts.Lockout do
  alias Snippetbox.{Repo, Accounts.User}
  import Ecto.Query

  @max_attempts 5
  @base_lockout_minutes 5
  @max_lockout_minutes 24 * 60

  def record_failed_attempt(user) do
    new_count = (user.failed_attempts || 0) + 1

    updates =
      if new_count >= @max_attempts do
        lockout_minutes = calculate_lockout(new_count)
        locked_until = DateTime.add(DateTime.utc_now(), lockout_minutes, :minute)

        [failed_attempts: new_count, locked_until: locked_until]
      else
        [failed_attempts: new_count]
      end

    user
    |> Ecto.Changeset.change(updates)
    |> Repo.update()
  end

  def reset_attempts(user) do
    user
    |> Ecto.Changeset.change(failed_attempts: 0, locked_until: nil)
    |> Repo.update()
  end

  def locked?(user) do
    case user.locked_until do
      nil -> false
      locked_until -> DateTime.compare(locked_until, DateTime.utc_now()) == :gt
    end
  end

  def unlock_at(user), do: user.locked_until

  def remaining_attempts(user) do
    max(@max_attempts - (user.failed_attempts || 0), 0)
  end

  defp calculate_lockout(attempt_count) do
    # Exponential backoff: 5, 10, 20, 40, 80, 160... minutes
    lockout = @base_lockout_minutes * :math.pow(2, div(attempt_count, @max_attempts))
    min(trunc(lockout), @max_lockout_minutes)
  end
end
```
</details>

## Exercise 5: API Token Authentication

Implement stateless API authentication with tokens.

```elixir
# File: lib/snippetbox_web/plugs/api_auth.ex

defmodule SnippetboxWeb.Plugs.APIAuth do
  # Implement:
  # - Extract token from Authorization header
  # - Validate token format (Bearer scheme)
  # - Verify token signature
  # - Load user from token
  # - Handle expiration
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.Plugs.APIAuth do
  import Plug.Conn
  import Phoenix.Controller

  alias Snippetbox.Accounts

  def init(opts), do: opts

  def call(conn, _opts) do
    with {:ok, token} <- get_token(conn),
         {:ok, user_id} <- verify_token(token),
         user when not is_nil(user) <- Accounts.get_user(user_id) do
      assign(conn, :current_user, user)
    else
      _ ->
        conn
        |> put_status(:unauthorized)
        |> json(%{error: "Invalid or missing authentication token"})
        |> halt()
    end
  end

  defp get_token(conn) do
    case get_req_header(conn, "authorization") do
      ["Bearer " <> token] -> {:ok, token}
      _ -> {:error, :missing_token}
    end
  end

  defp verify_token(token) do
    case Phoenix.Token.verify(
      SnippetboxWeb.Endpoint,
      "api_token",
      token,
      max_age: 86400 * 30  # 30 days
    ) do
      {:ok, user_id} -> {:ok, user_id}
      {:error, _reason} -> {:error, :invalid_token}
    end
  end
end

# Token generation in Accounts context
def generate_api_token(user) do
  Phoenix.Token.sign(SnippetboxWeb.Endpoint, "api_token", user.id)
end
```
</details>

## Exercise 6: OAuth Scope Handling

Implement OAuth scope validation for API endpoints.

```elixir
# File: lib/snippetbox_web/plugs/require_scope.ex

defmodule SnippetboxWeb.Plugs.RequireScope do
  # Implement:
  # - Check if token has required scopes
  # - Support multiple scope requirements (any/all)
  # - Return 403 with missing scopes info

  # Usage:
  # plug RequireScope, scopes: ["snippets:read"]
  # plug RequireScope, scopes: ["snippets:write", "snippets:delete"], match: :any
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.Plugs.RequireScope do
  import Plug.Conn
  import Phoenix.Controller

  def init(opts) do
    %{
      scopes: Keyword.fetch!(opts, :scopes),
      match: Keyword.get(opts, :match, :all)
    }
  end

  def call(conn, %{scopes: required, match: match}) do
    user_scopes = get_user_scopes(conn)

    if has_required_scopes?(user_scopes, required, match) do
      conn
    else
      missing = required -- user_scopes

      conn
      |> put_status(:forbidden)
      |> json(%{
        error: "Insufficient permissions",
        required_scopes: required,
        missing_scopes: missing
      })
      |> halt()
    end
  end

  defp get_user_scopes(conn) do
    case conn.assigns[:token_scopes] do
      nil -> []
      scopes -> scopes
    end
  end

  defp has_required_scopes?(user_scopes, required, :all) do
    Enum.all?(required, &(&1 in user_scopes))
  end

  defp has_required_scopes?(user_scopes, required, :any) do
    Enum.any?(required, &(&1 in user_scopes))
  end
end
```
</details>

## Challenge: Social Login with Multiple Providers

Implement social login supporting:

1. GitHub
2. Google
3. Account linking (one user, multiple providers)
4. Handle email conflicts
5. Profile data sync

Create the full flow from OAuth callback to user creation/linking.

This exercises OAuth, user management, and conflict resolution.
