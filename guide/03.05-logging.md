# Chapter 3.5: Logging

Logging is essential for debugging, monitoring, and understanding your application's behavior. In this chapter, we'll explore Elixir's built-in Logger and Phoenix's logging capabilities.

## Elixir's Logger

Elixir includes a powerful logging system out of the box:

```elixir
require Logger

Logger.debug("Debugging information")
Logger.info("Something happened")
Logger.warning("Watch out for this")  # Note: warning, not warn
Logger.error("Something went wrong")
```

## Log Levels

Logger supports four levels (from least to most severe):

| Level | Use For |
|-------|---------|
| `:debug` | Detailed diagnostic information |
| `:info` | General operational messages |
| `:warning` | Potential issues that aren't errors |
| `:error` | Errors that need attention |

```elixir
require Logger

# Debug: Verbose info for development
Logger.debug("Processing snippet #{id} with params: #{inspect(params)}")

# Info: Normal operations
Logger.info("User #{user.id} created snippet #{snippet.id}")

# Warning: Something unusual
Logger.warning("Rate limit approaching for IP #{ip}")

# Error: Something failed
Logger.error("Failed to send email: #{inspect(reason)}")
```

## Logger Configuration

### Development

```elixir
# File: config/dev.exs

# Show all logs including debug
config :logger, :console,
  format: "[$level] $message\n",
  level: :debug
```

### Production

```elixir
# File: config/prod.exs

# Only info and above (no debug)
config :logger,
  level: :info

config :logger, :console,
  format: "$time $metadata[$level] $message\n",
  metadata: [:request_id, :user_id]
```

### Test

```elixir
# File: config/test.exs

# Only warnings and errors (quiet tests)
config :logger, level: :warning
```

## Log Formats

### Custom Format

```elixir
# File: config/config.exs

config :logger, :console,
  format: "$time $metadata[$level] $message\n",
  metadata: [:request_id, :module, :function, :line]
```

Format variables:
- `$time` - Timestamp
- `$date` - Date
- `$level` - Log level
- `$message` - Log message
- `$metadata` - Metadata key-value pairs
- `$node` - Node name

### JSON Format for Production

```elixir
# File: mix.exs
defp deps do
  [{:logger_json, "~> 5.1"}]
end

# File: config/prod.exs
config :logger, backends: [LoggerJSON]

config :logger_json, :backend,
  metadata: [:request_id, :user_id, :module]
```

Output:
```json
{"time":"2024-01-15T10:30:00.000Z","level":"info","message":"User logged in","request_id":"abc123","user_id":42}
```

## Logging in Phoenix

### Request Logging

Phoenix logs requests automatically:

```
[info] GET /snippets
[info] Sent 200 in 15ms
```

Configure request logging:

```elixir
# File: lib/snippetbox_web/endpoint.ex

plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

# Or disable request logging
# plug Plug.Logger, log: false
```

### Controller Logging

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

defmodule SnippetboxWeb.SnippetController do
  use SnippetboxWeb, :controller

  require Logger

  def show(conn, %{"id" => id}) do
    Logger.info("Fetching snippet", snippet_id: id)

    snippet = Snippets.get_snippet!(id)

    Logger.debug("Snippet retrieved",
      snippet_id: snippet.id,
      title: snippet.title,
      size: byte_size(snippet.content)
    )

    render(conn, :show, snippet: snippet)
  end

  def create(conn, %{"snippet" => params}) do
    case Snippets.create_snippet(params) do
      {:ok, snippet} ->
        Logger.info("Snippet created",
          snippet_id: snippet.id,
          user_id: conn.assigns[:current_user]&.id
        )
        redirect(conn, to: ~p"/snippets/#{snippet}")

      {:error, changeset} ->
        Logger.warning("Snippet creation failed",
          errors: inspect(changeset.errors)
        )
        render(conn, :new, changeset: changeset)
    end
  end
end
```

### Context Logging

```elixir
# File: lib/snippetbox/snippets.ex

defmodule Snippetbox.Snippets do
  require Logger

  def create_snippet(attrs) do
    Logger.debug("Creating snippet with attrs: #{inspect(attrs)}")

    result =
      %Snippet{}
      |> Snippet.changeset(attrs)
      |> Repo.insert()

    case result do
      {:ok, snippet} ->
        Logger.info("Snippet created: #{snippet.id}")
      {:error, changeset} ->
        Logger.warning("Failed to create snippet: #{inspect(changeset.errors)}")
    end

    result
  end
end
```

## Metadata

Add contextual information to logs:

### Request Metadata

```elixir
# File: lib/snippetbox_web/plugs/logger_metadata.ex

defmodule SnippetboxWeb.Plugs.LoggerMetadata do
  @behaviour Plug

  def init(opts), do: opts

  def call(conn, _opts) do
    Logger.metadata(
      request_id: conn.assigns[:request_id],
      remote_ip: format_ip(conn.remote_ip),
      user_agent: get_user_agent(conn)
    )

    conn
  end

  defp format_ip({a, b, c, d}), do: "#{a}.#{b}.#{c}.#{d}"
  defp format_ip(ip), do: inspect(ip)

  defp get_user_agent(conn) do
    case Plug.Conn.get_req_header(conn, "user-agent") do
      [ua | _] -> ua
      _ -> "unknown"
    end
  end
end
```

Add to your endpoint:

```elixir
# File: lib/snippetbox_web/endpoint.ex

plug Plug.RequestId
plug SnippetboxWeb.Plugs.LoggerMetadata
```

### User Metadata

```elixir
# In authentication plug
def call(conn, _opts) do
  user = get_current_user(conn)

  if user do
    Logger.metadata(user_id: user.id, user_email: user.email)
    assign(conn, :current_user, user)
  else
    conn
  end
end
```

## Structured Logging

Log with structured data:

```elixir
require Logger

# With keyword list metadata
Logger.info("User action",
  action: "login",
  user_id: 123,
  ip: "192.168.1.1",
  duration_ms: 45
)

# In JSON format, outputs:
# {"message":"User action","action":"login","user_id":123,"ip":"192.168.1.1","duration_ms":45}
```

### Logging Complex Data

```elixir
# Safe inspection
Logger.debug("Params received: #{inspect(params, pretty: true, limit: 1000)}")

# Truncate large data
Logger.debug("Large data: #{inspect(data, limit: 100)}")

# Avoid logging sensitive data
def log_user(user) do
  safe_user = Map.take(user, [:id, :email, :name])
  Logger.info("User: #{inspect(safe_user)}")
end
```

## Performance Considerations

### Lazy Evaluation

Logger evaluates messages lazily:

```elixir
# Good: Only evaluated if debug level is enabled
Logger.debug(fn -> "Expensive computation: #{expensive_function()}" end)

# Bad: Always evaluated, even if debug is disabled
Logger.debug("Expensive computation: #{expensive_function()}")
```

### Compile-Time Removal

```elixir
# File: config/prod.exs

# Remove debug logs at compile time
config :logger,
  compile_time_purge_matching: [
    [level_lower_than: :info]
  ]
```

This removes debug log calls from compiled code entirely.

## Log Backends

### Console Backend (Default)

```elixir
config :logger, :console,
  format: "$time [$level] $message\n",
  colors: [enabled: true]
```

### File Backend

```elixir
# File: mix.exs
defp deps do
  [{:logger_file_backend, "~> 0.0.13"}]
end

# File: config/prod.exs
config :logger,
  backends: [:console, {LoggerFileBackend, :file_log}]

config :logger, :file_log,
  path: "/var/log/snippetbox/app.log",
  level: :info,
  format: "$dateT$time [$level] $message\n"
```

### External Services

```elixir
# Papertrail
{:logger_papertrail_backend, "~> 1.1"}

# Datadog
{:logger_datadog, "~> 0.1"}

# AWS CloudWatch
{:ex_aws_cloudwatch, "~> 2.0"}
```

## Debugging with Logger

### Temporary Debug Logging

```elixir
def problematic_function(data) do
  # Add temporary debug
  Logger.debug(">>> DEBUG: Entering problematic_function")
  Logger.debug(">>> DEBUG: data = #{inspect(data)}")

  result = process(data)

  Logger.debug(">>> DEBUG: result = #{inspect(result)}")
  result
end
```

### IEx Debugging

```elixir
# In IEx, change log level at runtime
Logger.configure(level: :debug)

# Or for a specific backend
Logger.configure_backend(:console, level: :debug)
```

### Tracing with Logger

```elixir
defmodule Snippetbox.Tracer do
  require Logger

  defmacro trace(message, do: block) do
    quote do
      start = System.monotonic_time(:microsecond)
      Logger.debug("START: #{unquote(message)}")

      result = unquote(block)

      duration = System.monotonic_time(:microsecond) - start
      Logger.debug("END: #{unquote(message)} (#{duration}μs)")

      result
    end
  end
end

# Usage
import Snippetbox.Tracer

trace "database query" do
  Repo.all(Snippet)
end

# Output:
# [debug] START: database query
# [debug] END: database query (1234μs)
```

## Phoenix Telemetry Events

Phoenix emits telemetry events you can log:

```elixir
# File: lib/snippetbox_web/telemetry.ex

defmodule SnippetboxWeb.Telemetry do
  require Logger

  def handle_event([:phoenix, :router_dispatch, :stop], measurements, metadata, _config) do
    Logger.info("Request processed",
      route: metadata.route,
      method: metadata.conn.method,
      status: metadata.conn.status,
      duration_ms: System.convert_time_unit(measurements.duration, :native, :millisecond)
    )
  end
end
```

Attach in application startup:

```elixir
# File: lib/snippetbox/application.ex

def start(_type, _args) do
  :telemetry.attach(
    "snippetbox-phoenix-logger",
    [:phoenix, :router_dispatch, :stop],
    &SnippetboxWeb.Telemetry.handle_event/4,
    nil
  )

  # ...
end
```

> **FP Concept: Pure Logging**
>
> In functional programming, we try to keep functions pure (no side effects). Logging is a side effect, but Elixir handles it gracefully:
>
> ```elixir
> # Logger is a separate process
> Logger.info("Message")  # Sends message to Logger process
> ```
>
> Benefits:
> - **Non-blocking**: Logging doesn't slow down your code
> - **Buffered**: Messages are batched for efficiency
> - **Isolated**: Logger failures don't crash your app
>
> The Logger process handles all the I/O, keeping your functions focused on logic.
>
> **Further Reading**:
> - [Elixir Logger](https://hexdocs.pm/logger/Logger.html)
> - [Logger Backends](https://hexdocs.pm/logger/Logger.html#module-backends)

## Summary

In this chapter, we learned:

- Using Elixir's Logger with different levels
- Configuring logging for different environments
- Adding metadata for context
- Structured logging for better analysis
- Performance considerations
- Different log backends
- Debugging techniques

This completes the Configuration and Error Handling chapter. In the next chapter, we'll start working with databases using Ecto.

---

## Additional Information

### Log Rotation

For file-based logging in production:

```elixir
config :logger, :file_log,
  path: "/var/log/snippetbox/app.log",
  rotate: %{max_bytes: 10_485_760, keep: 5}  # 10MB, keep 5 files
```

Or use logrotate on Linux:

```
# /etc/logrotate.d/snippetbox
/var/log/snippetbox/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
}
```

### Comparing to Other Frameworks

**Rails (Ruby)**:
```ruby
Rails.logger.info "Message"
Rails.logger.debug { "Lazy: #{expensive}" }
```

**Django (Python)**:
```python
import logging
logger = logging.getLogger(__name__)
logger.info("Message")
```

**Express (Node)**:
```javascript
const winston = require('winston');
logger.info('Message');
```

**Phoenix (Elixir)**:
```elixir
require Logger
Logger.info("Message")
Logger.debug(fn -> "Lazy: #{expensive()}" end)
```

Elixir's Logger is simpler than most, with lazy evaluation built-in and process-based isolation for reliability.
