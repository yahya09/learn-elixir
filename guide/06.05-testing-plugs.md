# Chapter 6.5: Testing Plugs

Plugs should be tested independently. In this chapter, we'll learn how to write unit tests for both function and module plugs.

## Testing Setup

Create a test helper for plug testing:

```elixir
# File: test/support/plug_case.ex

defmodule SnippetboxWeb.PlugCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      import Plug.Conn
      import Phoenix.ConnTest
      import SnippetboxWeb.PlugCase

      @endpoint SnippetboxWeb.Endpoint
    end
  end

  def conn_with_session do
    Phoenix.ConnTest.build_conn()
    |> Plug.Test.init_test_session(%{})
  end

  def conn_with_user(user) do
    conn_with_session()
    |> Plug.Conn.assign(:current_user, user)
  end
end
```

## Testing Function Plugs

### Basic Function Plug Test

```elixir
# File: test/snippetbox_web/plugs/auth_test.exs

defmodule SnippetboxWeb.Plugs.AuthTest do
  use SnippetboxWeb.PlugCase, async: true

  alias SnippetboxWeb.Plugs.Auth

  describe "fetch_current_user/2" do
    test "assigns nil when no user in session" do
      conn = conn_with_session()
      conn = Auth.fetch_current_user(conn, [])

      assert conn.assigns.current_user == nil
    end

    test "assigns user when user_id in session" do
      user = user_fixture()

      conn =
        conn_with_session()
        |> put_session(:user_id, user.id)
        |> Auth.fetch_current_user([])

      assert conn.assigns.current_user.id == user.id
    end

    test "assigns nil when user_id is invalid" do
      conn =
        conn_with_session()
        |> put_session(:user_id, -1)
        |> Auth.fetch_current_user([])

      assert conn.assigns.current_user == nil
    end
  end

  describe "require_authenticated_user/2" do
    test "continues when user is logged in" do
      user = user_fixture()
      conn = conn_with_user(user)

      result = Auth.require_authenticated_user(conn, [])

      refute result.halted
    end

    test "redirects when no user" do
      conn =
        conn_with_session()
        |> assign(:current_user, nil)
        |> Auth.require_authenticated_user([])

      assert conn.halted
      assert redirected_to(conn) == "/login"
      assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ "must log in"
    end

    test "stores return path for GET requests" do
      conn =
        conn_with_session()
        |> Map.put(:method, "GET")
        |> Map.put(:request_path, "/snippets/123")
        |> assign(:current_user, nil)
        |> Auth.require_authenticated_user([])

      assert get_session(conn, :return_to) == "/snippets/123"
    end
  end
end
```

## Testing Module Plugs

### Testing init/1 and call/2

```elixir
# File: test/snippetbox_web/plugs/request_logger_test.exs

defmodule SnippetboxWeb.Plugs.RequestLoggerTest do
  use SnippetboxWeb.PlugCase, async: true

  import ExUnit.CaptureLog

  alias SnippetboxWeb.Plugs.RequestLogger

  describe "init/1" do
    test "sets default log level to :info" do
      opts = RequestLogger.init([])
      assert opts.level == :info
    end

    test "accepts custom log level" do
      opts = RequestLogger.init(level: :debug)
      assert opts.level == :debug
    end
  end

  describe "call/2" do
    test "logs request after response is sent" do
      opts = RequestLogger.init(level: :info)

      log =
        capture_log(fn ->
          build_conn(:get, "/test")
          |> RequestLogger.call(opts)
          |> send_resp(200, "OK")
        end)

      assert log =~ "GET /test"
      assert log =~ "200"
    end
  end
end
```

### Testing Rate Limiter

```elixir
# File: test/snippetbox_web/plugs/rate_limiter_test.exs

defmodule SnippetboxWeb.Plugs.RateLimiterTest do
  use SnippetboxWeb.PlugCase, async: false  # Not async due to shared state

  alias SnippetboxWeb.Plugs.RateLimiter

  setup do
    # Reset rate limit state before each test
    :ets.delete_all_objects(:rate_limits)
    :ok
  end

  describe "call/2" do
    test "allows requests within limit" do
      opts = RateLimiter.init(max_requests: 5, window_ms: 60_000)

      conn = build_conn(:get, "/api/test")
      conn = RateLimiter.call(conn, opts)

      refute conn.halted
      assert get_resp_header(conn, "x-ratelimit-remaining") == ["4"]
    end

    test "blocks requests over limit" do
      opts = RateLimiter.init(max_requests: 2, window_ms: 60_000)

      # Make 3 requests
      conn1 = build_conn(:get, "/api/test") |> RateLimiter.call(opts)
      conn2 = build_conn(:get, "/api/test") |> RateLimiter.call(opts)
      conn3 = build_conn(:get, "/api/test") |> RateLimiter.call(opts)

      refute conn1.halted
      refute conn2.halted
      assert conn3.halted
      assert conn3.status == 429
    end

    test "sets retry-after header when rate limited" do
      opts = RateLimiter.init(max_requests: 1, window_ms: 60_000)

      build_conn(:get, "/api/test") |> RateLimiter.call(opts)
      conn = build_conn(:get, "/api/test") |> RateLimiter.call(opts)

      assert get_resp_header(conn, "retry-after") == ["60"]
    end
  end
end
```

### Testing CORS Plug

```elixir
# File: test/snippetbox_web/plugs/cors_test.exs

defmodule SnippetboxWeb.Plugs.CORSTest do
  use SnippetboxWeb.PlugCase, async: true

  alias SnippetboxWeb.Plugs.CORS

  describe "call/2" do
    test "sets CORS headers for allowed origin" do
      opts = CORS.init(origins: ["http://localhost:3000"])

      conn =
        build_conn(:get, "/api/test")
        |> put_req_header("origin", "http://localhost:3000")
        |> CORS.call(opts)

      assert get_resp_header(conn, "access-control-allow-origin") == ["http://localhost:3000"]
    end

    test "does not set CORS headers for disallowed origin" do
      opts = CORS.init(origins: ["http://localhost:3000"])

      conn =
        build_conn(:get, "/api/test")
        |> put_req_header("origin", "http://evil.com")
        |> CORS.call(opts)

      assert get_resp_header(conn, "access-control-allow-origin") == []
    end

    test "handles preflight OPTIONS request" do
      opts = CORS.init(origins: ["*"])

      conn =
        build_conn(:options, "/api/test")
        |> put_req_header("origin", "http://localhost:3000")
        |> CORS.call(opts)

      assert conn.status == 204
      assert conn.halted
      assert get_resp_header(conn, "access-control-max-age") == ["86400"]
    end
  end
end
```

## Testing Authorization Plugs

```elixir
# File: test/snippetbox_web/plugs/authorize_test.exs

defmodule SnippetboxWeb.Plugs.AuthorizeTest do
  use SnippetboxWeb.PlugCase, async: true

  alias SnippetboxWeb.Plugs.Authorize

  describe "require_role/2" do
    test "allows user with matching role" do
      user = %{id: 1, role: :admin}
      conn = conn_with_user(user)

      result = Authorize.require_role(conn, [:admin])

      refute result.halted
    end

    test "allows user with one of multiple roles" do
      user = %{id: 1, role: :moderator}
      conn = conn_with_user(user)

      result = Authorize.require_role(conn, [:admin, :moderator])

      refute result.halted
    end

    test "blocks user without matching role" do
      user = %{id: 1, role: :user}
      conn = conn_with_user(user)

      result = Authorize.require_role(conn, [:admin])

      assert result.halted
      assert result.status == 403
    end

    test "blocks when no user" do
      conn = conn_with_session() |> assign(:current_user, nil)

      result = Authorize.require_role(conn, [:admin])

      assert result.halted
      assert result.status == 403
    end
  end
end
```

## Testing Plugs with Mocks

```elixir
# File: test/snippetbox_web/plugs/api_auth_test.exs

defmodule SnippetboxWeb.Plugs.APIAuthTest do
  use SnippetboxWeb.PlugCase, async: true
  import Mox

  alias SnippetboxWeb.Plugs.APIAuth

  setup :verify_on_exit!

  describe "fetch_api_user/2" do
    test "authenticates valid token" do
      user = %{id: 1, email: "test@example.com"}

      # Mock token verification
      expect(SnippetboxWeb.TokenMock, :verify, fn "valid-token" ->
        {:ok, %{"sub" => user.id}}
      end)

      expect(Snippetbox.AccountsMock, :get_user, fn 1 -> user end)

      conn =
        build_conn(:get, "/api/test")
        |> put_req_header("authorization", "Bearer valid-token")
        |> APIAuth.fetch_api_user([])

      refute conn.halted
      assert conn.assigns.current_user == user
    end

    test "rejects invalid token" do
      expect(SnippetboxWeb.TokenMock, :verify, fn "invalid-token" ->
        {:error, :invalid}
      end)

      conn =
        build_conn(:get, "/api/test")
        |> put_req_header("authorization", "Bearer invalid-token")
        |> APIAuth.fetch_api_user([])

      assert conn.halted
      assert conn.status == 401
    end

    test "rejects missing token" do
      conn =
        build_conn(:get, "/api/test")
        |> APIAuth.fetch_api_user([])

      assert conn.halted
      assert conn.status == 401
    end
  end
end
```

## Integration Testing Plugs

Test plugs in the context of a full request:

```elixir
# File: test/snippetbox_web/controllers/snippet_controller_test.exs

defmodule SnippetboxWeb.SnippetControllerTest do
  use SnippetboxWeb.ConnCase

  describe "protected routes" do
    test "redirect to login when not authenticated", %{conn: conn} do
      conn = get(conn, ~p"/snippets/new")

      assert redirected_to(conn) == "/login"
      assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ "must log in"
    end

    test "accessible when authenticated", %{conn: conn} do
      user = user_fixture()
      conn = log_in_user(conn, user)

      conn = get(conn, ~p"/snippets/new")

      assert html_response(conn, 200) =~ "New Snippet"
    end
  end

  describe "admin routes" do
    test "forbidden for non-admin users", %{conn: conn} do
      user = user_fixture(role: :user)
      conn = log_in_user(conn, user)

      conn = get(conn, ~p"/admin/users")

      assert html_response(conn, 403) =~ "Forbidden"
    end

    test "accessible for admin users", %{conn: conn} do
      admin = user_fixture(role: :admin)
      conn = log_in_user(conn, admin)

      conn = get(conn, ~p"/admin/users")

      assert html_response(conn, 200) =~ "Users"
    end
  end
end
```

## Test Helpers

```elixir
# File: test/support/conn_case.ex

defmodule SnippetboxWeb.ConnCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      import Plug.Conn
      import Phoenix.ConnTest
      import SnippetboxWeb.ConnCase

      @endpoint SnippetboxWeb.Endpoint
    end
  end

  setup tags do
    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Snippetbox.Repo)

    unless tags[:async] do
      Ecto.Adapters.SQL.Sandbox.mode(Snippetbox.Repo, {:shared, self()})
    end

    {:ok, conn: Phoenix.ConnTest.build_conn()}
  end

  def log_in_user(conn, user) do
    conn
    |> Phoenix.ConnTest.init_test_session(%{})
    |> Plug.Conn.put_session(:user_id, user.id)
    |> Plug.Conn.assign(:current_user, user)
  end
end
```

> **FP Concept: Testing Pure Functions**
>
> Plugs are essentially pure functions (ignoring side effects):
>
> ```elixir
> input_conn → plug → output_conn
> ```
>
> This makes them trivially testable:
> - Create input conn with specific state
> - Call plug function
> - Assert on output conn properties
>
> No mocking of external services needed for most plug tests.

## Summary

In this chapter, we learned:

- Setting up plug test helpers
- Testing function plugs
- Testing module plugs (init and call)
- Testing authentication and authorization
- Using mocks for external dependencies
- Integration testing plugs

This completes the Plugs and Middleware chapter. In the next chapter, we'll explore Advanced Routing.
