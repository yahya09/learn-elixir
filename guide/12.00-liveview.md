# Chapter 12: Phoenix LiveView

LiveView enables rich, real-time user experiences without writing JavaScript. In this chapter, we'll explore how to build interactive applications with LiveView.

## What You'll Learn

- LiveView basics and lifecycle
- Interactive forms with real-time validation
- Live components for reusability
- Real-time features (notifications, updates)
- LiveView best practices

## Chapter Structure

This chapter covers:

- **12.1 LiveView Basics** - Lifecycle, state, and events
- **12.2 LiveView Forms** - Real-time form validation
- **12.3 Live Components** - Reusable LiveView components
- **12.4 Real-Time Features** - PubSub and live updates

## What is LiveView?

LiveView is server-rendered HTML with real-time updates:

```
┌─────────────────────────────────────────────────────────────┐
│                         Browser                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    LiveView JS                          │ │
│  │  • WebSocket connection                                 │ │
│  │  • DOM patching (morphdom)                              │ │
│  │  • Event handling                                       │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              ↕ WebSocket
┌─────────────────────────────────────────────────────────────┐
│                         Server                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    LiveView Process                     │ │
│  │  • Stateful Elixir process                              │ │
│  │  • Handles events                                       │ │
│  │  • Renders HTML diffs                                   │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## LiveView vs Traditional

| Traditional | LiveView |
|-------------|----------|
| Full page reload | DOM patching |
| JavaScript required | Server-rendered |
| Client state | Server state |
| REST API | WebSocket |
| Complex JS frameworks | Simple HEEx templates |

## When to Use LiveView

**Good Fit:**
- Forms with real-time validation
- Live search/filtering
- Real-time dashboards
- Chat/notifications
- Interactive tables
- Wizards/multi-step flows

**Consider Alternatives:**
- Offline-first apps
- Heavy client-side computation
- Complex animations
- Mobile apps

## LiveView Preview

```elixir
defmodule SnippetboxWeb.SnippetLive.Index do
  use SnippetboxWeb, :live_view

  alias Snippetbox.Snippets

  @impl true
  def mount(_params, _session, socket) do
    {:ok, stream(socket, :snippets, Snippets.list_snippets())}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <.header>
      Snippets
      <:actions>
        <.link patch={~p"/snippets/new"}>
          <.button>New Snippet</.button>
        </.link>
      </:actions>
    </.header>

    <.table id="snippets" rows={@streams.snippets}>
      <:col :let={{_id, snippet}} label="Title"><%= snippet.title %></:col>
      <:col :let={{_id, snippet}} label="Language"><%= snippet.language %></:col>
      <:action :let={{_id, snippet}}>
        <.link patch={~p"/snippets/#{snippet}/edit"}>Edit</.link>
      </:action>
    </.table>
    """
  end

  @impl true
  def handle_event("delete", %{"id" => id}, socket) do
    snippet = Snippets.get_snippet!(id)
    {:ok, _} = Snippets.delete_snippet(snippet)
    {:noreply, stream_delete(socket, :snippets, snippet)}
  end
end
```

## Architecture

```
LiveView Process
├── mount/3 - Initialize state
├── handle_params/3 - URL changes
├── handle_event/3 - User interactions
├── handle_info/2 - Server messages
└── render/1 - Generate HTML

Each user gets their own:
├── WebSocket connection
├── LiveView process
└── Server-side state
```

## Key Concepts

### Assigns

Server-side state stored in socket assigns:

```elixir
socket
|> assign(:count, 0)
|> assign(:user, current_user)
```

### Events

User interactions sent to server:

```heex
<button phx-click="increment">+1</button>
```

### Streams

Efficient list handling:

```elixir
socket
|> stream(:items, items)
|> stream_insert(:items, new_item)
|> stream_delete(:items, item)
```

Let's start with LiveView basics.
