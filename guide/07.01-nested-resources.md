# Chapter 7.1: Nested Resources

When resources have parent-child relationships, nested routes express this clearly. In this chapter, we'll learn when and how to use nested resources.

## When to Nest Resources

Nest resources when:
- The child **belongs to** the parent
- The child **only makes sense** in the context of the parent
- You need the parent ID in the URL

Examples:
- `/users/:user_id/snippets` - User's snippets
- `/snippets/:snippet_id/comments` - Snippet's comments
- `/organizations/:org_id/members` - Organization's members

## Basic Nested Resources

```elixir
# File: lib/snippetbox_web/router.ex

resources "/users", UserController do
  resources "/snippets", UserSnippetController
end
```

This generates:

| Verb | Path | Controller#Action |
|------|------|-------------------|
| GET | /users/:user_id/snippets | UserSnippetController :index |
| GET | /users/:user_id/snippets/:id | UserSnippetController :show |
| GET | /users/:user_id/snippets/new | UserSnippetController :new |
| POST | /users/:user_id/snippets | UserSnippetController :create |
| GET | /users/:user_id/snippets/:id/edit | UserSnippetController :edit |
| PUT/PATCH | /users/:user_id/snippets/:id | UserSnippetController :update |
| DELETE | /users/:user_id/snippets/:id | UserSnippetController :delete |

## Nested Controller

```elixir
# File: lib/snippetbox_web/controllers/user_snippet_controller.ex

defmodule SnippetboxWeb.UserSnippetController do
  use SnippetboxWeb, :controller

  alias Snippetbox.Accounts
  alias Snippetbox.Snippets

  # Plug to load and authorize user
  plug :load_user

  def index(conn, _params) do
    snippets = Snippets.list_snippets_for_user(conn.assigns.user)
    render(conn, :index, snippets: snippets)
  end

  def show(conn, %{"id" => id}) do
    snippet = Snippets.get_user_snippet!(conn.assigns.user, id)
    render(conn, :show, snippet: snippet)
  end

  def new(conn, _params) do
    changeset = Snippets.change_snippet(%Snippet{})
    render(conn, :new, changeset: changeset)
  end

  def create(conn, %{"snippet" => snippet_params}) do
    case Snippets.create_snippet_for_user(conn.assigns.user, snippet_params) do
      {:ok, snippet} ->
        conn
        |> put_flash(:info, "Snippet created successfully.")
        |> redirect(to: ~p"/users/#{conn.assigns.user}/snippets/#{snippet}")

      {:error, changeset} ->
        render(conn, :new, changeset: changeset)
    end
  end

  defp load_user(conn, _opts) do
    user = Accounts.get_user!(conn.params["user_id"])
    assign(conn, :user, user)
  end
end
```

## Shallow Nesting

Avoid deep nesting by using shallow routes:

```elixir
# Only nest :index and :create
resources "/users", UserController do
  resources "/snippets", UserSnippetController, only: [:index, :create]
end

# Direct routes for specific snippets
resources "/snippets", SnippetController, only: [:show, :edit, :update, :delete]
```

Result:
- `/users/:user_id/snippets` - List user's snippets
- `/users/:user_id/snippets` - Create for user
- `/snippets/:id` - View specific snippet
- `/snippets/:id/edit` - Edit specific snippet

## Comments on Snippets

```elixir
resources "/snippets", SnippetController do
  resources "/comments", CommentController, only: [:index, :create, :delete]
end
```

Controller:

```elixir
# File: lib/snippetbox_web/controllers/comment_controller.ex

defmodule SnippetboxWeb.CommentController do
  use SnippetboxWeb, :controller

  alias Snippetbox.Snippets
  alias Snippetbox.Comments

  plug :load_snippet

  def index(conn, _params) do
    comments = Comments.list_comments_for_snippet(conn.assigns.snippet)
    render(conn, :index, comments: comments)
  end

  def create(conn, %{"comment" => comment_params}) do
    case Comments.create_comment(conn.assigns.snippet, conn.assigns.current_user, comment_params) do
      {:ok, _comment} ->
        conn
        |> put_flash(:info, "Comment added.")
        |> redirect(to: ~p"/snippets/#{conn.assigns.snippet}")

      {:error, changeset} ->
        conn
        |> put_flash(:error, "Failed to add comment.")
        |> redirect(to: ~p"/snippets/#{conn.assigns.snippet}")
    end
  end

  def delete(conn, %{"id" => id}) do
    comment = Comments.get_comment!(id)

    if comment.user_id == conn.assigns.current_user.id do
      Comments.delete_comment(comment)
      put_flash(conn, :info, "Comment deleted.")
    else
      put_flash(conn, :error, "Cannot delete others' comments.")
    end
    |> redirect(to: ~p"/snippets/#{conn.assigns.snippet}")
  end

  defp load_snippet(conn, _opts) do
    snippet = Snippets.get_snippet!(conn.params["snippet_id"])
    assign(conn, :snippet, snippet)
  end
end
```

## Verified Routes with Nested Resources

```elixir
# Route helpers
~p"/users/#{user}/snippets"
~p"/users/#{user}/snippets/#{snippet}"
~p"/snippets/#{snippet}/comments"
```

In templates:

```heex
<.link href={~p"/users/#{@user}/snippets"}>
  View <%= @user.name %>'s Snippets
</.link>

<.link href={~p"/snippets/#{@snippet}/comments"}>
  <%= length(@snippet.comments) %> comments
</.link>
```

## Multiple Levels of Nesting

Avoid more than one level of nesting:

```elixir
# Bad: Too deep
resources "/organizations", OrganizationController do
  resources "/teams", TeamController do
    resources "/members", MemberController do
      resources "/tasks", TaskController  # 4 levels deep!
    end
  end
end

# Good: Flatten where possible
resources "/organizations", OrganizationController do
  resources "/teams", TeamController, only: [:index, :create]
end

resources "/teams", TeamController, only: [:show, :update, :delete] do
  resources "/members", MemberController, only: [:index, :create]
end

resources "/members", MemberController, only: [:show, :delete]
resources "/tasks", TaskController
```

## Context Functions for Nested Resources

```elixir
# File: lib/snippetbox/snippets.ex

defmodule Snippetbox.Snippets do
  # Scoped to user
  def list_snippets_for_user(user) do
    Snippet
    |> where([s], s.user_id == ^user.id)
    |> order_by([s], desc: s.inserted_at)
    |> Repo.all()
  end

  def get_user_snippet!(user, id) do
    Snippet
    |> where([s], s.user_id == ^user.id)
    |> Repo.get!(id)
  end

  def create_snippet_for_user(user, attrs) do
    %Snippet{user_id: user.id}
    |> Snippet.changeset(attrs)
    |> Repo.insert()
  end
end
```

## Authorization in Nested Routes

```elixir
defmodule SnippetboxWeb.UserSnippetController do
  use SnippetboxWeb, :controller

  plug :load_user
  plug :authorize_user

  # Actions...

  defp load_user(conn, _opts) do
    user = Accounts.get_user!(conn.params["user_id"])
    assign(conn, :user, user)
  end

  defp authorize_user(conn, _opts) do
    # Only allow viewing own snippets (or admin)
    current_user = conn.assigns.current_user

    if conn.assigns.user.id == current_user.id || current_user.role == :admin do
      conn
    else
      conn
      |> put_flash(:error, "You can only view your own snippets.")
      |> redirect(to: ~p"/snippets")
      |> halt()
    end
  end
end
```

> **FP Concept: URL as Data Hierarchy**
>
> Nested URLs express data relationships:
>
> ```
> /users/42/snippets/123
>
> User (id: 42)
>  └── Snippet (id: 123)
> ```
>
> The URL structure mirrors your data model, making the API intuitive and self-documenting.
>
> **Further Reading**:
> - [Phoenix Resources](https://hexdocs.pm/phoenix/routing.html#resources)

## Summary

In this chapter, we learned:

- When to use nested resources
- Creating nested routes with `resources do`
- Shallow nesting to avoid deep URLs
- Controller patterns for nested resources
- Context functions for scoped queries
- Authorization in nested routes

In the next chapter, we'll explore scopes and namespaces.
