# Chapter 11.3: Login and Logout

Session management is at the heart of authentication. In this chapter, we'll implement secure login and logout functionality.

## Session Controller

```elixir
# File: lib/snippetbox_web/controllers/user_session_controller.ex

defmodule SnippetboxWeb.UserSessionController do
  use SnippetboxWeb, :controller

  alias Snippetbox.Accounts
  alias SnippetboxWeb.UserAuth

  def new(conn, _params) do
    render(conn, :new, error_message: nil)
  end

  def create(conn, %{"user" => user_params}) do
    %{"email" => email, "password" => password} = user_params

    if user = Accounts.get_user_by_email_and_password(email, password) do
      conn
      |> put_flash(:info, "Welcome back!")
      |> UserAuth.log_in_user(user, user_params)
    else
      # Generic error message to prevent email enumeration
      render(conn, :new, error_message: "Invalid email or password")
    end
  end

  def delete(conn, _params) do
    conn
    |> put_flash(:info, "Logged out successfully.")
    |> UserAuth.log_out_user()
  end
end
```

## Login Template

```heex
<%# File: lib/snippetbox_web/controllers/user_session_html/new.html.heex %>

<div class="mx-auto max-w-md">
  <.header class="text-center">
    Log In
    <:subtitle>
      Don't have an account?
      <.link navigate={~p"/register"} class="font-semibold text-brand hover:underline">
        Sign up
      </.link>
    </:subtitle>
  </.header>

  <.form for={%{}} action={~p"/login"} as={:user} class="mt-8">
    <.error :if={@error_message}><%= @error_message %></.error>

    <div class="space-y-4">
      <.input name="email" type="email" label="Email" required />
      <.input name="password" type="password" label="Password" required />
    </div>

    <div class="mt-4 flex items-center justify-between">
      <label class="flex items-center gap-2">
        <input type="checkbox" name="remember_me" class="rounded border-gray-300" />
        <span class="text-sm text-gray-600">Remember me</span>
      </label>
      <.link href={~p"/forgot-password"} class="text-sm text-brand hover:underline">
        Forgot password?
      </.link>
    </div>

    <div class="mt-6">
      <.button class="w-full">Log In</.button>
    </div>
  </.form>
</div>
```

## User Auth Module

```elixir
# File: lib/snippetbox_web/user_auth.ex

defmodule SnippetboxWeb.UserAuth do
  use SnippetboxWeb, :verified_routes

  import Plug.Conn
  import Phoenix.Controller

  alias Snippetbox.Accounts

  # How long the session token is valid
  @max_age 60 * 60 * 24 * 60  # 60 days
  @remember_me_cookie "_snippetbox_remember_me"
  @remember_me_options [sign: true, max_age: @max_age, same_site: "Lax"]

  @doc """
  Logs the user in.

  Renews the session ID and clears the whole session to avoid fixation attacks.
  """
  def log_in_user(conn, user, params \\ %{}) do
    token = Accounts.generate_user_session_token(user)
    user_return_to = get_session(conn, :user_return_to)

    conn
    |> renew_session()
    |> put_token_in_session(token)
    |> maybe_write_remember_me_cookie(token, params)
    |> redirect(to: user_return_to || signed_in_path(conn))
  end

  defp maybe_write_remember_me_cookie(conn, token, %{"remember_me" => "true"}) do
    put_resp_cookie(conn, @remember_me_cookie, token, @remember_me_options)
  end

  defp maybe_write_remember_me_cookie(conn, _token, _params) do
    conn
  end

  defp renew_session(conn) do
    conn
    |> configure_session(renew: true)
    |> clear_session()
  end

  @doc """
  Logs the user out.

  Clears all session data and deletes the remember me cookie.
  """
  def log_out_user(conn) do
    user_token = get_session(conn, :user_token)
    user_token && Accounts.delete_user_session_token(user_token)

    if live_socket_id = get_session(conn, :live_socket_id) do
      SnippetboxWeb.Endpoint.broadcast(live_socket_id, "disconnect", %{})
    end

    conn
    |> renew_session()
    |> delete_resp_cookie(@remember_me_cookie)
    |> redirect(to: ~p"/")
  end

  @doc """
  Authenticates the user by looking into the session and remember me token.
  """
  def fetch_current_user(conn, _opts) do
    {user_token, conn} = ensure_user_token(conn)
    user = user_token && Accounts.get_user_by_session_token(user_token)
    assign(conn, :current_user, user)
  end

  defp ensure_user_token(conn) do
    if token = get_session(conn, :user_token) do
      {token, conn}
    else
      conn = fetch_cookies(conn, signed: [@remember_me_cookie])

      if token = conn.cookies[@remember_me_cookie] do
        {token, put_token_in_session(conn, token)}
      else
        {nil, conn}
      end
    end
  end

  defp put_token_in_session(conn, token) do
    conn
    |> put_session(:user_token, token)
    |> put_session(:live_socket_id, "users_sessions:#{Base.url_encode64(token)}")
  end

  @doc """
  Handles mounting and authenticating the current user in LiveViews.
  """
  def on_mount(:mount_current_user, _params, session, socket) do
    {:cont, mount_current_user(socket, session)}
  end

  def on_mount(:ensure_authenticated, _params, session, socket) do
    socket = mount_current_user(socket, session)

    if socket.assigns.current_user do
      {:cont, socket}
    else
      socket =
        socket
        |> Phoenix.LiveView.put_flash(:error, "You must log in to access this page.")
        |> Phoenix.LiveView.redirect(to: ~p"/login")

      {:halt, socket}
    end
  end

  def on_mount(:redirect_if_user_is_authenticated, _params, session, socket) do
    socket = mount_current_user(socket, session)

    if socket.assigns.current_user do
      {:halt, Phoenix.LiveView.redirect(socket, to: signed_in_path(socket))}
    else
      {:cont, socket}
    end
  end

  defp mount_current_user(socket, session) do
    Phoenix.Component.assign_new(socket, :current_user, fn ->
      if user_token = session["user_token"] do
        Accounts.get_user_by_session_token(user_token)
      end
    end)
  end

  @doc """
  Used for routes that require the user to not be authenticated.
  """
  def redirect_if_user_is_authenticated(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
      |> redirect(to: signed_in_path(conn))
      |> halt()
    else
      conn
    end
  end

  @doc """
  Used for routes that require the user to be authenticated.
  """
  def require_authenticated_user(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
    else
      conn
      |> put_flash(:error, "You must log in to access this page.")
      |> maybe_store_return_to()
      |> redirect(to: ~p"/login")
      |> halt()
    end
  end

  defp maybe_store_return_to(%{method: "GET"} = conn) do
    put_session(conn, :user_return_to, current_path(conn))
  end

  defp maybe_store_return_to(conn), do: conn

  defp signed_in_path(_conn), do: ~p"/"
end
```

## Session Token Model

```elixir
# File: lib/snippetbox/accounts/user_token.ex

defmodule Snippetbox.Accounts.UserToken do
  use Ecto.Schema
  import Ecto.Query

  @hash_algorithm :sha256
  @rand_size 32

  # Token validity periods
  @session_validity_in_days 60
  @confirm_validity_in_days 7
  @reset_password_validity_in_days 1

  schema "users_tokens" do
    field :token, :binary
    field :context, :string
    field :sent_to, :string
    belongs_to :user, Snippetbox.Accounts.User

    timestamps(updated_at: false)
  end

  @doc """
  Generates a token for session.
  """
  def build_session_token(user) do
    token = :crypto.strong_rand_bytes(@rand_size)
    {token, %__MODULE__{token: token, context: "session", user_id: user.id}}
  end

  @doc """
  Checks if the token is valid and returns its underlying lookup query.
  """
  def verify_session_token_query(token) do
    query =
      from token in by_token_and_context_query(token, "session"),
        join: user in assoc(token, :user),
        where: token.inserted_at > ago(@session_validity_in_days, "day"),
        select: user

    {:ok, query}
  end

  defp by_token_and_context_query(token, context) do
    from __MODULE__, where: [token: ^token, context: ^context]
  end
end
```

## Migration for Tokens

```elixir
# File: priv/repo/migrations/YYYYMMDDHHMMSS_create_users_tokens.exs

defmodule Snippetbox.Repo.Migrations.CreateUsersTokens do
  use Ecto.Migration

  def change do
    create table(:users_tokens) do
      add :user_id, references(:users, on_delete: :delete_all), null: false
      add :token, :binary, null: false
      add :context, :string, null: false
      add :sent_to, :string

      timestamps(updated_at: false)
    end

    create index(:users_tokens, [:user_id])
    create unique_index(:users_tokens, [:context, :token])
  end
end
```

## Context Functions

```elixir
# File: lib/snippetbox/accounts.ex

defmodule Snippetbox.Accounts do
  alias Snippetbox.Repo
  alias Snippetbox.Accounts.{User, UserToken}

  ## Session

  @doc """
  Generates a session token.
  """
  def generate_user_session_token(user) do
    {token, user_token} = UserToken.build_session_token(user)
    Repo.insert!(user_token)
    token
  end

  @doc """
  Gets the user with the given session token.
  """
  def get_user_by_session_token(token) do
    {:ok, query} = UserToken.verify_session_token_query(token)
    Repo.one(query)
  end

  @doc """
  Deletes the session token.
  """
  def delete_user_session_token(token) do
    Repo.delete_all(UserToken.by_token_and_context_query(token, "session"))
    :ok
  end

  ## Authentication

  @doc """
  Gets a user by email and password.
  """
  def get_user_by_email_and_password(email, password)
      when is_binary(email) and is_binary(password) do
    user = Repo.get_by(User, email: email)
    if User.valid_password?(user, password), do: user
  end
end
```

## Router Setup

```elixir
# File: lib/snippetbox_web/router.ex

defmodule SnippetboxWeb.Router do
  use SnippetboxWeb, :router

  import SnippetboxWeb.UserAuth

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {SnippetboxWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
    plug :fetch_current_user
  end

  # Routes for unauthenticated users only
  scope "/", SnippetboxWeb do
    pipe_through [:browser, :redirect_if_user_is_authenticated]

    get "/register", UserRegistrationController, :new
    post "/register", UserRegistrationController, :create
    get "/login", UserSessionController, :new
    post "/login", UserSessionController, :create
  end

  # Routes for authenticated users
  scope "/", SnippetboxWeb do
    pipe_through [:browser, :require_authenticated_user]

    delete "/logout", UserSessionController, :delete
    # Protected routes...
  end

  # Routes for all users
  scope "/", SnippetboxWeb do
    pipe_through :browser

    get "/", PageController, :home
    # Public routes...
  end
end
```

## Navigation with Auth State

```heex
<%# File: lib/snippetbox_web/components/layouts/app.html.heex %>

<header class="px-4 py-4 border-b">
  <nav class="flex items-center justify-between">
    <.link href={~p"/"} class="text-xl font-bold">
      Snippetbox
    </.link>

    <div class="flex items-center gap-4">
      <%= if @current_user do %>
        <span class="text-sm text-gray-600">
          <%= @current_user.email %>
        </span>
        <.link href={~p"/settings"}>Settings</.link>
        <.link href={~p"/logout"} method="delete">Log out</.link>
      <% else %>
        <.link href={~p"/register"}>Register</.link>
        <.link href={~p"/login"}>Log in</.link>
      <% end %>
    </div>
  </nav>
</header>
```

## Testing Login/Logout

```elixir
# File: test/snippetbox_web/controllers/user_session_controller_test.exs

defmodule SnippetboxWeb.UserSessionControllerTest do
  use SnippetboxWeb.ConnCase

  setup do
    %{user: user_fixture()}
  end

  describe "POST /login" do
    test "logs the user in", %{conn: conn, user: user} do
      conn =
        post(conn, ~p"/login", %{
          "user" => %{
            "email" => user.email,
            "password" => valid_user_password()
          }
        })

      assert get_session(conn, :user_token)
      assert redirected_to(conn) == ~p"/"

      # Verify logged in
      conn = get(conn, ~p"/")
      html = html_response(conn, 200)
      assert html =~ user.email
      assert html =~ "Log out"
    end

    test "logs the user in with remember me", %{conn: conn, user: user} do
      conn =
        post(conn, ~p"/login", %{
          "user" => %{
            "email" => user.email,
            "password" => valid_user_password(),
            "remember_me" => "true"
          }
        })

      assert conn.resp_cookies["_snippetbox_remember_me"]
    end

    test "returns error with invalid credentials", %{conn: conn} do
      conn =
        post(conn, ~p"/login", %{
          "user" => %{"email" => "invalid@email.com", "password" => "wrong"}
        })

      html = html_response(conn, 200)
      assert html =~ "Invalid email or password"
    end
  end

  describe "DELETE /logout" do
    test "logs the user out", %{conn: conn, user: user} do
      conn = conn |> log_in_user(user) |> delete(~p"/logout")

      assert redirected_to(conn) == ~p"/"
      refute get_session(conn, :user_token)
    end

    test "succeeds even if not logged in", %{conn: conn} do
      conn = delete(conn, ~p"/logout")
      assert redirected_to(conn) == ~p"/"
    end
  end
end
```

> **FP Concept: Token-Based Sessions**
>
> Session tokens follow functional principles:
>
> ```elixir
> # Generate: pure function
> token = generate_token(user)
>
> # Verify: query returns user or nil
> user = get_user_by_token(token)
>
> # Delete: removes token, returns :ok
> :ok = delete_token(token)
> ```
>
> Each operation is explicit and predictable.

## Summary

In this chapter, we learned:

- Creating session controller
- Login form implementation
- Token-based session management
- Remember me functionality
- Logout and session cleanup
- Router authentication pipelines
- Navigation with auth state
- Testing login/logout flows

In the next chapter, we'll explore remember me functionality in detail.
