# Chapter 17.2: Database Exercises

These exercises reinforce concepts from Chapter 4 covering Ecto schemas, changesets, queries, and associations.

## Exercise 1: Schema with Validation

Create a schema for a `Comment` with proper validations.

```elixir
# File: lib/snippetbox/comments/comment.ex

defmodule Snippetbox.Comments.Comment do
  use Ecto.Schema
  import Ecto.Changeset

  # Create schema with:
  # - content (required, min 10 chars, max 1000 chars)
  # - author_name (required if user_id is nil)
  # - user_id (optional, foreign key)
  # - snippet_id (required, foreign key)
  # - approved (boolean, default false)
  # - timestamps
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule Snippetbox.Comments.Comment do
  use Ecto.Schema
  import Ecto.Changeset

  schema "comments" do
    field :content, :string
    field :author_name, :string
    field :approved, :boolean, default: false

    belongs_to :user, Snippetbox.Accounts.User
    belongs_to :snippet, Snippetbox.Snippets.Snippet

    timestamps()
  end

  def changeset(comment, attrs) do
    comment
    |> cast(attrs, [:content, :author_name, :user_id, :snippet_id, :approved])
    |> validate_required([:content, :snippet_id])
    |> validate_length(:content, min: 10, max: 1000)
    |> validate_author()
    |> foreign_key_constraint(:user_id)
    |> foreign_key_constraint(:snippet_id)
  end

  defp validate_author(changeset) do
    user_id = get_field(changeset, :user_id)
    author_name = get_field(changeset, :author_name)

    if is_nil(user_id) and (is_nil(author_name) or author_name == "") do
      add_error(changeset, :author_name, "is required when not logged in")
    else
      changeset
    end
  end
end
```
</details>

## Exercise 2: Complex Query

Write a query that returns snippets with their comment counts and average rating.

```elixir
# File: lib/snippetbox/snippets.ex

def list_snippets_with_stats do
  # Return snippets with:
  # - snippet fields
  # - comment_count
  # - avg_rating (from a ratings table)
  # - ordered by comment_count desc
end
```

### Hints
- Use `left_join` to handle snippets without comments/ratings
- Use `group_by` and aggregate functions
- Use `select` to shape the output

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def list_snippets_with_stats do
  from(s in Snippet,
    left_join: c in assoc(s, :comments),
    left_join: r in assoc(s, :ratings),
    group_by: s.id,
    select: %{
      snippet: s,
      comment_count: count(c.id),
      avg_rating: avg(r.score)
    },
    order_by: [desc: count(c.id)]
  )
  |> Repo.all()
end
```
</details>

## Exercise 3: Custom Changeset Function

Create a changeset for publishing a snippet that validates additional requirements.

```elixir
# File: lib/snippetbox/snippets/snippet.ex

def publish_changeset(snippet, attrs) do
  # Requirements for publishing:
  # - Title must be at least 10 characters
  # - Content must be at least 50 characters
  # - Must have a description
  # - Must have at least one tag
  # - Sets published_at to current time
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def publish_changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :description])
  |> validate_required([:title, :content, :description])
  |> validate_length(:title, min: 10)
  |> validate_length(:content, min: 50)
  |> validate_has_tags()
  |> put_change(:published_at, DateTime.utc_now() |> DateTime.truncate(:second))
end

defp validate_has_tags(changeset) do
  snippet = changeset.data

  if Ecto.assoc_loaded?(snippet.tags) and length(snippet.tags) > 0 do
    changeset
  else
    add_error(changeset, :tags, "must have at least one tag to publish")
  end
end
```
</details>

## Exercise 4: Transactions

Implement a function that creates a snippet with tags atomically.

```elixir
# File: lib/snippetbox/snippets.ex

def create_snippet_with_tags(attrs, tag_names) do
  # 1. Create snippet
  # 2. Create or find tags by name
  # 3. Associate tags with snippet
  # 4. All in one transaction
  # 5. Return {:ok, snippet_with_tags} or {:error, changeset}
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def create_snippet_with_tags(attrs, tag_names) do
  Repo.transaction(fn ->
    with {:ok, snippet} <- create_snippet(attrs),
         {:ok, tags} <- find_or_create_tags(tag_names),
         {:ok, snippet} <- associate_tags(snippet, tags) do
      snippet
    else
      {:error, changeset} -> Repo.rollback(changeset)
    end
  end)
end

defp find_or_create_tags(names) do
  tags =
    Enum.map(names, fn name ->
      case Repo.get_by(Tag, name: name) do
        nil ->
          %Tag{}
          |> Tag.changeset(%{name: name})
          |> Repo.insert!()
        tag ->
          tag
      end
    end)

  {:ok, tags}
rescue
  e -> {:error, e}
end

defp associate_tags(snippet, tags) do
  snippet
  |> Repo.preload(:tags)
  |> Ecto.Changeset.change()
  |> Ecto.Changeset.put_assoc(:tags, tags)
  |> Repo.update()
end
```
</details>

## Exercise 5: Pagination

Implement cursor-based pagination for snippets.

```elixir
# File: lib/snippetbox/snippets.ex

def list_snippets_paginated(opts \\ []) do
  # Options:
  # - limit: number of items (default 20)
  # - cursor: last item's id from previous page
  # - direction: :after or :before cursor

  # Return: %{items: [...], next_cursor: id, has_more: boolean}
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def list_snippets_paginated(opts \\ []) do
  limit = Keyword.get(opts, :limit, 20)
  cursor = Keyword.get(opts, :cursor)
  direction = Keyword.get(opts, :direction, :after)

  query = from(s in Snippet, order_by: [desc: s.id], limit: ^(limit + 1))

  query =
    case {cursor, direction} do
      {nil, _} -> query
      {cursor, :after} -> from(s in query, where: s.id < ^cursor)
      {cursor, :before} -> from(s in query, where: s.id > ^cursor)
    end

  items = Repo.all(query)
  has_more = length(items) > limit
  items = Enum.take(items, limit)

  next_cursor =
    case List.last(items) do
      nil -> nil
      item -> item.id
    end

  %{
    items: items,
    next_cursor: next_cursor,
    has_more: has_more
  }
end
```
</details>

## Exercise 6: Search with Full-Text

Implement full-text search for snippets.

```elixir
# Create migration for search
defmodule Snippetbox.Repo.Migrations.AddSearchToSnippets do
  use Ecto.Migration

  def up do
    # Add tsvector column and index
  end

  def down do
    # Remove search column and index
  end
end

# In Snippets context
def search(query_string, opts \\ []) do
  # Full-text search on title and content
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
# Migration
def up do
  execute """
  ALTER TABLE snippets
  ADD COLUMN search_vector tsvector
  GENERATED ALWAYS AS (
    setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(content, '')), 'B')
  ) STORED
  """

  execute "CREATE INDEX snippets_search_idx ON snippets USING GIN (search_vector)"
end

def down do
  execute "DROP INDEX snippets_search_idx"
  execute "ALTER TABLE snippets DROP COLUMN search_vector"
end

# Context function
def search(query_string, opts \\ []) do
  limit = Keyword.get(opts, :limit, 20)

  from(s in Snippet,
    where: fragment(
      "search_vector @@ plainto_tsquery('english', ?)",
      ^query_string
    ),
    order_by: fragment(
      "ts_rank(search_vector, plainto_tsquery('english', ?)) DESC",
      ^query_string
    ),
    limit: ^limit
  )
  |> Repo.all()
end
```
</details>

## Challenge: Implement Soft Deletes

Add soft delete functionality to snippets:

1. Add `deleted_at` column
2. Modify queries to exclude deleted records by default
3. Add `delete_snippet/1` that sets `deleted_at`
4. Add `restore_snippet/1` to undelete
5. Add `list_deleted_snippets/0` for admin

```elixir
# Your implementation here
```

This exercise tests your understanding of:
- Schema modifications
- Query composition
- Default scopes
- Business logic in contexts
