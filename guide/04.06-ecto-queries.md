# Chapter 4.6: Ecto Queries

Ecto provides a powerful query DSL for building database queries. In this chapter, we'll learn how to write queries from simple selects to complex joins.

## Query Basics

### Import and Alias

```elixir
import Ecto.Query
alias Snippetbox.Repo
alias Snippetbox.Snippets.Snippet
```

### Query Syntax

Ecto supports two query syntaxes:

```elixir
# Keyword syntax (more readable)
from s in Snippet,
  where: s.is_public == true,
  order_by: [desc: s.inserted_at],
  limit: 10

# Pipe syntax (more composable)
Snippet
|> where([s], s.is_public == true)
|> order_by([s], desc: s.inserted_at)
|> limit(10)
```

Both produce identical SQL.

## Selecting Data

### Select All Fields

```elixir
# Default: returns full structs
Repo.all(from s in Snippet)
# => [%Snippet{id: 1, title: "...", ...}, ...]
```

### Select Specific Fields

```elixir
# Select as map
Repo.all(from s in Snippet, select: %{id: s.id, title: s.title})
# => [%{id: 1, title: "Hello"}, ...]

# Select as tuple
Repo.all(from s in Snippet, select: {s.id, s.title})
# => [{1, "Hello"}, {2, "World"}, ...]

# Select single field
Repo.all(from s in Snippet, select: s.title)
# => ["Hello", "World", ...]

# Select with expressions
Repo.all(from s in Snippet,
  select: %{
    id: s.id,
    title: s.title,
    length: fragment("length(?)", s.content)
  }
)
```

### Select Into Struct

```elixir
Repo.all(from s in Snippet,
  select: %Snippet{id: s.id, title: s.title}
)
```

## Filtering with Where

### Basic Conditions

```elixir
# Equality
from s in Snippet, where: s.is_public == true

# Not equal
from s in Snippet, where: s.language != "text"

# Comparison
from s in Snippet, where: s.views_count > 100

# NULL check
from s in Snippet, where: is_nil(s.expires_at)
from s in Snippet, where: not is_nil(s.expires_at)
```

### Using Variables (Pinning)

```elixir
language = "elixir"
min_views = 100

# Pin external values with ^
from s in Snippet,
  where: s.language == ^language,
  where: s.views_count >= ^min_views
```

### Multiple Conditions

```elixir
# AND (multiple where clauses)
from s in Snippet,
  where: s.is_public == true,
  where: s.views_count > 100

# Explicit AND
from s in Snippet,
  where: s.is_public == true and s.views_count > 100

# OR
from s in Snippet,
  where: s.language == "elixir" or s.language == "ruby"
```

### IN Operator

```elixir
languages = ["elixir", "ruby", "python"]

from s in Snippet,
  where: s.language in ^languages

# NOT IN
from s in Snippet,
  where: s.language not in ^languages
```

### LIKE Queries

```elixir
# Contains
from s in Snippet,
  where: like(s.title, "%elixir%")

# Case-insensitive (PostgreSQL)
from s in Snippet,
  where: ilike(s.title, "%elixir%")

# Dynamic pattern
search = "%#{term}%"
from s in Snippet, where: ilike(s.title, ^search)
```

### Date/Time Comparisons

```elixir
now = DateTime.utc_now()

# Not expired
from s in Snippet,
  where: is_nil(s.expires_at) or s.expires_at > ^now

# Created in last 7 days
week_ago = DateTime.add(now, -7, :day)
from s in Snippet,
  where: s.inserted_at > ^week_ago
```

## Ordering

```elixir
# Ascending (default)
from s in Snippet, order_by: s.title

# Descending
from s in Snippet, order_by: [desc: s.inserted_at]

# Multiple columns
from s in Snippet, order_by: [asc: s.language, desc: s.views_count]

# With NULL handling
from s in Snippet, order_by: [asc_nulls_last: s.expires_at]
```

## Limiting and Offset

```elixir
# Basic pagination
from s in Snippet,
  order_by: [desc: s.inserted_at],
  limit: 20,
  offset: 40  # Page 3 (0-indexed)

# Dynamic values
page = 3
per_page = 20
from s in Snippet,
  limit: ^per_page,
  offset: ^((page - 1) * per_page)
```

## Grouping and Aggregates

```elixir
# Count by language
from s in Snippet,
  group_by: s.language,
  select: {s.language, count(s.id)}
# => [{"elixir", 42}, {"ruby", 30}, ...]

# With having
from s in Snippet,
  group_by: s.language,
  having: count(s.id) > 10,
  select: {s.language, count(s.id)}

# Multiple aggregates
from s in Snippet,
  group_by: s.language,
  select: %{
    language: s.language,
    count: count(s.id),
    total_views: sum(s.views_count),
    avg_views: avg(s.views_count)
  }
```

## Joins

### Basic Join

```elixir
# Inner join
from s in Snippet,
  join: u in User, on: s.user_id == u.id,
  select: {s.title, u.name}

# With association
from s in Snippet,
  join: u in assoc(s, :user),
  select: {s.title, u.name}
```

### Join Types

```elixir
# Left join (include snippets without users)
from s in Snippet,
  left_join: u in assoc(s, :user),
  select: {s.title, u.name}  # u.name may be nil

# Right join
from u in User,
  right_join: s in assoc(u, :snippets),
  select: {u.name, s.title}
```

### Multiple Joins

```elixir
from s in Snippet,
  join: u in assoc(s, :user),
  join: t in assoc(s, :tags),
  where: t.name == "elixir",
  select: %{title: s.title, author: u.name}
```

### Named Bindings

```elixir
from s in Snippet,
  join: u in assoc(s, :user), as: :author,
  join: t in assoc(s, :tags), as: :tag,
  where: as(:tag).name == "elixir",
  select: %{title: s.title, author: as(:author).name}
```

## Composing Queries

### Pipe Syntax

```elixir
Snippet
|> where([s], s.is_public == true)
|> where([s], s.language == "elixir")
|> order_by([s], desc: s.inserted_at)
|> limit(10)
|> Repo.all()
```

### Building Queries Dynamically

```elixir
def list_snippets(opts \\ []) do
  Snippet
  |> filter_by_language(opts[:language])
  |> filter_by_public(opts[:public_only])
  |> filter_by_user(opts[:user_id])
  |> sort_by(opts[:sort])
  |> paginate(opts[:page], opts[:per_page])
  |> Repo.all()
end

defp filter_by_language(query, nil), do: query
defp filter_by_language(query, language) do
  where(query, [s], s.language == ^language)
end

defp filter_by_public(query, true) do
  where(query, [s], s.is_public == true)
end
defp filter_by_public(query, _), do: query

defp filter_by_user(query, nil), do: query
defp filter_by_user(query, user_id) do
  where(query, [s], s.user_id == ^user_id)
end

defp sort_by(query, "oldest"), do: order_by(query, [s], asc: s.inserted_at)
defp sort_by(query, "popular"), do: order_by(query, [s], desc: s.views_count)
defp sort_by(query, _), do: order_by(query, [s], desc: s.inserted_at)

defp paginate(query, page, per_page) do
  page = page || 1
  per_page = per_page || 20

  query
  |> limit(^per_page)
  |> offset(^((page - 1) * per_page))
end
```

### Query as Starting Point

```elixir
# Base query
def base_query do
  from s in Snippet,
    where: s.is_public == true,
    where: is_nil(s.expires_at) or s.expires_at > ^DateTime.utc_now()
end

# Build on base
def recent_snippets do
  base_query()
  |> order_by([s], desc: s.inserted_at)
  |> limit(10)
  |> Repo.all()
end

def popular_snippets do
  base_query()
  |> order_by([s], desc: s.views_count)
  |> limit(10)
  |> Repo.all()
end
```

## Subqueries

```elixir
# Subquery for popular snippet IDs
popular_ids = from s in Snippet,
  where: s.views_count > 1000,
  select: s.id

# Use in main query
from s in Snippet,
  where: s.id in subquery(popular_ids)
```

## Raw SQL Fragments

```elixir
# Fragment for database-specific functions
from s in Snippet,
  where: fragment("length(?) > ?", s.content, 1000)

# Select with fragment
from s in Snippet,
  select: %{
    title: s.title,
    word_count: fragment("array_length(string_to_array(?, ' '), 1)", s.content)
  }

# Full-text search (PostgreSQL)
from s in Snippet,
  where: fragment("to_tsvector('english', ?) @@ plainto_tsquery('english', ?)",
                  s.content, ^search_term)
```

## Explain Query

Debug query performance:

```elixir
query = from s in Snippet,
  where: s.is_public == true,
  order_by: [desc: s.inserted_at]

Repo.explain(:all, query)
# Prints PostgreSQL EXPLAIN output
```

> **FP Concept: Query as Data Structure**
>
> Ecto queries are data structures, not executed immediately:
>
> ```elixir
> query = from s in Snippet, where: s.is_public == true
> # query is just a struct, no database hit yet
>
> Repo.all(query)
> # NOW the query executes
> ```
>
> This enables:
> - **Composition**: Build complex queries from simple parts
> - **Reuse**: Define base queries and extend them
> - **Inspection**: Examine queries before execution
> - **Testing**: Test query construction without database
>
> **Further Reading**:
> - [Ecto.Query](https://hexdocs.pm/ecto/Ecto.Query.html)

## Summary

In this chapter, we learned:

- Query syntax (keyword and pipe)
- Selecting specific fields
- Filtering with `where` and various operators
- Ordering, limiting, and pagination
- Grouping and aggregates
- Joins and associations
- Composing queries dynamically
- Subqueries and raw SQL fragments

In the next chapter, we'll explore associations between schemas.

---

## Additional Information

### Query Debugging

```elixir
# Inspect generated SQL
query = from s in Snippet, where: s.is_public == true
Ecto.Adapters.SQL.to_sql(:all, Repo, query)
# => {"SELECT ... FROM snippets WHERE is_public = $1", [true]}

# Log all queries in config
config :snippetbox, Snippetbox.Repo, log: :debug
```

### Comparing to Other ORMs

**ActiveRecord (Rails)**:
```ruby
Snippet.where(is_public: true)
       .order(inserted_at: :desc)
       .limit(10)
```

**Django**:
```python
Snippet.objects.filter(is_public=True) \
       .order_by('-inserted_at')[:10]
```

**SQLAlchemy**:
```python
session.query(Snippet)
       .filter(Snippet.is_public == True)
       .order_by(Snippet.inserted_at.desc())
       .limit(10)
```

**Ecto**:
```elixir
from s in Snippet,
  where: s.is_public == true,
  order_by: [desc: s.inserted_at],
  limit: 10
```

Ecto's query syntax is more SQL-like, making it easier to understand the generated SQL.
