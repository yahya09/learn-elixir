# Chapter 3.2: Environment Variables

Environment variables are essential for keeping secrets out of your codebase and configuring applications across different deployment environments. In this chapter, we'll learn how to work with environment variables in Phoenix.

## Why Environment Variables?

Environment variables solve several problems:

1. **Security**: Secrets aren't committed to version control
2. **Flexibility**: Same code deploys to different environments
3. **12-Factor App**: Standard practice for cloud-native applications
4. **Separation**: Configuration separate from code

## Reading Environment Variables

In Elixir, use `System.get_env/1`:

```elixir
# Get environment variable (returns nil if not set)
System.get_env("DATABASE_URL")

# Get with default
System.get_env("PORT") || "4000"

# Get and convert type
String.to_integer(System.get_env("PORT") || "4000")
```

## The runtime.exs File

`config/runtime.exs` runs at application start, making it ideal for environment variables:

```elixir
# File: config/runtime.exs

import Config

if config_env() == :prod do
  # Required variables - raise if missing
  database_url =
    System.get_env("DATABASE_URL") ||
      raise """
      DATABASE_URL environment variable is missing.
      Example: ecto://USER:PASS@HOST/DATABASE
      """

  secret_key_base =
    System.get_env("SECRET_KEY_BASE") ||
      raise """
      SECRET_KEY_BASE environment variable is missing.
      Generate with: mix phx.gen.secret
      """

  # Optional variables with defaults
  pool_size = String.to_integer(System.get_env("POOL_SIZE") || "10")
  port = String.to_integer(System.get_env("PORT") || "4000")
  host = System.get_env("PHX_HOST") || "localhost"

  # Apply configuration
  config :snippetbox, Snippetbox.Repo,
    url: database_url,
    pool_size: pool_size,
    ssl: true

  config :snippetbox, SnippetboxWeb.Endpoint,
    url: [host: host, port: 443, scheme: "https"],
    http: [ip: {0, 0, 0, 0, 0, 0, 0, 0}, port: port],
    secret_key_base: secret_key_base
end
```

## Common Environment Variables

### Database Configuration

```elixir
# Single DATABASE_URL (recommended)
# Format: ecto://USER:PASSWORD@HOST:PORT/DATABASE
database_url = System.get_env("DATABASE_URL")

config :snippetbox, Snippetbox.Repo,
  url: database_url,
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10")

# Or individual variables
config :snippetbox, Snippetbox.Repo,
  username: System.get_env("DB_USER"),
  password: System.get_env("DB_PASSWORD"),
  hostname: System.get_env("DB_HOST"),
  database: System.get_env("DB_NAME"),
  port: String.to_integer(System.get_env("DB_PORT") || "5432")
```

### Application Secrets

```elixir
# Secret key for sessions and tokens
secret_key_base = System.get_env("SECRET_KEY_BASE")

# Live view signing salt
live_view_salt = System.get_env("LIVE_VIEW_SIGNING_SALT")

config :snippetbox, SnippetboxWeb.Endpoint,
  secret_key_base: secret_key_base,
  live_view: [signing_salt: live_view_salt]
```

### External Services

```elixir
# Email (SMTP)
config :snippetbox, Snippetbox.Mailer,
  adapter: Swoosh.Adapters.SMTP,
  relay: System.get_env("SMTP_HOST"),
  port: String.to_integer(System.get_env("SMTP_PORT") || "587"),
  username: System.get_env("SMTP_USERNAME"),
  password: System.get_env("SMTP_PASSWORD")

# AWS S3
config :ex_aws,
  access_key_id: System.get_env("AWS_ACCESS_KEY_ID"),
  secret_access_key: System.get_env("AWS_SECRET_ACCESS_KEY"),
  region: System.get_env("AWS_REGION") || "us-east-1"

# Stripe
config :stripity_stripe,
  api_key: System.get_env("STRIPE_SECRET_KEY")
```

## Development Environment Variables

### Using .env Files

Create a `.env` file for development (add to `.gitignore`!):

```bash
# File: .env

export DATABASE_URL="ecto://postgres:postgres@localhost/snippetbox_dev"
export SECRET_KEY_BASE="dev-only-secret-key-for-local-development"
export SMTP_HOST="localhost"
export SMTP_PORT="1025"
```

Load before starting the server:

```bash
$ source .env && mix phx.server
```

Or use direnv for automatic loading:

```bash
# Install direnv and allow the directory
$ brew install direnv
$ direnv allow .
```

### Using dotenvy

Add the `dotenvy` library for automatic `.env` loading in development:

```elixir
# File: mix.exs
defp deps do
  [
    {:dotenvy, "~> 0.8", only: [:dev, :test]}
  ]
end
```

```elixir
# File: config/runtime.exs

import Config

# Load .env file in dev/test
if config_env() in [:dev, :test] do
  Dotenvy.source([".env", ".env.#{config_env()}"])
end

# Rest of configuration...
```

### Sample .env File

```bash
# File: .env.sample (commit this to git)

# Database
DATABASE_URL=ecto://postgres:postgres@localhost/snippetbox_dev

# Application
SECRET_KEY_BASE=generate-with-mix-phx.gen.secret
PHX_HOST=localhost
PORT=4000

# Email (use Mailhog for development)
SMTP_HOST=localhost
SMTP_PORT=1025

# External Services (get from service dashboards)
# STRIPE_SECRET_KEY=sk_test_...
# AWS_ACCESS_KEY_ID=...
# AWS_SECRET_ACCESS_KEY=...
```

## Type Conversion Helpers

Create helpers for common conversions:

```elixir
# File: lib/snippetbox/env.ex

defmodule Snippetbox.Env do
  @moduledoc """
  Environment variable helpers with type conversion.
  """

  @doc """
  Get required environment variable. Raises if missing.
  """
  def get!(name) do
    System.get_env(name) ||
      raise "Environment variable #{name} is required"
  end

  @doc """
  Get optional environment variable with default.
  """
  def get(name, default \\ nil) do
    System.get_env(name) || default
  end

  @doc """
  Get environment variable as integer.
  """
  def get_integer(name, default) do
    case System.get_env(name) do
      nil -> default
      val -> String.to_integer(val)
    end
  end

  @doc """
  Get environment variable as boolean.
  """
  def get_boolean(name, default \\ false) do
    case System.get_env(name) do
      nil -> default
      "true" -> true
      "1" -> true
      _ -> false
    end
  end

  @doc """
  Get environment variable as list (comma-separated).
  """
  def get_list(name, default \\ []) do
    case System.get_env(name) do
      nil -> default
      val -> String.split(val, ",", trim: true)
    end
  end
end
```

Use in runtime.exs:

```elixir
# File: config/runtime.exs

import Config

if config_env() == :prod do
  import Snippetbox.Env

  config :snippetbox, Snippetbox.Repo,
    url: get!("DATABASE_URL"),
    pool_size: get_integer("POOL_SIZE", 10),
    ssl: get_boolean("DATABASE_SSL", true)

  config :snippetbox, SnippetboxWeb.Endpoint,
    secret_key_base: get!("SECRET_KEY_BASE"),
    http: [port: get_integer("PORT", 4000)]

  config :snippetbox,
    allowed_origins: get_list("ALLOWED_ORIGINS", ["https://snippetbox.com"])
end
```

## Validating Environment at Startup

Validate all required variables early:

```elixir
# File: lib/snippetbox/env.ex

defmodule Snippetbox.Env do
  # ... previous functions ...

  @required_vars ~w(
    DATABASE_URL
    SECRET_KEY_BASE
    PHX_HOST
  )

  @optional_vars ~w(
    PORT
    POOL_SIZE
    SMTP_HOST
  )

  def validate! do
    missing =
      @required_vars
      |> Enum.filter(&is_nil(System.get_env(&1)))

    if missing != [] do
      raise """
      Missing required environment variables:
      #{Enum.join(missing, "\n")}

      See .env.sample for required variables.
      """
    end

    :ok
  end

  def print_config do
    IO.puts("\n=== Environment Configuration ===")

    for var <- @required_vars ++ @optional_vars do
      value = System.get_env(var)
      masked = mask_sensitive(var, value)
      status = if value, do: "✓", else: "✗"
      IO.puts("#{status} #{var}: #{masked}")
    end

    IO.puts("================================\n")
  end

  defp mask_sensitive(name, nil), do: "(not set)"
  defp mask_sensitive(name, value) do
    if String.contains?(name, ["SECRET", "PASSWORD", "KEY"]) do
      String.slice(value, 0, 4) <> "****"
    else
      value
    end
  end
end
```

Call from application:

```elixir
# File: lib/snippetbox/application.ex

def start(_type, _args) do
  # Validate environment in production
  if Application.get_env(:snippetbox, :env) == :prod do
    Snippetbox.Env.validate!()
  end

  # Debug: print config (remove in production)
  if Application.get_env(:snippetbox, :env) == :dev do
    Snippetbox.Env.print_config()
  end

  children = [
    # ...
  ]

  Supervisor.start_link(children, opts)
end
```

## Platform-Specific Configuration

### Heroku

```elixir
# Heroku sets DATABASE_URL automatically
# Other config via heroku config:set

# File: config/runtime.exs
if config_env() == :prod do
  # Heroku provides PORT
  port = String.to_integer(System.get_env("PORT") || "4000")

  config :snippetbox, SnippetboxWeb.Endpoint,
    http: [ip: {0, 0, 0, 0, 0, 0, 0, 0}, port: port],
    url: [host: System.get_env("PHX_HOST"), port: 443, scheme: "https"]
end
```

### Docker

```dockerfile
# File: Dockerfile

ENV PORT=4000
ENV MIX_ENV=prod

# Set at runtime
# docker run -e DATABASE_URL=... -e SECRET_KEY_BASE=... app
```

```yaml
# File: docker-compose.yml

services:
  web:
    build: .
    environment:
      - DATABASE_URL=ecto://postgres:postgres@db/snippetbox
      - SECRET_KEY_BASE=${SECRET_KEY_BASE}
      - PHX_HOST=localhost
    env_file:
      - .env.production
```

### Fly.io

```bash
# Set secrets
$ fly secrets set DATABASE_URL="..."
$ fly secrets set SECRET_KEY_BASE="..."

# View secrets
$ fly secrets list
```

```elixir
# File: config/runtime.exs
if config_env() == :prod do
  # Fly.io provides FLY_APP_NAME
  app_name = System.get_env("FLY_APP_NAME")

  config :snippetbox, SnippetboxWeb.Endpoint,
    url: [host: "#{app_name}.fly.dev", port: 443, scheme: "https"]
end
```

## Secrets Management

### Using Mix Secrets (Development)

```bash
# Encrypt secrets
$ mix phx.gen.secret > priv/secrets/secret_key_base.txt
$ mix archive.install hex mix_encrypt

# Use encrypted secrets in config
```

### Using External Secret Managers

```elixir
# AWS Secrets Manager
defmodule Snippetbox.Secrets do
  def get_secret(name) do
    {:ok, response} = ExAws.SecretsManager.get_secret_value(name)
    |> ExAws.request()

    response["SecretString"]
  end
end

# HashiCorp Vault
defmodule Snippetbox.Secrets do
  def get_secret(path) do
    {:ok, response} = Vault.read(path)
    response.data
  end
end
```

> **FP Concept: Fail Fast**
>
> Notice how we raise on missing required config:
>
> ```elixir
> database_url =
>   System.get_env("DATABASE_URL") ||
>     raise "DATABASE_URL is required"
> ```
>
> This follows the "fail fast" principle:
> - **Early detection**: Problems caught at startup, not runtime
> - **Clear errors**: Descriptive message tells exactly what's wrong
> - **No silent failures**: App won't start in broken state
>
> In functional programming, we prefer explicit failures over implicit ones. A crash with a clear message is better than subtle bugs from nil values.
>
> **Further Reading**:
> - [Let It Crash Philosophy](https://ferd.ca/the-zen-of-erlang.html)

## Summary

In this chapter, we learned:

- Why environment variables are important
- Using `runtime.exs` for environment configuration
- Common environment variable patterns
- Loading `.env` files in development
- Type conversion helpers
- Validating environment at startup
- Platform-specific configuration

In the next chapter, we'll learn how to create custom error responses.

---

## Additional Information

### Environment Variable Naming

Follow these conventions:

| Type | Convention | Example |
|------|------------|---------|
| Database | `DATABASE_*` | `DATABASE_URL` |
| Application | `APP_*` or `PHX_*` | `PHX_HOST` |
| Services | `SERVICE_*` | `STRIPE_SECRET_KEY` |
| Features | `ENABLE_*` | `ENABLE_SIGNUP` |

### Never Commit Secrets

Add to `.gitignore`:

```gitignore
# Environment files
.env
.env.local
.env.*.local

# Secrets
*.pem
*.key
secrets/
```

### Comparing to Other Frameworks

**Node.js (dotenv)**:
```javascript
require('dotenv').config()
const dbUrl = process.env.DATABASE_URL
```

**Python (python-decouple)**:
```python
from decouple import config
DATABASE_URL = config('DATABASE_URL')
```

**Ruby (dotenv)**:
```ruby
Dotenv.load
ENV['DATABASE_URL']
```

**Elixir**:
```elixir
System.get_env("DATABASE_URL")
```

All frameworks follow similar patterns, but Elixir's `runtime.exs` provides a clean separation of compile-time vs runtime configuration.
