# Chapter 13.6: Test Best Practices

Effective testing requires good organization, coverage, and maintainability. In this chapter, we'll explore testing best practices for Phoenix applications.

## Test Coverage

### Enabling Coverage

```bash
# Run tests with coverage
mix test --cover

# Generate HTML report
mix test --cover --export-coverage default
mix phx.coverage
```

### ExCoveralls

```elixir
# File: mix.exs

defp deps do
  [
    {:excoveralls, "~> 0.18", only: :test}
  ]
end

def project do
  [
    # ...
    test_coverage: [tool: ExCoveralls],
    preferred_cli_env: [
      coveralls: :test,
      "coveralls.detail": :test,
      "coveralls.post": :test,
      "coveralls.html": :test
    ]
  ]
end
```

```bash
# Generate coverage reports
mix coveralls
mix coveralls.html
mix coveralls.detail
```

### Coverage Configuration

```elixir
# File: coveralls.json

{
  "coverage_options": {
    "minimum_coverage": 80,
    "treat_no_relevant_lines_as_covered": true
  },
  "skip_files": [
    "lib/snippetbox_web.ex",
    "lib/snippetbox/release.ex",
    "test/support"
  ]
}
```

## Test Organization

### Directory Structure

```
test/
├── snippetbox/
│   ├── accounts/
│   │   ├── user_test.exs
│   │   └── user_token_test.exs
│   ├── snippets/
│   │   ├── snippet_test.exs
│   │   └── tag_test.exs
│   ├── accounts_test.exs
│   └── snippets_test.exs
├── snippetbox_web/
│   ├── controllers/
│   │   ├── api/
│   │   │   └── snippet_controller_test.exs
│   │   ├── page_controller_test.exs
│   │   ├── snippet_controller_test.exs
│   │   └── user_session_controller_test.exs
│   ├── live/
│   │   ├── snippet_live_test.exs
│   │   └── user_settings_live_test.exs
│   ├── plugs/
│   │   └── require_auth_test.exs
│   └── components/
│       └── core_components_test.exs
├── support/
│   ├── conn_case.ex
│   ├── data_case.ex
│   ├── feature_case.ex
│   ├── fixtures/
│   │   ├── accounts_fixtures.ex
│   │   └── snippets_fixtures.ex
│   └── test_helpers.ex
└── test_helper.exs
```

### Naming Conventions

```elixir
# Test module name matches source module
# lib/snippetbox/snippets.ex
# test/snippetbox/snippets_test.exs

# Describe blocks for grouping
describe "create_snippet/1" do
  test "with valid data creates a snippet" do
  end

  test "with invalid data returns error" do
  end
end
```

## Writing Good Tests

### Test Structure (Arrange-Act-Assert)

```elixir
test "creates snippet with valid data" do
  # Arrange
  user = user_fixture()
  attrs = %{title: "Test", content: "code", language: "elixir"}

  # Act
  {:ok, snippet} = Snippets.create_snippet(user, attrs)

  # Assert
  assert snippet.title == "Test"
  assert snippet.user_id == user.id
end
```

### Descriptive Test Names

```elixir
# Bad: vague test names
test "test snippet" do
end

test "it works" do
end

# Good: descriptive test names
test "create_snippet/1 with valid data creates a snippet" do
end

test "create_snippet/1 with empty title returns error changeset" do
end

test "list_snippets/1 filters by language when language param provided" do
end
```

### One Assertion Per Test (Generally)

```elixir
# Multiple related assertions are OK
test "creates snippet with all attributes" do
  {:ok, snippet} = Snippets.create_snippet(@valid_attrs)

  assert snippet.title == "Test"
  assert snippet.content == "code"
  assert snippet.language == "elixir"
end

# But separate unrelated assertions
test "sets default view_count to 0" do
  {:ok, snippet} = Snippets.create_snippet(@valid_attrs)
  assert snippet.view_count == 0
end

test "sets inserted_at timestamp" do
  {:ok, snippet} = Snippets.create_snippet(@valid_attrs)
  assert snippet.inserted_at != nil
end
```

## Testing Edge Cases

```elixir
describe "edge cases" do
  test "handles empty list" do
    assert Snippets.list_snippets() == []
  end

  test "handles nil input" do
    assert {:error, _} = Snippets.create_snippet(nil)
  end

  test "handles unicode characters" do
    {:ok, snippet} = Snippets.create_snippet(%{
      title: "日本語タイトル",
      content: "# Привет мир",
      language: "elixir"
    })

    assert snippet.title == "日本語タイトル"
  end

  test "handles very long content" do
    long_content = String.duplicate("a", 100_000)

    {:ok, snippet} = Snippets.create_snippet(%{
      title: "Long",
      content: long_content,
      language: "elixir"
    })

    assert String.length(snippet.content) == 100_000
  end

  test "handles concurrent creation" do
    tasks = for i <- 1..10 do
      Task.async(fn ->
        Snippets.create_snippet(%{
          title: "Concurrent #{i}",
          content: "code",
          language: "elixir"
        })
      end)
    end

    results = Task.await_many(tasks)

    assert Enum.all?(results, &match?({:ok, _}, &1))
    assert Snippets.count_snippets() == 10
  end
end
```

## Mocking and Stubbing

### Using Mox

```elixir
# File: mix.exs
{:mox, "~> 1.0", only: :test}

# File: lib/snippetbox/http_client.ex
defmodule Snippetbox.HTTPClient do
  @callback get(String.t()) :: {:ok, map()} | {:error, term()}
end

# File: lib/snippetbox/http_client/hackney.ex
defmodule Snippetbox.HTTPClient.Hackney do
  @behaviour Snippetbox.HTTPClient

  def get(url) do
    # Real HTTP call
  end
end

# File: config/test.exs
config :snippetbox, :http_client, Snippetbox.HTTPClient.Mock

# File: test/support/mocks.ex
Mox.defmock(Snippetbox.HTTPClient.Mock, for: Snippetbox.HTTPClient)

# File: test/test_helper.exs
Code.require_file("support/mocks.ex", __DIR__)
```

```elixir
# Usage in tests
defmodule Snippetbox.ExternalApiTest do
  use Snippetbox.DataCase

  import Mox

  setup :verify_on_exit!

  test "fetches data from external API" do
    expect(Snippetbox.HTTPClient.Mock, :get, fn url ->
      assert url == "https://api.example.com/data"
      {:ok, %{"items" => [1, 2, 3]}}
    end)

    assert {:ok, items} = ExternalApi.fetch_items()
    assert items == [1, 2, 3]
  end

  test "handles API error" do
    expect(Snippetbox.HTTPClient.Mock, :get, fn _ ->
      {:error, :timeout}
    end)

    assert {:error, :timeout} = ExternalApi.fetch_items()
  end
end
```

### Bypass for HTTP

```elixir
# File: mix.exs
{:bypass, "~> 2.1", only: :test}

# Usage
defmodule Snippetbox.WebhookTest do
  use Snippetbox.DataCase

  setup do
    bypass = Bypass.open()
    {:ok, bypass: bypass}
  end

  test "sends webhook successfully", %{bypass: bypass} do
    Bypass.expect_once(bypass, "POST", "/webhook", fn conn ->
      {:ok, body, conn} = Plug.Conn.read_body(conn)
      assert Jason.decode!(body)["event"] == "snippet_created"
      Plug.Conn.resp(conn, 200, "OK")
    end)

    url = "http://localhost:#{bypass.port}/webhook"
    assert :ok = Webhooks.send(url, %{event: "snippet_created"})
  end
end
```

## Property-Based Testing

```elixir
# File: mix.exs
{:stream_data, "~> 1.0", only: [:dev, :test]}

# Usage
defmodule Snippetbox.StringHelperPropertyTest do
  use ExUnit.Case
  use ExUnitProperties

  alias Snippetbox.Helpers.StringHelper

  property "truncate never exceeds max length" do
    check all string <- string(:alphanumeric),
              max_length <- positive_integer(),
              max_length > 3 do
      result = StringHelper.truncate(string, max_length)
      assert String.length(result) <= max_length + 3  # +3 for "..."
    end
  end

  property "slugify produces valid slugs" do
    check all string <- string(:alphanumeric, min_length: 1) do
      slug = StringHelper.slugify(string)
      assert slug =~ ~r/^[a-z0-9-]*$/
    end
  end

  property "reversible encoding" do
    check all data <- binary() do
      encoded = Base.encode64(data)
      assert Base.decode64!(encoded) == data
    end
  end
end
```

## Test Performance

### Parallel Testing

```elixir
# Enable async for independent tests
use Snippetbox.DataCase, async: true

# Disable for tests that need shared state
use Snippetbox.DataCase, async: false
```

### Avoid Slow Operations

```elixir
# Bad: slow password hashing in tests
config :bcrypt_elixir, :log_rounds, 12  # Slow!

# Good: fast password hashing for tests
# config/test.exs
config :bcrypt_elixir, :log_rounds, 1
```

### Use ExUnit Tags

```elixir
# Tag slow tests
@tag :slow
test "complex aggregation query" do
  # ...
end

# Run without slow tests
# mix test --exclude slow

# Run only slow tests
# mix test --only slow
```

## Continuous Integration

### GitHub Actions

```yaml
# File: .github/workflows/test.yml

name: Test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3

      - name: Set up Elixir
        uses: erlef/setup-beam@v1
        with:
          elixir-version: '1.16'
          otp-version: '26'

      - name: Cache deps
        uses: actions/cache@v3
        with:
          path: deps
          key: ${{ runner.os }}-mix-${{ hashFiles('**/mix.lock') }}

      - name: Install dependencies
        run: mix deps.get

      - name: Setup database
        run: mix ecto.setup
        env:
          MIX_ENV: test

      - name: Run tests
        run: mix test --cover

      - name: Check formatting
        run: mix format --check-formatted

      - name: Run Credo
        run: mix credo --strict
```

## Test Helpers

```elixir
# File: test/support/test_helpers.ex

defmodule Snippetbox.TestHelpers do
  @doc """
  Waits for a condition to be true.
  """
  def eventually(func, timeout \\ 1000) do
    end_time = System.monotonic_time(:millisecond) + timeout
    do_eventually(func, end_time)
  end

  defp do_eventually(func, end_time) do
    if func.() do
      :ok
    else
      if System.monotonic_time(:millisecond) < end_time do
        Process.sleep(10)
        do_eventually(func, end_time)
      else
        raise "Condition not met within timeout"
      end
    end
  end

  @doc """
  Asserts that a function eventually returns true.
  """
  defmacro assert_eventually(expr, timeout \\ 1000) do
    quote do
      Snippetbox.TestHelpers.eventually(fn -> unquote(expr) end, unquote(timeout))
    end
  end
end
```

> **FP Concept: Pure Tests**
>
> The best tests verify pure transformations:
>
> ```elixir
> # Pure function test: predictable, fast, isolated
> test "add/2 returns sum" do
>   assert Calculator.add(2, 3) == 5  # Always true
> end
>
> # Impure function test: requires setup, slower
> test "create_snippet/1 persists data" do
>   # Requires database connection
>   # Has side effects
>   # Order matters
> end
> ```
>
> Maximize pure functions in your codebase to maximize testability.

## Summary

In this chapter, we learned:

- Test coverage tools (ExCoveralls)
- Test organization and naming
- Writing good tests (AAA pattern)
- Testing edge cases
- Mocking with Mox and Bypass
- Property-based testing
- Test performance optimization
- CI/CD integration
- Useful test helpers

This completes the Testing chapter. In the next chapter, we'll explore deployment strategies for Phoenix applications.
