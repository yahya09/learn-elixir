# Chapter 14.5: Monitoring and Observability

Monitoring production applications is essential for reliability. In this chapter, we'll explore observability tools for Phoenix applications.

## The Three Pillars

```
Observability
├── Logging - What happened?
├── Metrics - How much/how often?
└── Tracing - How long/where?
```

## Phoenix Dashboard

Phoenix LiveDashboard provides real-time monitoring:

### Setup

```elixir
# mix.exs
{:phoenix_live_dashboard, "~> 0.8"}

# router.ex
import Phoenix.LiveDashboard.Router

scope "/" do
  pipe_through [:browser, :require_admin]
  live_dashboard "/dashboard",
    metrics: SnippetboxWeb.Telemetry,
    ecto_repos: [Snippetbox.Repo],
    ecto_psql_extras_options: [long_running_queries: [threshold: "200 milliseconds"]]
end
```

### Production Access

```elixir
# lib/snippetbox_web/router.ex

defp require_admin(conn, _opts) do
  if conn.assigns[:current_user] && conn.assigns[:current_user].admin do
    conn
  else
    conn
    |> put_flash(:error, "Unauthorized")
    |> redirect(to: ~p"/")
    |> halt()
  end
end

# Or with basic auth
pipeline :dashboard_auth do
  plug :dashboard_basic_auth
end

defp dashboard_basic_auth(conn, _opts) do
  username = System.fetch_env!("DASHBOARD_USER")
  password = System.fetch_env!("DASHBOARD_PASSWORD")
  Plug.BasicAuth.basic_auth(conn, username: username, password: password)
end
```

## Telemetry

### Telemetry Module

```elixir
# File: lib/snippetbox_web/telemetry.ex

defmodule SnippetboxWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary("phoenix.endpoint.start.system_time",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.endpoint.stop.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.stop.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),

      # LiveView Metrics
      summary("phoenix.live_view.mount.stop.duration",
        unit: {:native, :millisecond},
        tags: [:view]
      ),
      summary("phoenix.live_view.handle_event.stop.duration",
        unit: {:native, :millisecond},
        tags: [:view, :event]
      ),

      # Database Metrics
      summary("snippetbox.repo.query.total_time",
        unit: {:native, :millisecond},
        description: "Total query time"
      ),
      summary("snippetbox.repo.query.decode_time",
        unit: {:native, :millisecond}
      ),
      summary("snippetbox.repo.query.queue_time",
        unit: {:native, :millisecond}
      ),
      counter("snippetbox.repo.query.count"),

      # VM Metrics
      summary("vm.memory.total", unit: {:byte, :megabyte}),
      summary("vm.total_run_queue_lengths.total"),
      summary("vm.total_run_queue_lengths.cpu"),
      summary("vm.total_run_queue_lengths.io"),

      # Custom Business Metrics
      counter("snippetbox.snippets.created.count"),
      counter("snippetbox.users.registered.count"),
      summary("snippetbox.snippets.view_duration",
        unit: {:native, :millisecond}
      )
    ]
  end

  defp periodic_measurements do
    [
      {__MODULE__, :measure_users_online, []},
      {__MODULE__, :measure_snippets_count, []}
    ]
  end

  def measure_users_online do
    count = SnippetboxWeb.Presence.list("users:online") |> map_size()
    :telemetry.execute([:snippetbox, :users, :online], %{count: count}, %{})
  end

  def measure_snippets_count do
    count = Snippetbox.Snippets.count_snippets()
    :telemetry.execute([:snippetbox, :snippets, :total], %{count: count}, %{})
  end
end
```

### Custom Telemetry Events

```elixir
# Emit custom event
:telemetry.execute(
  [:snippetbox, :snippets, :created],
  %{count: 1},
  %{language: snippet.language}
)

# In context
def create_snippet(attrs) do
  result = %Snippet{}
  |> Snippet.changeset(attrs)
  |> Repo.insert()

  case result do
    {:ok, snippet} ->
      :telemetry.execute([:snippetbox, :snippets, :created], %{count: 1}, %{
        language: snippet.language,
        user_id: snippet.user_id
      })
      result

    error ->
      error
  end
end
```

## Prometheus Metrics

### Setup

```elixir
# mix.exs
{:telemetry_metrics_prometheus, "~> 1.1"}

# application.ex
def start(_type, _args) do
  children = [
    SnippetboxWeb.Telemetry,
    TelemetryMetricsPrometheus.Core.child_spec(
      metrics: SnippetboxWeb.Telemetry.metrics()
    ),
    # ...
  ]
end

# router.ex
get "/metrics", TelemetryMetricsPrometheus.Core, []
```

### Prometheus Configuration

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'snippetbox'
    static_configs:
      - targets: ['app:4000']
    metrics_path: '/metrics'
    scrape_interval: 15s
```

## Structured Logging

### Logger Configuration

```elixir
# config/prod.exs
config :logger, :console,
  format: {SnippetboxWeb.LogFormatter, :format},
  metadata: [:request_id, :user_id, :trace_id]
```

### Custom Log Formatter

```elixir
# File: lib/snippetbox_web/log_formatter.ex

defmodule SnippetboxWeb.LogFormatter do
  def format(level, message, timestamp, metadata) do
    %{
      timestamp: format_timestamp(timestamp),
      level: level,
      message: IO.iodata_to_binary(message),
      metadata: Map.new(metadata)
    }
    |> Jason.encode!()
    |> Kernel.<>("\n")
  rescue
    _ -> "#{inspect({level, message, metadata})}\n"
  end

  defp format_timestamp({date, {hour, min, sec, _ms}}) do
    NaiveDateTime.from_erl!({date, {hour, min, sec}})
    |> NaiveDateTime.to_iso8601()
  end
end
```

### Request Logging

```elixir
# File: lib/snippetbox_web/plugs/request_logger.ex

defmodule SnippetboxWeb.Plugs.RequestLogger do
  require Logger

  def init(opts), do: opts

  def call(conn, _opts) do
    start = System.monotonic_time()

    Plug.Conn.register_before_send(conn, fn conn ->
      stop = System.monotonic_time()
      duration = System.convert_time_unit(stop - start, :native, :millisecond)

      Logger.info("Request completed",
        method: conn.method,
        path: conn.request_path,
        status: conn.status,
        duration_ms: duration,
        user_id: get_in(conn.assigns, [:current_user, :id])
      )

      conn
    end)
  end
end
```

## Error Tracking

### Sentry Integration

```elixir
# mix.exs
{:sentry, "~> 10.0"},
{:hackney, "~> 1.8"}

# config/runtime.exs
config :sentry,
  dsn: System.get_env("SENTRY_DSN"),
  environment_name: config_env(),
  enable_source_code_context: true,
  root_source_code_paths: [File.cwd!()],
  tags: %{
    env: config_env()
  },
  included_environments: [:prod]

# endpoint.ex
use Sentry.PlugCapture

# error_handler.ex
def handle_errors(conn, %{kind: kind, reason: reason, stack: stack}) do
  Sentry.capture_exception(
    reason,
    stacktrace: stack,
    extra: %{
      kind: kind,
      path: conn.request_path,
      method: conn.method
    }
  )

  send_resp(conn, conn.status, "Internal Server Error")
end
```

### Custom Error Context

```elixir
# Add context to errors
Sentry.Context.set_user_context(%{
  id: user.id,
  email: user.email
})

Sentry.Context.set_extra_context(%{
  snippet_id: snippet.id
})

# Capture with context
Sentry.capture_message("Something went wrong", extra: %{detail: "info"})
```

## Distributed Tracing

### OpenTelemetry Setup

```elixir
# mix.exs
{:opentelemetry, "~> 1.3"},
{:opentelemetry_api, "~> 1.2"},
{:opentelemetry_exporter, "~> 1.6"},
{:opentelemetry_phoenix, "~> 1.1"},
{:opentelemetry_ecto, "~> 1.1"}

# application.ex
def start(_type, _args) do
  OpentelemetryPhoenix.setup()
  OpentelemetryEcto.setup([:snippetbox, :repo])

  # ...
end

# config/runtime.exs
config :opentelemetry,
  span_processor: :batch,
  traces_exporter: :otlp

config :opentelemetry_exporter,
  otlp_protocol: :http_protobuf,
  otlp_endpoint: System.get_env("OTEL_EXPORTER_OTLP_ENDPOINT")
```

### Custom Spans

```elixir
require OpenTelemetry.Tracer, as: Tracer

def process_snippet(snippet) do
  Tracer.with_span "process_snippet" do
    Tracer.set_attribute("snippet.id", snippet.id)
    Tracer.set_attribute("snippet.language", snippet.language)

    result = do_processing(snippet)

    Tracer.add_event("processing_complete", %{})
    result
  end
end
```

## Health Checks and Readiness

```elixir
# File: lib/snippetbox_web/controllers/health_controller.ex

defmodule SnippetboxWeb.HealthController do
  use SnippetboxWeb, :controller

  # Liveness: Is the app running?
  def live(conn, _params) do
    json(conn, %{status: "ok"})
  end

  # Readiness: Can the app serve traffic?
  def ready(conn, _params) do
    checks = [
      {:database, check_database()},
      {:migrations, check_migrations()}
    ]

    if Enum.all?(checks, fn {_, status} -> status == :ok end) do
      json(conn, %{status: "ready", checks: Map.new(checks)})
    else
      conn
      |> put_status(:service_unavailable)
      |> json(%{status: "not_ready", checks: Map.new(checks)})
    end
  end

  defp check_database do
    case Ecto.Adapters.SQL.query(Snippetbox.Repo, "SELECT 1", []) do
      {:ok, _} -> :ok
      _ -> :error
    end
  end

  defp check_migrations do
    repo = Snippetbox.Repo
    migrations = Ecto.Migrator.migrations(repo)

    if Enum.all?(migrations, fn {status, _, _} -> status == :up end) do
      :ok
    else
      :pending
    end
  end
end
```

## Alerting

### Alert Rules

```yaml
# prometheus_alerts.yml
groups:
  - name: snippetbox
    rules:
      - alert: HighErrorRate
        expr: rate(phoenix_endpoint_stop_duration_count{status=~"5.."}[5m]) > 0.1
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: High error rate detected

      - alert: SlowRequests
        expr: histogram_quantile(0.95, rate(phoenix_endpoint_stop_duration_bucket[5m])) > 1000
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: 95th percentile latency above 1s

      - alert: DatabaseConnectionsLow
        expr: snippetbox_repo_pool_size - snippetbox_repo_pool_in_use < 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: Running low on database connections
```

## Monitoring Stack

### Docker Compose

```yaml
# docker-compose.monitoring.yml
version: "3.8"

services:
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    volumes:
      - grafana-data:/var/lib/grafana

  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "4317:4317"

volumes:
  grafana-data:
```

> **FP Concept: Observable Side Effects**
>
> Monitoring makes side effects observable:
>
> ```elixir
> # Function with side effect
> def create_snippet(attrs) do
>   Repo.insert(changeset)  # Side effect
> end
>
> # Observable function
> def create_snippet(attrs) do
>   :telemetry.span([:snippetbox, :snippet, :create], %{}, fn ->
>     result = Repo.insert(changeset)
>     {result, %{success: match?({:ok, _}, result)}}
>   end)
> end
>
> # Now we can observe: timing, success rate, frequency
> ```
>
> Telemetry wraps side effects with metadata for observability.

## Summary

In this chapter, we learned:

- Phoenix LiveDashboard
- Telemetry metrics
- Prometheus integration
- Structured logging
- Error tracking with Sentry
- Distributed tracing with OpenTelemetry
- Health checks and readiness probes
- Alerting strategies

This completes the Deployment chapter. You now have the knowledge to deploy and monitor Phoenix applications in production.
