# Chapter 2: Foundations

In this chapter, we'll lay the groundwork for our SnippetBox application. We'll start from scratch and build up the fundamental pieces of a Phoenix web application.

## What We'll Cover

By the end of this chapter, you'll understand:

- How to create a new Phoenix project
- The structure of a Phoenix application
- How routing works in Phoenix
- How to create controllers and actions
- How to render HTML templates
- How to serve static files (CSS, JavaScript, images)
- The request/response lifecycle in Phoenix

## The Phoenix Request Lifecycle

Before we dive into code, let's understand how Phoenix processes a web request:

```
Browser Request
    ↓
Endpoint (connection handling, parsing)
    ↓
Router (pattern matching on path)
    ↓
Pipeline (plugs for auth, logging, etc.)
    ↓
Controller Action (business logic)
    ↓
View (data preparation)
    ↓
Template (HTML rendering)
    ↓
Response sent to Browser
```

This is similar to the MVC pattern you might know from Rails, Django, or Laravel, but with some functional programming twists.

## Comparing to Other Frameworks

If you're coming from another framework, here's how Phoenix concepts map:

| Phoenix | Rails | Django | Laravel | Express |
|---------|-------|--------|---------|---------|
| Router | routes.rb | urls.py | routes/web.php | app.get() |
| Controller | Controller | View | Controller | Route handler |
| View | View Helper | Template Context | View | - |
| Template (EEx) | ERB | Django Template | Blade | EJS/Pug |
| Context | Model | Model/Manager | Model | - |
| Plug | Middleware | Middleware | Middleware | Middleware |

## Key Differences from OOP Frameworks

As we build our application, you'll notice some differences from traditional OOP frameworks:

**1. Immutability**
```elixir
# Data is never modified in place
conn = put_status(conn, 200)
# This creates a NEW conn with updated status
# The original conn is unchanged
```

**2. Pattern Matching**
```elixir
def show(conn, %{"id" => id}) do
  # Pattern match on params in function head
end
```

**3. Pipe Operator**
```elixir
conn
|> put_status(200)
|> put_resp_header("content-type", "application/json")
|> send_resp("{}")
```

**4. No Classes or Objects**
```elixir
# Instead of methods on objects, we use modules with functions
# SnippetController.show(conn, params)  # Not this
# show(conn, params)                     # But this
```

Don't worry if these concepts feel unfamiliar - we'll introduce them gradually as we build the application.

## What We're Building

In this chapter, we'll build the foundation of SnippetBox:

- A home page listing snippets
- A page to view a single snippet
- A page to create a new snippet
- Proper routing between these pages
- Basic HTML templates with a consistent layout
- Static CSS styling

This won't yet connect to a database - that comes in Chapter 4. For now, we'll use placeholder data to focus on understanding Phoenix fundamentals.

## A Note on Functional Programming

Throughout this chapter, you'll encounter functional programming concepts that might be new:

> **FP Concept: Functions as Data Transformers**
>
> In functional programming, we think of functions as data transformers. Instead of:
>
> ```python
> # Imperative (Python)
> user.update_email("new@example.com")  # Mutates user object
> ```
>
> We do:
>
> ```elixir
> # Functional (Elixir)
> updated_user = User.update_email(user, "new@example.com")  # Returns new user
> ```
>
> The original `user` is never modified. This eliminates a whole class of bugs related to shared mutable state.
>
> **Further Reading**:
> - [Elixir School - Functions](https://elixirschool.com/en/lessons/basics/functions)
> - [Joy of Elixir - Functions](https://joyofelixir.com/8-working-with-lists/)

Ready to start building? Let's create our Phoenix application in the next section.
