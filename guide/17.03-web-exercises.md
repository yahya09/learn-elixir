# Chapter 17.3: Web Layer Exercises

These exercises reinforce concepts from Chapters 5-8 covering templates, routing, forms, and controllers.

## Exercise 1: Custom Component

Create a reusable card component with slots.

```elixir
# File: lib/snippetbox_web/components/card_component.ex

defmodule SnippetboxWeb.Components.Card do
  use Phoenix.Component

  # Create a card component with:
  # - Required :title attribute
  # - Optional :subtitle attribute
  # - Optional :class attribute
  # - Required :inner_block slot (main content)
  # - Optional :footer slot
  # - Optional :actions slot (appears in header)
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.Components.Card do
  use Phoenix.Component

  attr :title, :string, required: true
  attr :subtitle, :string, default: nil
  attr :class, :string, default: ""

  slot :inner_block, required: true
  slot :footer
  slot :actions

  def card(assigns) do
    ~H"""
    <div class={["bg-white rounded-lg shadow-md overflow-hidden", @class]}>
      <div class="px-6 py-4 border-b flex justify-between items-center">
        <div>
          <h3 class="text-lg font-semibold"><%= @title %></h3>
          <p :if={@subtitle} class="text-sm text-gray-500"><%= @subtitle %></p>
        </div>
        <div :if={@actions != []} class="flex gap-2">
          <%= render_slot(@actions) %>
        </div>
      </div>

      <div class="px-6 py-4">
        <%= render_slot(@inner_block) %>
      </div>

      <div :if={@footer != []} class="px-6 py-4 bg-gray-50 border-t">
        <%= render_slot(@footer) %>
      </div>
    </div>
    """
  end
end
```
</details>

## Exercise 2: Nested Resources

Set up routes for nested comments under snippets.

```elixir
# File: lib/snippetbox_web/router.ex

# Create routes for:
# GET    /snippets/:snippet_id/comments          -> index
# GET    /snippets/:snippet_id/comments/:id      -> show
# POST   /snippets/:snippet_id/comments          -> create
# DELETE /snippets/:snippet_id/comments/:id      -> delete
```

Then implement the controller:

```elixir
# File: lib/snippetbox_web/controllers/comment_controller.ex

defmodule SnippetboxWeb.CommentController do
  use SnippetboxWeb, :controller

  # Implement index, show, create, delete
  # Each action should load the parent snippet first
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
# Router
resources "/snippets", SnippetController do
  resources "/comments", CommentController, only: [:index, :show, :create, :delete]
end

# Controller
defmodule SnippetboxWeb.CommentController do
  use SnippetboxWeb, :controller

  alias Snippetbox.{Snippets, Comments}

  plug :load_snippet

  def index(conn, _params) do
    comments = Comments.list_comments_for_snippet(conn.assigns.snippet.id)
    render(conn, :index, comments: comments)
  end

  def show(conn, %{"id" => id}) do
    comment = Comments.get_comment!(id)
    render(conn, :show, comment: comment)
  end

  def create(conn, %{"comment" => comment_params}) do
    params = Map.put(comment_params, "snippet_id", conn.assigns.snippet.id)

    case Comments.create_comment(params) do
      {:ok, comment} ->
        conn
        |> put_flash(:info, "Comment created.")
        |> redirect(to: ~p"/snippets/#{conn.assigns.snippet}")

      {:error, changeset} ->
        render(conn, :new, changeset: changeset)
    end
  end

  def delete(conn, %{"id" => id}) do
    comment = Comments.get_comment!(id)
    {:ok, _} = Comments.delete_comment(comment)

    conn
    |> put_flash(:info, "Comment deleted.")
    |> redirect(to: ~p"/snippets/#{conn.assigns.snippet}")
  end

  defp load_snippet(conn, _opts) do
    snippet = Snippets.get_snippet!(conn.params["snippet_id"])
    assign(conn, :snippet, snippet)
  end
end
```
</details>

## Exercise 3: Form with Dynamic Fields

Create a form that allows adding/removing tag inputs dynamically.

```elixir
# File: lib/snippetbox_web/controllers/snippet_html/form.html.heex

# Create a form with:
# - Standard snippet fields (title, content, language)
# - Dynamic tag fields that can be added/removed
# - JavaScript-free solution using LiveView or form submissions
```

### Solution
<details>
<summary>Click to reveal</summary>

```heex
<.simple_form for={@form} action={@action} phx-change="validate" phx-submit="save">
  <.input field={@form[:title]} label="Title" />
  <.input field={@form[:content]} type="textarea" label="Content" />
  <.input field={@form[:language]} type="select" label="Language"
    options={~w(elixir javascript python ruby)} />

  <div class="mt-4">
    <label class="block text-sm font-medium mb-2">Tags</label>

    <.inputs_for :let={tag_form} field={@form[:tags]}>
      <div class="flex gap-2 mb-2">
        <input type="hidden" name="snippet[tags_sort][]" value={tag_form.index} />
        <.input field={tag_form[:name]} placeholder="Tag name" class="flex-1" />
        <button
          type="button"
          name="snippet[tags_drop][]"
          value={tag_form.index}
          phx-click={JS.dispatch("change")}
          class="text-red-600"
        >
          Remove
        </button>
      </div>
    </.inputs_for>

    <input type="hidden" name="snippet[tags_drop][]" />

    <button
      type="button"
      name="snippet[tags_sort][]"
      value="new"
      phx-click={JS.dispatch("change")}
      class="text-blue-600"
    >
      + Add Tag
    </button>
  </div>

  <:actions>
    <.button>Save</.button>
  </:actions>
</.simple_form>
```
</details>

## Exercise 4: File Upload with Preview

Create a file upload component that shows a preview before submission.

```elixir
# File: lib/snippetbox_web/live/upload_live.ex

defmodule SnippetboxWeb.UploadLive do
  use SnippetboxWeb, :live_view

  # Implement:
  # 1. File upload configuration (accept .ex, .exs, .txt)
  # 2. Preview showing file content
  # 3. Syntax highlighting for code files
  # 4. Error handling for invalid files
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.UploadLive do
  use SnippetboxWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |> assign(:preview, nil)
     |> allow_upload(:file,
       accept: ~w(.ex .exs .txt),
       max_entries: 1,
       max_file_size: 100_000
     )}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="max-w-2xl mx-auto">
      <form phx-submit="save" phx-change="validate">
        <.live_file_input upload={@uploads.file} />

        <%= for entry <- @uploads.file.entries do %>
          <div class="mt-4 p-4 border rounded">
            <div class="flex justify-between items-center">
              <span><%= entry.client_name %></span>
              <button type="button" phx-click="cancel" phx-value-ref={entry.ref}>
                Cancel
              </button>
            </div>

            <progress value={entry.progress} max="100" class="w-full mt-2">
              <%= entry.progress %>%
            </progress>

            <%= for err <- upload_errors(@uploads.file, entry) do %>
              <p class="text-red-600"><%= error_message(err) %></p>
            <% end %>
          </div>
        <% end %>

        <div :if={@preview} class="mt-4">
          <h3 class="font-semibold mb-2">Preview:</h3>
          <pre class="bg-gray-100 p-4 rounded overflow-auto max-h-96">
            <code><%= @preview %></code>
          </pre>
        </div>

        <.button type="submit" class="mt-4">Upload</.button>
      </form>
    </div>
    """
  end

  @impl true
  def handle_event("validate", _params, socket) do
    preview =
      case socket.assigns.uploads.file.entries do
        [entry | _] ->
          consume_uploaded_entry(socket, entry, fn %{path: path} ->
            {:ok, File.read!(path)}
          end)
        _ ->
          nil
      end

    {:noreply, assign(socket, :preview, preview)}
  end

  def handle_event("cancel", %{"ref" => ref}, socket) do
    {:noreply, cancel_upload(socket, :file, ref)}
  end

  def handle_event("save", _params, socket) do
    # Process upload
    {:noreply, socket}
  end

  defp error_message(:too_large), do: "File is too large (max 100KB)"
  defp error_message(:not_accepted), do: "Invalid file type"
end
```
</details>

## Exercise 5: Rate Limiting Plug

Create a plug that rate limits requests per IP.

```elixir
# File: lib/snippetbox_web/plugs/rate_limit.ex

defmodule SnippetboxWeb.Plugs.RateLimit do
  import Plug.Conn

  # Implement rate limiting:
  # - 100 requests per minute per IP
  # - Return 429 Too Many Requests when exceeded
  # - Include Retry-After header
  # - Use ETS for storage
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.Plugs.RateLimit do
  import Plug.Conn
  import Phoenix.Controller

  @max_requests 100
  @window_ms 60_000
  @table :rate_limit

  def init(opts) do
    # Ensure ETS table exists
    if :ets.whereis(@table) == :undefined do
      :ets.new(@table, [:set, :public, :named_table])
    end
    opts
  end

  def call(conn, _opts) do
    ip = get_ip(conn)
    now = System.monotonic_time(:millisecond)

    case check_rate(ip, now) do
      {:allow, _count} ->
        conn

      {:deny, retry_after} ->
        conn
        |> put_resp_header("retry-after", Integer.to_string(div(retry_after, 1000)))
        |> put_status(:too_many_requests)
        |> json(%{error: "Rate limit exceeded", retry_after: div(retry_after, 1000)})
        |> halt()
    end
  end

  defp check_rate(ip, now) do
    case :ets.lookup(@table, ip) do
      [] ->
        :ets.insert(@table, {ip, 1, now})
        {:allow, 1}

      [{^ip, count, window_start}] when now - window_start < @window_ms ->
        if count < @max_requests do
          :ets.update_counter(@table, ip, {2, 1})
          {:allow, count + 1}
        else
          retry_after = @window_ms - (now - window_start)
          {:deny, retry_after}
        end

      [{^ip, _count, _window_start}] ->
        :ets.insert(@table, {ip, 1, now})
        {:allow, 1}
    end
  end

  defp get_ip(conn) do
    conn.remote_ip |> :inet.ntoa() |> to_string()
  end
end
```
</details>

## Exercise 6: API Versioning

Implement API versioning using path prefixes.

```elixir
# Implement:
# /api/v1/snippets - returns basic fields
# /api/v2/snippets - returns extended fields with stats

# Create versioned controllers and views
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
# Router
scope "/api" do
  pipe_through :api

  scope "/v1", as: :v1 do
    resources "/snippets", Api.V1.SnippetController, only: [:index, :show]
  end

  scope "/v2", as: :v2 do
    resources "/snippets", Api.V2.SnippetController, only: [:index, :show]
  end
end

# V1 Controller
defmodule SnippetboxWeb.Api.V1.SnippetController do
  use SnippetboxWeb, :controller

  def index(conn, _params) do
    snippets = Snippets.list_snippets()
    json(conn, %{data: Enum.map(snippets, &serialize_v1/1)})
  end

  defp serialize_v1(snippet) do
    %{
      id: snippet.id,
      title: snippet.title,
      language: snippet.language
    }
  end
end

# V2 Controller
defmodule SnippetboxWeb.Api.V2.SnippetController do
  use SnippetboxWeb, :controller

  def index(conn, _params) do
    snippets = Snippets.list_snippets_with_stats()
    json(conn, %{data: Enum.map(snippets, &serialize_v2/1)})
  end

  defp serialize_v2(%{snippet: snippet, comment_count: count, avg_rating: rating}) do
    %{
      id: snippet.id,
      title: snippet.title,
      language: snippet.language,
      content: snippet.content,
      stats: %{
        comment_count: count,
        average_rating: rating
      },
      created_at: snippet.inserted_at
    }
  end
end
```
</details>

## Challenge: Build a Search Interface

Create a search page with:

1. Real-time search as you type (debounced)
2. Filter by language, date range, author
3. Sort options (relevance, date, popularity)
4. Pagination
5. URL reflects search state (shareable)

This combines LiveView, queries, and URL handling concepts.
