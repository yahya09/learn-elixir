# Chapter 4.9: Database Best Practices

Building on everything we've learned, this chapter covers best practices for working with databases in Phoenix applications.

## Schema Best Practices

### Keep Schemas Focused

```elixir
# Good: Schema only handles data mapping
defmodule Snippetbox.Snippets.Snippet do
  use Ecto.Schema
  import Ecto.Changeset

  schema "snippets" do
    field :title, :string
    field :content, :string
    belongs_to :user, User
    timestamps()
  end

  # Only changeset functions in schema
  def changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content])
    |> validate_required([:title, :content])
  end
end

# Business logic goes in context
defmodule Snippetbox.Snippets do
  def publish_snippet(snippet) do
    # Business logic here
  end
end
```

### Use Multiple Changesets

```elixir
defmodule Snippetbox.Snippets.Snippet do
  # For creating new snippets
  def create_changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :language])
    |> validate_required([:title, :content])
    |> validate_length(:title, max: 100)
    |> validate_length(:content, max: 100_000)
  end

  # For updating (different rules)
  def update_changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :language])
    |> validate_length(:title, max: 100)
  end

  # For admin operations
  def admin_changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :is_featured, :is_public])
  end
end
```

## Query Best Practices

### Avoid N+1 Queries

```elixir
# Bad: N+1 queries
snippets = Repo.all(Snippet)
Enum.each(snippets, fn snippet ->
  snippet = Repo.preload(snippet, :user)  # Query for each snippet!
  IO.puts(snippet.user.name)
end)

# Good: Single query with preload
snippets = Repo.all(from s in Snippet, preload: [:user])
Enum.each(snippets, fn snippet ->
  IO.puts(snippet.user.name)
end)
```

### Select Only What You Need

```elixir
# Bad: Loads all columns
Repo.all(Snippet)

# Good: Select specific fields
Repo.all(from s in Snippet, select: %{id: s.id, title: s.title})

# Good: Use select when you only need some fields
def list_snippet_titles do
  Repo.all(from s in Snippet, select: s.title)
end
```

### Use Indexes

```elixir
# Migration: Add indexes for frequently queried columns
create index(:snippets, [:user_id])
create index(:snippets, [:inserted_at])
create index(:snippets, [:language])

# Composite index for common queries
create index(:snippets, [:user_id, :inserted_at])

# Unique indexes for constraints
create unique_index(:users, [:email])
create unique_index(:snippets, [:user_id, :slug])
```

### Paginate Large Results

```elixir
def list_snippets(opts \\ []) do
  page = opts[:page] || 1
  per_page = opts[:per_page] || 20

  query = from s in Snippet,
    order_by: [desc: s.inserted_at],
    limit: ^per_page,
    offset: ^((page - 1) * per_page)

  snippets = Repo.all(query)
  total = Repo.aggregate(Snippet, :count)

  %{
    snippets: snippets,
    page: page,
    per_page: per_page,
    total: total,
    total_pages: ceil(total / per_page)
  }
end
```

### Use Streaming for Large Datasets

```elixir
# Bad: Loads all into memory
Repo.all(Snippet)
|> Enum.each(&process/1)

# Good: Stream from database
Snippet
|> Repo.stream()
|> Stream.each(&process/1)
|> Stream.run()

# With transaction (required for streaming)
Repo.transaction(fn ->
  Snippet
  |> Repo.stream()
  |> Stream.each(&process/1)
  |> Stream.run()
end)
```

## Migration Best Practices

### Make Migrations Reversible

```elixir
# Good: Reversible
def change do
  alter table(:snippets) do
    add :language, :string, default: "text"
  end
end

# When not reversible, use up/down
def up do
  execute "CREATE INDEX CONCURRENTLY ..."
end

def down do
  execute "DROP INDEX ..."
end
```

### Use Safe Migrations in Production

```elixir
# Bad: Locks table in production
def change do
  alter table(:snippets) do
    add :views, :integer, default: 0  # DEFAULT locks table
  end
end

# Good: Add column, then backfill
def change do
  alter table(:snippets) do
    add :views, :integer  # No default, no lock
  end
end

# Then backfill in a separate migration or task
def up do
  execute "UPDATE snippets SET views = 0 WHERE views IS NULL"

  alter table(:snippets) do
    modify :views, :integer, null: false, default: 0
  end
end
```

### Never Modify Existing Migrations

Once deployed, create new migrations for changes:

```elixir
# Don't edit: 20240115_create_snippets.exs

# Instead create: 20240120_add_views_to_snippets.exs
def change do
  alter table(:snippets) do
    add :views, :integer, default: 0
  end
end
```

## Context Best Practices

### Keep Functions Pure When Possible

```elixir
defmodule Snippetbox.Snippets do
  # Pure function: builds query without execution
  def public_snippets_query do
    from s in Snippet,
      where: s.is_public == true,
      order_by: [desc: s.inserted_at]
  end

  # Impure: executes query
  def list_public_snippets do
    Repo.all(public_snippets_query())
  end

  # Pure: builds changeset without persisting
  def change_snippet(snippet, attrs \\ %{}) do
    Snippet.changeset(snippet, attrs)
  end

  # Impure: persists to database
  def create_snippet(attrs) do
    %Snippet{}
    |> Snippet.changeset(attrs)
    |> Repo.insert()
  end
end
```

### Use Consistent Return Types

```elixir
# Good: Consistent {:ok, _} | {:error, _} pattern
def get_snippet(id) do
  case Repo.get(Snippet, id) do
    nil -> {:error, :not_found}
    snippet -> {:ok, snippet}
  end
end

def create_snippet(attrs) do
  %Snippet{}
  |> Snippet.changeset(attrs)
  |> Repo.insert()
  # Returns {:ok, snippet} | {:error, changeset}
end

# Or use bang functions for "expected to succeed"
def get_snippet!(id) do
  Repo.get!(Snippet, id)
  # Raises if not found
end
```

### Encapsulate Complex Queries

```elixir
defmodule Snippetbox.Snippets do
  # Public API
  def search(term, opts \\ []) do
    Snippet
    |> search_by_term(term)
    |> filter_by_language(opts[:language])
    |> filter_by_date_range(opts[:from], opts[:to])
    |> sort_by(opts[:sort])
    |> paginate(opts[:page], opts[:per_page])
    |> Repo.all()
  end

  # Private query builders
  defp search_by_term(query, nil), do: query
  defp search_by_term(query, term) do
    where(query, [s], ilike(s.title, ^"%#{term}%") or ilike(s.content, ^"%#{term}%"))
  end

  defp filter_by_language(query, nil), do: query
  defp filter_by_language(query, language) do
    where(query, [s], s.language == ^language)
  end

  defp filter_by_date_range(query, nil, nil), do: query
  defp filter_by_date_range(query, from, to) do
    query
    |> maybe_filter_from(from)
    |> maybe_filter_to(to)
  end

  defp maybe_filter_from(query, nil), do: query
  defp maybe_filter_from(query, from), do: where(query, [s], s.inserted_at >= ^from)

  defp maybe_filter_to(query, nil), do: query
  defp maybe_filter_to(query, to), do: where(query, [s], s.inserted_at <= ^to)

  defp sort_by(query, "oldest"), do: order_by(query, asc: :inserted_at)
  defp sort_by(query, "popular"), do: order_by(query, desc: :views)
  defp sort_by(query, _), do: order_by(query, desc: :inserted_at)

  defp paginate(query, page, per_page) do
    page = page || 1
    per_page = min(per_page || 20, 100)  # Cap at 100

    query
    |> limit(^per_page)
    |> offset(^((page - 1) * per_page))
  end
end
```

## Performance Tips

### Use Database-Level Constraints

```elixir
# Migration
create table(:snippets) do
  add :title, :string, null: false
  add :views, :integer, default: 0
end

# Add check constraint
create constraint(:snippets, :views_must_be_positive, check: "views >= 0")

# Schema
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :views])
  |> check_constraint(:views, name: :views_must_be_positive)
end
```

### Batch Operations

```elixir
# Bad: Individual inserts
Enum.each(items, fn item ->
  Repo.insert!(%Record{data: item})
end)

# Good: Batch insert
now = DateTime.utc_now()
entries = Enum.map(items, fn item ->
  %{data: item, inserted_at: now, updated_at: now}
end)

Repo.insert_all(Record, entries, on_conflict: :nothing)
```

### Use Explain for Debugging

```elixir
query = from s in Snippet,
  where: s.is_public == true,
  order_by: [desc: s.inserted_at]

IO.puts(Repo.explain(:all, query))
# Shows PostgreSQL query plan
```

### Connection Pool Sizing

```elixir
# config/prod.exs
config :snippetbox, Snippetbox.Repo,
  pool_size: 10  # Adjust based on load

# Rule of thumb: (cores * 2) + spindle_count
# For most web apps: 10-20 connections per node
```

## Testing Best Practices

### Use Sandbox Mode

```elixir
# test/support/data_case.ex
setup tags do
  :ok = Ecto.Adapters.SQL.Sandbox.checkout(Snippetbox.Repo)

  unless tags[:async] do
    Ecto.Adapters.SQL.Sandbox.mode(Snippetbox.Repo, {:shared, self()})
  end

  :ok
end
```

### Create Test Factories

```elixir
# test/support/fixtures/snippets_fixtures.ex
defmodule Snippetbox.SnippetsFixtures do
  def snippet_fixture(attrs \\ %{}) do
    {:ok, snippet} =
      attrs
      |> Enum.into(%{
        title: "Test Snippet",
        content: "puts 'hello'",
        language: "ruby"
      })
      |> Snippetbox.Snippets.create_snippet()

    snippet
  end
end
```

### Test Queries Separately

```elixir
# Test query building (no database needed)
test "public_snippets_query filters by is_public" do
  query = Snippets.public_snippets_query()
  assert inspect(query) =~ "is_public"
end

# Test execution (needs database)
test "list_public_snippets returns only public snippets" do
  public = snippet_fixture(is_public: true)
  _private = snippet_fixture(is_public: false)

  result = Snippets.list_public_snippets()

  assert length(result) == 1
  assert hd(result).id == public.id
end
```

> **FP Concept: Separation of Concerns**
>
> The best practices above follow functional principles:
>
> - **Pure functions** where possible (query builders)
> - **Explicit side effects** isolated to Repo calls
> - **Composition** over inheritance (query pipelines)
> - **Immutability** through changesets
>
> This makes code easier to test, reason about, and maintain.

## Summary

In this chapter, we covered:

- Schema best practices (focused schemas, multiple changesets)
- Query optimization (avoiding N+1, indexes, pagination)
- Migration safety (reversible, production-safe)
- Context organization (pure functions, consistent returns)
- Performance tips (batching, connection pools)
- Testing strategies

This completes our Database with Ecto chapter. In the next chapter, we'll explore Dynamic Templates.

---

## Additional Information

### Monitoring Database Performance

```elixir
# Enable query logging
config :snippetbox, Snippetbox.Repo, log: :debug

# Use telemetry for metrics
:telemetry.attach(
  "repo-query-handler",
  [:snippetbox, :repo, :query],
  &MyApp.Telemetry.handle_query/4,
  nil
)
```

### Common Anti-Patterns to Avoid

1. **Fat schemas** - Put business logic in contexts, not schemas
2. **Implicit preloads** - Always explicitly preload associations
3. **Missing indexes** - Index foreign keys and frequently queried columns
4. **Large transactions** - Keep transactions short to avoid locks
5. **Hardcoded queries** - Use parameterized queries to prevent SQL injection
