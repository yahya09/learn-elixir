# Chapter 2.5: URL Query Strings and Parameters

Query strings allow passing data through URLs. In this chapter, we'll learn how to work with query parameters, path parameters, and how Phoenix handles different parameter types.

## Understanding URL Parameters

URLs can contain parameters in different places:

```
https://example.com/snippets/123?page=2&sort=date#section1
\_____/\_________/\_______/\_/\______________/\______/
  |         |        |     |        |            |
scheme    host      path  path   query        fragment
                         param   string
```

Phoenix gives you access to:
- **Path parameters**: `/snippets/:id` → `%{"id" => "123"}`
- **Query parameters**: `?page=2&sort=date` → `%{"page" => "2", "sort" => "date"}`
- **Body parameters**: Form data or JSON body

All parameters are merged into the `params` map passed to your controller action.

## Path Parameters

Define path parameters in your router with `:name`:

```elixir
# File: lib/snippetbox_web/router.ex

scope "/", SnippetboxWeb do
  pipe_through :browser

  get "/snippets/:id", SnippetController, :show
  get "/users/:user_id/snippets/:id", SnippetController, :user_snippet
end
```

Access them in your controller:

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def show(conn, %{"id" => id}) do
  text(conn, "Showing snippet #{id}")
end

def user_snippet(conn, %{"user_id" => user_id, "id" => id}) do
  text(conn, "User #{user_id}'s snippet #{id}")
end
```

### Pattern Matching Parameters

Use pattern matching to extract and validate:

```elixir
# Match specific parameter values
def show(conn, %{"id" => "new"}) do
  # Handle /snippets/new specially
  render(conn, :new)
end

def show(conn, %{"id" => id}) do
  # Handle /snippets/:id
  render(conn, :show, id: id)
end
```

> **Important**: Define more specific patterns before general ones. Elixir matches from top to bottom.

## Query String Parameters

Query parameters are automatically parsed from the URL:

```
GET /snippets?page=2&limit=10&sort=created_at&order=desc
```

Access them in your controller:

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def index(conn, params) do
  # params = %{
  #   "page" => "2",
  #   "limit" => "10",
  #   "sort" => "created_at",
  #   "order" => "desc"
  # }

  page = Map.get(params, "page", "1")
  limit = Map.get(params, "limit", "20")

  text(conn, "Page #{page}, showing #{limit} items")
end
```

### Pattern Matching Query Parameters

```elixir
# When pagination params are provided
def index(conn, %{"page" => page, "limit" => limit}) do
  # Both page and limit are present
  list_snippets(page: page, limit: limit)
end

# Default case - no pagination params
def index(conn, _params) do
  # Use defaults
  list_snippets(page: "1", limit: "20")
end
```

### Extracting with Defaults

Use `Map.get/3` for optional parameters with defaults:

```elixir
def index(conn, params) do
  page = params |> Map.get("page", "1") |> String.to_integer()
  limit = params |> Map.get("limit", "20") |> String.to_integer()
  sort = Map.get(params, "sort", "inserted_at")
  order = Map.get(params, "order", "desc")

  snippets = list_snippets(
    page: page,
    limit: limit,
    sort: sort,
    order: order
  )

  render(conn, :index, snippets: snippets)
end
```

## Type Conversion

All URL parameters arrive as strings. Convert them as needed:

```elixir
def show(conn, %{"id" => id}) do
  # Convert string to integer
  case Integer.parse(id) do
    {int_id, ""} ->
      snippet = Snippets.get_snippet!(int_id)
      render(conn, :show, snippet: snippet)

    _ ->
      conn
      |> put_status(:bad_request)
      |> text("Invalid ID format")
  end
end
```

### Safe Type Conversion

Create helper functions for common conversions:

```elixir
# File: lib/snippetbox_web/controllers/helpers.ex

defmodule SnippetboxWeb.Helpers do
  def to_integer(value, default \\ 0)

  def to_integer(value, default) when is_binary(value) do
    case Integer.parse(value) do
      {int, ""} -> int
      _ -> default
    end
  end

  def to_integer(value, _default) when is_integer(value), do: value
  def to_integer(_, default), do: default

  def to_boolean("true"), do: true
  def to_boolean("1"), do: true
  def to_boolean(_), do: false
end
```

Use in controllers:

```elixir
import SnippetboxWeb.Helpers

def index(conn, params) do
  page = to_integer(params["page"], 1)
  limit = to_integer(params["limit"], 20)
  show_expired = to_boolean(params["show_expired"])

  # ...
end
```

## Array Parameters

Phoenix handles array-style parameters:

```
GET /snippets?tags[]=elixir&tags[]=phoenix&tags[]=web
```

```elixir
def index(conn, %{"tags" => tags}) when is_list(tags) do
  # tags = ["elixir", "phoenix", "web"]
  snippets = Snippets.filter_by_tags(tags)
  render(conn, :index, snippets: snippets)
end
```

## Nested Parameters

Phoenix parses nested parameters from bracket notation:

```
GET /snippets?filter[status]=active&filter[category]=tutorial
```

```elixir
def index(conn, %{"filter" => filter}) do
  # filter = %{"status" => "active", "category" => "tutorial"}
  status = filter["status"]
  category = filter["category"]

  # ...
end
```

## Building URLs with Query Parameters

Use verified routes with query parameters:

```elixir
# In a template or controller
~p"/snippets?page=2&limit=10"

# With dynamic values
~p"/snippets?#{[page: page, limit: limit]}"

# Complex parameters
~p"/snippets?#{[filter: %{status: "active"}, sort: "date"]}"
```

In templates:

```heex
<.link href={~p"/snippets?#{[page: @page + 1]}"}>
  Next Page
</.link>
```

## Validating Parameters

Create validation functions for complex parameter requirements:

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def index(conn, params) do
  with {:ok, validated} <- validate_index_params(params) do
    snippets = Snippets.list_snippets(validated)
    render(conn, :index, snippets: snippets, params: validated)
  else
    {:error, message} ->
      conn
      |> put_status(:bad_request)
      |> text("Invalid parameters: #{message}")
  end
end

defp validate_index_params(params) do
  page = to_integer(params["page"], 1)
  limit = to_integer(params["limit"], 20)
  sort = params["sort"] || "inserted_at"
  order = params["order"] || "desc"

  cond do
    page < 1 ->
      {:error, "page must be positive"}

    limit < 1 or limit > 100 ->
      {:error, "limit must be between 1 and 100"}

    sort not in ~w(inserted_at title expires_at) ->
      {:error, "invalid sort field"}

    order not in ~w(asc desc) ->
      {:error, "order must be asc or desc"}

    true ->
      {:ok, %{page: page, limit: limit, sort: sort, order: order}}
  end
end
```

## Practical Example: Search with Filters

Build a search endpoint with multiple filter options:

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def search(conn, params) do
  search_params = %{
    query: params["q"] || "",
    page: to_integer(params["page"], 1),
    per_page: to_integer(params["per_page"], 20),
    language: params["language"],
    author: params["author"],
    from_date: parse_date(params["from"]),
    to_date: parse_date(params["to"]),
    sort: params["sort"] || "relevance"
  }

  results = Snippets.search(search_params)

  render(conn, :search,
    results: results,
    params: search_params
  )
end

defp parse_date(nil), do: nil
defp parse_date(date_string) do
  case Date.from_iso8601(date_string) do
    {:ok, date} -> date
    _ -> nil
  end
end
```

URL example:
```
/snippets/search?q=elixir&language=elixir&from=2024-01-01&sort=date
```

> **FP Concept: Pattern Matching for Control Flow**
>
> Pattern matching replaces conditional logic:
>
> ```elixir
> # Instead of:
> def index(conn, params) do
>   if params["page"] != nil and params["limit"] != nil do
>     # paginated
>   else
>     # not paginated
>   end
> end
>
> # Use pattern matching:
> def index(conn, %{"page" => page, "limit" => limit}) do
>   # paginated - these params exist
> end
>
> def index(conn, _params) do
>   # not paginated - catch-all
> end
> ```
>
> Benefits:
> - Clearer intent
> - Compiler checks for missing cases
> - Separates concerns into different function clauses
> - Each clause is smaller and focused
>
> **Further Reading**:
> - [Elixir Pattern Matching](https://elixir-lang.org/getting-started/pattern-matching.html)
> - [Function Clauses](https://elixir-lang.org/getting-started/modules-and-functions.html#named-functions)

## Accessing Raw Query String

If you need the unparsed query string:

```elixir
def debug(conn, _params) do
  query_string = conn.query_string
  # "page=2&limit=10&sort=date"

  text(conn, "Raw query: #{query_string}")
end
```

## Summary

In this chapter, we learned:

- How to define and access path parameters (`:id`)
- How to work with query string parameters (`?key=value`)
- How to convert string parameters to other types
- How to handle array and nested parameters
- How to validate parameters
- How to build URLs with query parameters

In the next chapter, we'll explore how Phoenix projects are structured and organized.

---

## Additional Information

### Parameter Precedence

When the same key exists in multiple places, Phoenix merges them with this precedence (highest to lowest):

1. Body parameters (POST/PUT data)
2. Query string parameters
3. Path parameters

### Comparing to Other Frameworks

**Express (Node.js)**:
```javascript
app.get('/snippets/:id', (req, res) => {
  const { id } = req.params;        // Path param
  const { page } = req.query;       // Query param
});
```

**Django (Python)**:
```python
def show(request, id):              # Path param from URL conf
    page = request.GET.get('page')  # Query param
```

**Laravel (PHP)**:
```php
public function show(Request $request, $id) {
    $page = $request->query('page'); // Query param
}
```

**Phoenix (Elixir)**:
```elixir
def show(conn, %{"id" => id, "page" => page}) do
  # Both path and query params in same map
end
```

Phoenix's unified params map is simpler - you don't need to remember which map to check.
