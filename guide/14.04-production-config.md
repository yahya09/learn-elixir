# Chapter 14.4: Production Configuration

Production environments require careful configuration for security, performance, and reliability. In this chapter, we'll explore production-ready configuration.

## Runtime vs Compile-Time Config

### Understanding the Difference

```elixir
# config/config.exs - Compile-time
# Baked into release, cannot change without recompiling
config :snippetbox, SnippetboxWeb.Endpoint,
  render_errors: [formats: [html: SnippetboxWeb.ErrorHTML]]

# config/runtime.exs - Runtime
# Read at application startup, can use environment variables
config :snippetbox, SnippetboxWeb.Endpoint,
  url: [host: System.get_env("PHX_HOST")]
```

### When to Use Each

| Compile-Time (config.exs) | Runtime (runtime.exs) |
|---------------------------|----------------------|
| Static configuration | Secrets |
| Module configuration | Environment-specific values |
| Logger formats | Database URLs |
| Error templates | API keys |

## Complete Production Config

### config/runtime.exs

```elixir
# File: config/runtime.exs

import Config

if config_env() == :prod do
  # Database
  database_url =
    System.get_env("DATABASE_URL") ||
      raise """
      DATABASE_URL environment variable is missing.
      Example: ecto://USER:PASS@HOST/DATABASE
      """

  maybe_ipv6 = if System.get_env("ECTO_IPV6") in ~w(true 1), do: [:inet6], else: []

  config :snippetbox, Snippetbox.Repo,
    url: database_url,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),
    socket_options: maybe_ipv6,
    ssl: System.get_env("DATABASE_SSL") == "true",
    ssl_opts: [
      verify: :verify_peer,
      cacerts: :public_key.cacerts_get(),
      customize_hostname_check: [
        match_fun: :public_key.pkix_verify_hostname_match_fun(:https)
      ]
    ]

  # Endpoint
  secret_key_base =
    System.get_env("SECRET_KEY_BASE") ||
      raise """
      SECRET_KEY_BASE environment variable is missing.
      Generate with: mix phx.gen.secret
      """

  host = System.get_env("PHX_HOST") || "localhost"
  port = String.to_integer(System.get_env("PORT") || "4000")

  config :snippetbox, SnippetboxWeb.Endpoint,
    url: [host: host, port: 443, scheme: "https"],
    http: [
      ip: {0, 0, 0, 0, 0, 0, 0, 0},
      port: port
    ],
    secret_key_base: secret_key_base,
    server: true

  # Email (Swoosh)
  config :snippetbox, Snippetbox.Mailer,
    adapter: Swoosh.Adapters.Postmark,
    api_key: System.get_env("POSTMARK_API_KEY")

  # Error tracking (Sentry)
  config :sentry,
    dsn: System.get_env("SENTRY_DSN"),
    environment_name: :prod,
    included_environments: [:prod]

  # Feature flags
  config :snippetbox,
    enable_registrations: System.get_env("ENABLE_REGISTRATIONS") == "true",
    maintenance_mode: System.get_env("MAINTENANCE_MODE") == "true"
end
```

## Environment Variables

### Required Variables

```bash
# Essential
DATABASE_URL=ecto://user:password@host/database
SECRET_KEY_BASE=super-long-secret-key-at-least-64-chars
PHX_HOST=snippetbox.com
PORT=4000

# Email
POSTMARK_API_KEY=your-api-key

# Error tracking
SENTRY_DSN=https://xxx@sentry.io/xxx

# Feature flags
ENABLE_REGISTRATIONS=true
MAINTENANCE_MODE=false
```

### Generating Secrets

```bash
# Generate secret key base
mix phx.gen.secret

# Output: PbXjH3bkQW...64+ characters
```

## SSL/TLS Configuration

### Force HTTPS

```elixir
# config/prod.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  force_ssl: [rewrite_on: [:x_forwarded_proto]]
```

### SSL with Custom Certificates

```elixir
# config/runtime.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  https: [
    port: 443,
    cipher_suite: :strong,
    keyfile: System.get_env("SSL_KEY_PATH"),
    certfile: System.get_env("SSL_CERT_PATH")
  ]
```

## Database Configuration

### Connection Pooling

```elixir
config :snippetbox, Snippetbox.Repo,
  url: database_url,
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),
  queue_target: 5000,
  queue_interval: 1000
```

### Database SSL

```elixir
config :snippetbox, Snippetbox.Repo,
  url: database_url,
  ssl: true,
  ssl_opts: [
    verify: :verify_peer,
    cacerts: :public_key.cacerts_get(),
    server_name_indication: String.to_charlist(db_host),
    customize_hostname_check: [
      match_fun: :public_key.pkix_verify_hostname_match_fun(:https)
    ]
  ]
```

## Logging

### Production Logger

```elixir
# config/prod.exs

config :logger, :console,
  format: "$time $metadata[$level] $message\n",
  metadata: [:request_id, :user_id]

config :logger,
  level: :info,
  compile_time_purge_matching: [
    [level_lower_than: :info]
  ]
```

### JSON Logging

```elixir
# For log aggregators
config :logger, :console,
  format: {LoggerJSON.Formatters.Basic, :format},
  metadata: :all

# Add to deps: {:logger_json, "~> 5.0"}
```

### Request Logging

```elixir
# lib/snippetbox_web/endpoint.ex

plug Plug.Logger, log: :info

# Or custom logging plug
plug SnippetboxWeb.Plugs.RequestLogger
```

## Error Handling

### Error Tracking with Sentry

```elixir
# File: mix.exs
{:sentry, "~> 10.0"}

# config/runtime.exs
config :sentry,
  dsn: System.get_env("SENTRY_DSN"),
  environment_name: config_env(),
  enable_source_code_context: true,
  root_source_code_paths: [File.cwd!()]

# lib/snippetbox_web/endpoint.ex
use Sentry.PlugCapture
```

### Error Pages

```elixir
# lib/snippetbox_web/controllers/error_html.ex

defmodule SnippetboxWeb.ErrorHTML do
  use SnippetboxWeb, :html

  embed_templates "error_html/*"

  def render(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end
```

## Session Configuration

```elixir
# config/prod.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  session: [
    store: :cookie,
    key: "_snippetbox_key",
    signing_salt: "random-salt",
    encryption_salt: "another-salt",
    same_site: "Strict",
    secure: true,
    max_age: 60 * 60 * 24 * 60  # 60 days
  ]
```

## Caching

### Static Asset Caching

```elixir
# lib/snippetbox_web/endpoint.ex

plug Plug.Static,
  at: "/",
  from: :snippetbox,
  gzip: true,
  cache_control_for_etags: "public, max-age=31536000",
  headers: [
    {"cache-control", "public, max-age=31536000, immutable"}
  ]
```

### Response Caching

```elixir
# In controller
def index(conn, _params) do
  conn
  |> put_resp_header("cache-control", "public, max-age=3600")
  |> render(:index)
end
```

## Rate Limiting

```elixir
# File: lib/snippetbox_web/plugs/rate_limiter.ex

defmodule SnippetboxWeb.Plugs.RateLimiter do
  import Plug.Conn

  @max_requests 100
  @window_ms 60_000

  def init(opts), do: opts

  def call(conn, _opts) do
    key = rate_limit_key(conn)

    case ExRated.check_rate(key, @window_ms, @max_requests) do
      {:ok, _count} ->
        conn
      {:error, _limit} ->
        conn
        |> put_status(:too_many_requests)
        |> Phoenix.Controller.json(%{error: "Rate limit exceeded"})
        |> halt()
    end
  end

  defp rate_limit_key(conn) do
    ip = conn.remote_ip |> :inet.ntoa() |> to_string()
    "rate_limit:#{ip}"
  end
end
```

## Health Checks

```elixir
# File: lib/snippetbox_web/controllers/health_controller.ex

defmodule SnippetboxWeb.HealthController do
  use SnippetboxWeb, :controller

  def check(conn, _params) do
    checks = %{
      database: check_database(),
      memory: check_memory(),
      disk: check_disk()
    }

    status = if Enum.all?(checks, fn {_, v} -> v == :ok end), do: :ok, else: :degraded

    conn
    |> put_status(if status == :ok, do: 200, else: 503)
    |> json(%{
      status: status,
      checks: checks,
      timestamp: DateTime.utc_now()
    })
  end

  defp check_database do
    case Ecto.Adapters.SQL.query(Snippetbox.Repo, "SELECT 1", []) do
      {:ok, _} -> :ok
      _ -> :error
    end
  end

  defp check_memory do
    memory = :erlang.memory(:total)
    if memory < 1_000_000_000, do: :ok, else: :warning
  end

  defp check_disk do
    # Simplified check
    :ok
  end
end
```

## Feature Flags

```elixir
# config/runtime.exs
config :snippetbox,
  features: %{
    new_editor: System.get_env("FEATURE_NEW_EDITOR") == "true",
    ai_suggestions: System.get_env("FEATURE_AI_SUGGESTIONS") == "true"
  }

# Usage
def show(conn, _params) do
  if Application.get_env(:snippetbox, :features)[:new_editor] do
    render(conn, :show_v2)
  else
    render(conn, :show)
  end
end
```

## Graceful Shutdown

```elixir
# File: lib/snippetbox/application.ex

def start(_type, _args) do
  children = [
    # ...
  ]

  opts = [strategy: :one_for_one, name: Snippetbox.Supervisor]

  # Handle shutdown signals
  :init.notify_when_started(self())

  Supervisor.start_link(children, opts)
end
```

```elixir
# rel/env.sh.eex
export RELEASE_DISTRIBUTION=name
export RELEASE_NODE=<%= @release.name %>@127.0.0.1

# Graceful shutdown timeout (30 seconds)
export RELEASE_SHUTDOWN_TIMEOUT=30000
```

> **FP Concept: Configuration as Data**
>
> Elixir treats configuration as data, not code:
>
> ```elixir
> # Configuration is just keyword lists
> config :my_app, key: "value"
>
> # Runtime evaluation makes it dynamic
> config :my_app, key: System.get_env("VALUE")
>
> # Access is explicit
> Application.get_env(:my_app, :key)
> ```
>
> This separation makes configuration predictable and testable.

## Summary

In this chapter, we learned:

- Runtime vs compile-time configuration
- Essential environment variables
- SSL/TLS setup
- Database configuration
- Production logging
- Error tracking
- Session configuration
- Caching strategies
- Rate limiting
- Health checks
- Feature flags

In the next chapter, we'll explore monitoring and observability.
