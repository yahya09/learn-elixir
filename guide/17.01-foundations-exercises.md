# Chapter 17.1: Foundations Exercises

These exercises reinforce concepts from Chapters 1-3 covering Elixir basics, Phoenix setup, configuration, and error handling.

## Exercise 1: Pattern Matching

Create a module that uses pattern matching to parse log entries.

```elixir
# File: lib/snippetbox/log_parser.ex

defmodule Snippetbox.LogParser do
  @doc """
  Parse a log line into structured data.

  ## Examples

      iex> LogParser.parse("[INFO] 2024-01-15 User logged in")
      {:ok, %{level: :info, date: "2024-01-15", message: "User logged in"}}

      iex> LogParser.parse("[ERROR] 2024-01-15 Connection failed")
      {:ok, %{level: :error, date: "2024-01-15", message: "Connection failed"}}

      iex> LogParser.parse("Invalid line")
      {:error, :invalid_format}
  """
  def parse(line) do
    # Your implementation here
  end
end
```

### Hints
- Use `String.split/2` to break the line into parts
- Pattern match on the list elements
- Use guards or pattern matching for the log level

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def parse("[" <> rest) do
  case String.split(rest, "] ", parts: 2) do
    [level, rest] ->
      case String.split(rest, " ", parts: 2) do
        [date, message] ->
          {:ok, %{
            level: parse_level(level),
            date: date,
            message: message
          }}
        _ ->
          {:error, :invalid_format}
      end
    _ ->
      {:error, :invalid_format}
  end
end

def parse(_), do: {:error, :invalid_format}

defp parse_level("INFO"), do: :info
defp parse_level("ERROR"), do: :error
defp parse_level("WARN"), do: :warn
defp parse_level("DEBUG"), do: :debug
defp parse_level(_), do: :unknown
```
</details>

## Exercise 2: Pipe Operator

Refactor this code to use the pipe operator:

```elixir
# Before: nested function calls
def process_text(text) do
  String.replace(
    String.downcase(
      String.trim(text)
    ),
    " ",
    "-"
  )
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def process_text(text) do
  text
  |> String.trim()
  |> String.downcase()
  |> String.replace(" ", "-")
end
```
</details>

## Exercise 3: Custom Plug

Create a plug that adds a request timing header.

```elixir
# File: lib/snippetbox_web/plugs/request_timer.ex

defmodule SnippetboxWeb.Plugs.RequestTimer do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    # 1. Record start time
    # 2. Register callback to run before response is sent
    # 3. Calculate duration and add X-Request-Time header
  end
end
```

### Hints
- Use `System.monotonic_time/1` for timing
- Use `register_before_send/2` to add the header

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def call(conn, _opts) do
  start_time = System.monotonic_time(:millisecond)

  register_before_send(conn, fn conn ->
    duration = System.monotonic_time(:millisecond) - start_time
    put_resp_header(conn, "x-request-time", "#{duration}ms")
  end)
end
```
</details>

## Exercise 4: Configuration Module

Create a configuration module that reads settings with defaults and validation.

```elixir
# File: lib/snippetbox/config.ex

defmodule Snippetbox.Config do
  @doc """
  Get a configuration value with type validation.

  ## Examples

      iex> Config.get(:pool_size, :integer, default: 10)
      {:ok, 10}

      iex> Config.get(:debug, :boolean, default: false)
      {:ok, false}
  """
  def get(key, type, opts \\ []) do
    # Your implementation here
  end
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def get(key, type, opts \\ []) do
  env_key = key |> Atom.to_string() |> String.upcase()
  default = Keyword.get(opts, :default)

  case System.get_env(env_key) do
    nil -> {:ok, default}
    value -> cast(value, type)
  end
end

defp cast(value, :integer) do
  case Integer.parse(value) do
    {int, ""} -> {:ok, int}
    _ -> {:error, "invalid integer"}
  end
end

defp cast(value, :boolean) do
  case String.downcase(value) do
    v when v in ["true", "1", "yes"] -> {:ok, true}
    v when v in ["false", "0", "no"] -> {:ok, false}
    _ -> {:error, "invalid boolean"}
  end
end

defp cast(value, :string), do: {:ok, value}
```
</details>

## Exercise 5: Error Handling

Create a function that handles multiple error types gracefully.

```elixir
# File: lib/snippetbox/file_processor.ex

defmodule Snippetbox.FileProcessor do
  @doc """
  Process a file and return its contents transformed.

  Should handle:
  - File not found
  - Permission denied
  - Invalid encoding
  - Empty file
  """
  def process(path) do
    # Your implementation here
  end
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
def process(path) do
  with {:ok, content} <- read_file(path),
       {:ok, content} <- validate_not_empty(content),
       {:ok, content} <- validate_encoding(content) do
    {:ok, transform(content)}
  end
end

defp read_file(path) do
  case File.read(path) do
    {:ok, content} -> {:ok, content}
    {:error, :enoent} -> {:error, "File not found: #{path}"}
    {:error, :eacces} -> {:error, "Permission denied: #{path}"}
    {:error, reason} -> {:error, "Failed to read file: #{reason}"}
  end
end

defp validate_not_empty(""), do: {:error, "File is empty"}
defp validate_not_empty(content), do: {:ok, content}

defp validate_encoding(content) do
  if String.valid?(content) do
    {:ok, content}
  else
    {:error, "Invalid UTF-8 encoding"}
  end
end

defp transform(content) do
  content
  |> String.trim()
  |> String.split("\n")
  |> Enum.map(&String.trim/1)
  |> Enum.reject(&(&1 == ""))
end
```
</details>

## Exercise 6: Custom Error Page

Create a custom error view that renders different templates based on error type.

```elixir
# File: lib/snippetbox_web/controllers/error_html.ex

defmodule SnippetboxWeb.ErrorHTML do
  use SnippetboxWeb, :html

  # Implement render/2 that:
  # - Shows "Page not found" for 404
  # - Shows "Access denied" for 403
  # - Shows "Something went wrong" for 500
  # - Falls back to status message for others
end
```

### Solution
<details>
<summary>Click to reveal</summary>

```elixir
defmodule SnippetboxWeb.ErrorHTML do
  use SnippetboxWeb, :html

  embed_templates "error_html/*"

  def render("404.html", assigns) do
    ~H"""
    <div class="error-page">
      <h1>Page Not Found</h1>
      <p>The page you're looking for doesn't exist.</p>
      <.link navigate={~p"/"}>Go Home</.link>
    </div>
    """
  end

  def render("403.html", assigns) do
    ~H"""
    <div class="error-page">
      <h1>Access Denied</h1>
      <p>You don't have permission to access this resource.</p>
    </div>
    """
  end

  def render("500.html", assigns) do
    ~H"""
    <div class="error-page">
      <h1>Something Went Wrong</h1>
      <p>We're working on fixing this issue.</p>
    </div>
    """
  end

  def render(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end
```
</details>

## Challenge: Build a CLI Tool

Create a simple command-line tool using Elixir that:

1. Accepts command-line arguments
2. Validates input
3. Processes data
4. Handles errors gracefully

```elixir
# File: lib/mix/tasks/snippetbox.stats.ex

defmodule Mix.Tasks.Snippetbox.Stats do
  use Mix.Task

  @shortdoc "Display snippet statistics"

  @moduledoc """
  Displays statistics about snippets in the database.

  ## Usage

      mix snippetbox.stats
      mix snippetbox.stats --language elixir
      mix snippetbox.stats --user user@example.com
  """

  def run(args) do
    # Parse args, start app, query database, display results
  end
end
```

This exercise combines multiple concepts: argument parsing, database queries, and formatted output.
