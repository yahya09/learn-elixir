# Chapter 4.7: Associations

Associations define relationships between schemas. In this chapter, we'll learn how to set up and work with belongs_to, has_many, has_one, and many_to_many associations.

## Association Types

| Association | Description | Example |
|-------------|-------------|---------|
| `belongs_to` | Many-to-one | Snippet belongs to User |
| `has_many` | One-to-many | User has many Snippets |
| `has_one` | One-to-one | User has one Profile |
| `many_to_many` | Many-to-many | Snippet has many Tags |

## belongs_to

A snippet belongs to a user:

### Migration

```elixir
# File: priv/repo/migrations/20240115100000_create_snippets.exs

def change do
  create table(:snippets) do
    add :title, :string, null: false
    add :content, :text, null: false
    add :user_id, references(:users, on_delete: :delete_all), null: false

    timestamps()
  end

  create index(:snippets, [:user_id])
end
```

### Schema

```elixir
# File: lib/snippetbox/snippets/snippet.ex

defmodule Snippetbox.Snippets.Snippet do
  use Ecto.Schema
  import Ecto.Changeset

  schema "snippets" do
    field :title, :string
    field :content, :string

    belongs_to :user, Snippetbox.Accounts.User

    timestamps()
  end

  def changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :user_id])
    |> validate_required([:title, :content, :user_id])
    |> foreign_key_constraint(:user_id)
  end
end
```

### Usage

```elixir
# Create with user_id
{:ok, snippet} = Snippets.create_snippet(%{
  title: "Hello",
  content: "World",
  user_id: user.id
})

# Access user (requires preload)
snippet = Repo.get!(Snippet, 1) |> Repo.preload(:user)
snippet.user.name  # => "Alice"
```

## has_many

A user has many snippets:

### Schema

```elixir
# File: lib/snippetbox/accounts/user.ex

defmodule Snippetbox.Accounts.User do
  use Ecto.Schema

  schema "users" do
    field :email, :string
    field :name, :string

    has_many :snippets, Snippetbox.Snippets.Snippet

    timestamps()
  end
end
```

### Usage

```elixir
# Get user with snippets
user = Repo.get!(User, 1) |> Repo.preload(:snippets)
user.snippets  # => [%Snippet{...}, %Snippet{...}]

# Count snippets
length(user.snippets)

# Query through association
from s in Snippet,
  where: s.user_id == ^user.id,
  order_by: [desc: s.inserted_at]
```

## has_one

A user has one profile:

### Migration

```elixir
def change do
  create table(:profiles) do
    add :bio, :text
    add :website, :string
    add :user_id, references(:users, on_delete: :delete_all), null: false

    timestamps()
  end

  create unique_index(:profiles, [:user_id])
end
```

### Schemas

```elixir
# User
schema "users" do
  field :email, :string
  has_one :profile, Snippetbox.Accounts.Profile
  timestamps()
end

# Profile
schema "profiles" do
  field :bio, :string
  field :website, :string
  belongs_to :user, Snippetbox.Accounts.User
  timestamps()
end
```

### Usage

```elixir
user = Repo.get!(User, 1) |> Repo.preload(:profile)
user.profile.bio  # => "Elixir developer..."
```

## many_to_many

Snippets can have many tags, and tags can belong to many snippets:

### Migration (Join Table)

```elixir
# Create tags table
def change do
  create table(:tags) do
    add :name, :string, null: false
    timestamps()
  end

  create unique_index(:tags, [:name])
end

# Create join table
def change do
  create table(:snippet_tags, primary_key: false) do
    add :snippet_id, references(:snippets, on_delete: :delete_all), null: false
    add :tag_id, references(:tags, on_delete: :delete_all), null: false

    timestamps()
  end

  create index(:snippet_tags, [:snippet_id])
  create index(:snippet_tags, [:tag_id])
  create unique_index(:snippet_tags, [:snippet_id, :tag_id])
end
```

### Schemas

```elixir
# Snippet
schema "snippets" do
  field :title, :string
  many_to_many :tags, Snippetbox.Tags.Tag, join_through: "snippet_tags"
  timestamps()
end

# Tag
schema "tags" do
  field :name, :string
  many_to_many :snippets, Snippetbox.Snippets.Snippet, join_through: "snippet_tags"
  timestamps()
end
```

### Usage

```elixir
# Preload tags
snippet = Repo.get!(Snippet, 1) |> Repo.preload(:tags)
snippet.tags  # => [%Tag{name: "elixir"}, %Tag{name: "phoenix"}]

# Associate tags with put_assoc
def add_tags(snippet, tag_names) do
  tags = Repo.all(from t in Tag, where: t.name in ^tag_names)

  snippet
  |> Repo.preload(:tags)
  |> Ecto.Changeset.change()
  |> Ecto.Changeset.put_assoc(:tags, tags)
  |> Repo.update()
end
```

## Preloading Associations

### Basic Preload

```elixir
# After fetching
snippet = Repo.get!(Snippet, 1)
snippet = Repo.preload(snippet, :user)

# In query
snippets = Repo.all(from s in Snippet, preload: [:user])

# Multiple associations
snippet = Repo.preload(snippet, [:user, :tags])
```

### Nested Preloading

```elixir
# Preload nested associations
snippets = Repo.all(
  from s in Snippet,
  preload: [comments: :author]
)

# Deep nesting
snippets = Repo.all(
  from s in Snippet,
  preload: [:user, comments: [author: :profile]]
)
```

### Preload with Query

```elixir
# Custom query for preloaded data
recent_comments = from c in Comment,
  order_by: [desc: c.inserted_at],
  limit: 5

snippet = Repo.preload(snippet, comments: recent_comments)
```

### Join Preload

More efficient for single records:

```elixir
# Loads in single query with join
snippet = Repo.one(
  from s in Snippet,
  where: s.id == ^id,
  join: u in assoc(s, :user),
  preload: [user: u]
)
```

## Creating Associated Records

### With Foreign Key

```elixir
def create_snippet(user, attrs) do
  %Snippet{}
  |> Snippet.changeset(attrs)
  |> Ecto.Changeset.put_change(:user_id, user.id)
  |> Repo.insert()
end
```

### With build_assoc

```elixir
def create_snippet(user, attrs) do
  user
  |> Ecto.build_assoc(:snippets)
  |> Snippet.changeset(attrs)
  |> Repo.insert()
end
```

### With put_assoc

```elixir
def create_user_with_profile(user_attrs, profile_attrs) do
  %User{}
  |> User.changeset(user_attrs)
  |> Ecto.Changeset.put_assoc(:profile, %Profile{} |> Profile.changeset(profile_attrs))
  |> Repo.insert()
end
```

### With cast_assoc

For nested forms:

```elixir
# Schema
schema "users" do
  field :email, :string
  has_one :profile, Profile
end

def changeset(user, attrs) do
  user
  |> cast(attrs, [:email])
  |> cast_assoc(:profile, with: &Profile.changeset/2)
end

# Usage
User.changeset(%User{}, %{
  email: "alice@example.com",
  profile: %{bio: "Developer", website: "https://alice.dev"}
})
```

## Deleting with Associations

### on_delete Options

```elixir
# In migration
add :user_id, references(:users, on_delete: :nothing)      # Default
add :user_id, references(:users, on_delete: :delete_all)   # Cascade delete
add :user_id, references(:users, on_delete: :nilify_all)   # Set NULL
add :user_id, references(:users, on_delete: :restrict)     # Prevent deletion
```

### Manual Deletion

```elixir
def delete_user(user) do
  # Delete associated records first
  Repo.delete_all(from s in Snippet, where: s.user_id == ^user.id)

  # Then delete user
  Repo.delete(user)
end
```

### With Transaction

```elixir
def delete_user_with_data(user) do
  Ecto.Multi.new()
  |> Ecto.Multi.delete_all(:snippets, from(s in Snippet, where: s.user_id == ^user.id))
  |> Ecto.Multi.delete_all(:comments, from(c in Comment, where: c.user_id == ^user.id))
  |> Ecto.Multi.delete(:user, user)
  |> Repo.transaction()
end
```

## Self-Referential Associations

Comments that can reply to other comments:

```elixir
schema "comments" do
  field :content, :string

  belongs_to :parent, __MODULE__, foreign_key: :parent_id
  has_many :replies, __MODULE__, foreign_key: :parent_id

  belongs_to :snippet, Snippet
  belongs_to :user, User

  timestamps()
end
```

## Polymorphic-like Associations

Ecto doesn't support polymorphic associations directly. Use separate tables or a type field:

```elixir
# Separate tables approach
schema "snippet_comments" do
  belongs_to :snippet, Snippet
  belongs_to :user, User
  field :content, :string
end

schema "post_comments" do
  belongs_to :post, Post
  belongs_to :user, User
  field :content, :string
end

# Or type field approach
schema "comments" do
  field :content, :string
  field :commentable_type, :string  # "snippet" or "post"
  field :commentable_id, :integer
end
```

> **FP Concept: Explicit Data Loading**
>
> Unlike ORMs with lazy loading, Ecto requires explicit preloading:
>
> ```elixir
> snippet = Repo.get!(Snippet, 1)
> snippet.user  # => #Ecto.Association.NotLoaded<...>
>
> snippet = Repo.preload(snippet, :user)
> snippet.user  # => %User{...}
> ```
>
> Benefits:
> - **No N+1 queries**: You decide when to load
> - **Predictable**: Know exactly what data you have
> - **Explicit**: Data dependencies are visible
>
> The trade-off is more explicit code, but better performance and fewer surprises.
>
> **Further Reading**:
> - [Ecto Associations](https://hexdocs.pm/ecto/associations.html)

## Summary

In this chapter, we learned:

- `belongs_to` for many-to-one relationships
- `has_many` for one-to-many relationships
- `has_one` for one-to-one relationships
- `many_to_many` with join tables
- Preloading associated data
- Creating and deleting associated records

In the next chapter, we'll explore database transactions and Ecto.Multi.

---

## Additional Information

### Association Options

```elixir
# Custom foreign key
belongs_to :author, User, foreign_key: :author_id

# Custom association name
has_many :authored_snippets, Snippet, foreign_key: :author_id

# Where clause
has_many :public_snippets, Snippet, where: [is_public: true]

# Defaults (for has_one)
has_one :profile, Profile, defaults: [bio: "No bio yet"]
```

### Comparing to Other ORMs

**ActiveRecord**:
```ruby
class Snippet < ApplicationRecord
  belongs_to :user
  # Lazy loading by default
end

snippet.user  # Loads automatically
```

**Django**:
```python
class Snippet(models.Model):
    user = models.ForeignKey(User)
    # Lazy loading by default

snippet.user  # Loads automatically
```

**Ecto**:
```elixir
schema "snippets" do
  belongs_to :user, User
end

# Must explicitly preload
snippet = Repo.preload(snippet, :user)
```

Ecto's explicit approach prevents accidental N+1 queries.
