# Chapter 4: Database-Driven Responses

So far, our application has used hardcoded data. In this chapter, we'll integrate PostgreSQL using Ecto, Phoenix's database wrapper. We'll create schemas, run migrations, and execute queries to build a fully database-driven application.

## What is Ecto?

Ecto is Elixir's database library. It provides:

- **Schema**: Define your data structures
- **Changeset**: Validate and cast data
- **Query**: Build and execute database queries
- **Migration**: Version-control database changes
- **Repository**: Interface to the database

Think of Ecto as:
- **SQLAlchemy** (Python)
- **Active Record** (Ruby/Rails)
- **Entity Framework** (C#/.NET)
- **Sequelize** (Node.js)
- **Eloquent** (PHP/Laravel)

But with a functional approach.

## Ecto vs ORM

Ecto is NOT an ORM (Object-Relational Mapper). Key differences:

**Traditional ORM:**
```python
# Python/Django
user = User.objects.get(id=1)
user.email = "new@example.com"
user.save()  # Implicit database update
```

**Ecto (Functional):**
```elixir
# Explicit, composable operations
user = Repo.get(User, 1)
changeset = User.changeset(user, %{email: "new@example.com"})
{:ok, user} = Repo.update(changeset)
```

Ecto advantages:
- **Explicit**: No hidden queries
- **Composable**: Build queries step by step
- **Type-safe**: Compile-time checks
- **Testable**: Easy to mock/stub

## The Ecto Architecture

```
Your Application
       ↓
    Context (Business Logic)
       ↓
    Schema (Data Structure)
       ↓
    Changeset (Validation)
       ↓
    Query (Database Operations)
       ↓
    Repo (Database Interface)
       ↓
   PostgreSQL Database
```

## What We'll Build

In this chapter, we'll:

1. Set up PostgreSQL
2. Create the `snippets` table with migrations
3. Define a `Snippet` schema
4. Create a context for snippet operations
5. Execute queries (CRUD operations)
6. Use changesets for validation
7. Handle transactions

## The Snippets Table

Our `snippets` table will have:

```sql
CREATE TABLE snippets (
  id BIGSERIAL PRIMARY KEY,
  title VARCHAR(100) NOT NULL,
  content TEXT NOT NULL,
  expires_at TIMESTAMP,
  inserted_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_snippets_inserted_at ON snippets(inserted_at);
```

This stores:
- `id`: Auto-incrementing primary key
- `title`: Snippet title (max 100 characters)
- `content`: The actual snippet text
- `expires_at`: When snippet expires (nullable)
- `inserted_at`: Creation timestamp
- `updated_at`: Last modification timestamp

> **FP Concept: Separation of Concerns**
>
> In Ecto, we separate:
>
> 1. **Schema** - What the data looks like
> 2. **Changeset** - How to validate and transform data
> 3. **Query** - How to fetch data
> 4. **Repository** - How to persist data
>
> This is different from Active Record pattern where everything is in one model class:
>
> ```ruby
> # Rails: Everything in one class
> class User < ApplicationRecord
>   validates :email, presence: true
>   has_many :posts
>
>   def full_name
>     "#{first_name} #{last_name}"
>   end
> end
> ```
>
> vs Ecto's separated concerns:
>
> ```elixir
> # Schema - structure
> defmodule User do
>   schema "users" do
>     field :email, :string
>     has_many :posts, Post
>   end
> end
>
> # Changeset - validation (separate function)
> def changeset(user, attrs) do
>   cast(user, attrs, [:email])
>   |> validate_required([:email])
> end
>
> # Query - fetching (separate module/function)
> def list_users do
>   User |> Repo.all()
> end
> ```
>
> **Further Reading**:
> - [Ecto Schema](https://hexdocs.pm/ecto/Ecto.Schema.html)
> - [Understanding Ecto](https://elixirschool.com/en/lessons/ecto/basics)

## Comparing to Other ORMs

Here's how common operations compare:

### Fetching Records

**Rails (Ruby)**
```ruby
User.find(1)
User.where(active: true).order(created_at: :desc).limit(10)
```

**Django (Python)**
```python
User.objects.get(id=1)
User.objects.filter(active=True).order_by('-created_at')[:10]
```

**Entity Framework (C#)**
```csharp
context.Users.Find(1);
context.Users.Where(u => u.Active).OrderByDescending(u => u.CreatedAt).Take(10);
```

**Ecto (Elixir)**
```elixir
Repo.get(User, 1)
User
|> where([u], u.active == true)
|> order_by([u], desc: u.inserted_at)
|> limit(10)
|> Repo.all()
```

### Creating Records

**Rails**
```ruby
user = User.create(email: "test@example.com")
```

**Django**
```python
user = User.objects.create(email="test@example.com")
```

**Ecto**
```elixir
%User{}
|> User.changeset(%{email: "test@example.com"})
|> Repo.insert()
```

The Ecto way is more explicit but gives you more control over validation and error handling.

## Database Configuration

Phoenix already configured your database in `config/dev.exs`. Let's review it:

```elixir
# File: config/dev.exs

config :snippetbox, Snippetbox.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "snippetbox_dev",
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 10
```

This configuration:
- Connects to PostgreSQL on localhost
- Uses database `snippetbox_dev`
- Shows detailed errors in development
- Maintains a pool of 10 database connections

## The Repository Pattern

Phoenix generated `lib/snippetbox/repo.ex`:

```elixir
# File: lib/snippetbox/repo.ex

defmodule Snippetbox.Repo do
  use Ecto.Repo,
    otp_app: :snippetbox,
    adapter: Ecto.Adapters.Postgres
end
```

The `Repo` module is your interface to the database. All database operations go through it:

```elixir
Repo.insert(changeset)
Repo.update(changeset)
Repo.delete(schema)
Repo.all(query)
Repo.get(Schema, id)
```

> **Note**: The Repository pattern centralizes database access. Instead of models having `save()` methods, you explicitly call `Repo.insert()`, `Repo.update()`, etc. This makes database operations explicit and easier to test.

## Connection Pooling

Ecto uses connection pooling for efficiency:

```
Application
    ↓
[Worker1] ←→ [Connection 1]
[Worker2] ←→ [Connection 2]   } Pool of 10
[Worker3] ←→ [Connection 3]
[Worker4] ←→ [Connection 4]
    ...
```

Benefits:
- **Reuses connections** (faster than creating new ones)
- **Limits concurrent connections** (prevents overwhelming database)
- **Handles failures** (replaces broken connections)

The `pool_size: 10` means up to 10 simultaneous database queries.

## Next Steps

In the following sections, we'll:

1. Create migrations to set up the database schema
2. Define the `Snippet` schema module
3. Build a context for snippet operations
4. Execute queries to create, read, update, and delete snippets
5. Use changesets for validation
6. Handle complex queries and transactions

By the end of this chapter, you'll have a fully functional, database-backed application.

---

## Additional Information

### Why PostgreSQL?

We use PostgreSQL because:

- **Feature-rich**: JSON, full-text search, arrays, etc.
- **Reliable**: Battle-tested in production
- **Performance**: Handles millions of rows efficiently
- **Open source**: Free and community-supported
- **Phoenix-friendly**: Excellent Ecto support

Alternatives:
- **MySQL**: Also well-supported by Ecto
- **SQLite**: Good for development/testing
- **MSSQL**: Enterprise databases (via ecto_sql)

### Ecto vs Other Languages

Ecto's functional approach differs from traditional ORMs:

**Advantages:**
- No implicit state or behavior
- Explicit database operations
- Easy to compose queries
- Type-safe at compile-time
- Testable without database

**Learning Curve:**
- Different from Active Record pattern
- More explicit (more code initially)
- Requires understanding changesets

Most developers find Ecto clearer once they understand the pattern, even if it feels verbose at first.

### Connection Pool Sizing

Rule of thumb for pool size:

```
pool_size ≈ (available_db_connections) / (num_app_instances)
```

Example:
- PostgreSQL allows 100 connections
- You run 5 app instances
- Use pool_size: 20 per instance (100 / 5)

Phoenix defaults to 10, which is reasonable for development. Adjust for production based on load.
