# Chapter 9.2: Flash Messages

Flash messages provide feedback to users after actions. They persist across a single redirect and are automatically cleared after being displayed.

## How Flash Works

```
User submits form
       ↓
Controller processes
       ↓
put_flash(:info, "Success!")
       ↓
Redirect to new page
       ↓
Flash stored in session
       ↓
New page renders
       ↓
Flash displayed
       ↓
Flash cleared from session
```

## Using Flash Messages

### Setting Flash

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def create(conn, %{"snippet" => snippet_params}) do
  case Snippets.create_snippet(snippet_params) do
    {:ok, snippet} ->
      conn
      |> put_flash(:info, "Snippet created successfully.")
      |> redirect(to: ~p"/snippets/#{snippet}")

    {:error, changeset} ->
      conn
      |> put_flash(:error, "Please fix the errors below.")
      |> render(:new, changeset: changeset)
  end
end

def delete(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)
  {:ok, _} = Snippets.delete_snippet(snippet)

  conn
  |> put_flash(:info, "Snippet deleted.")
  |> redirect(to: ~p"/snippets")
end
```

### Flash Types

Common flash types by convention:

| Type | Usage | Typical Color |
|------|-------|---------------|
| `:info` | Success messages | Green/Blue |
| `:error` | Error messages | Red |
| `:warning` | Warning messages | Yellow/Orange |

```elixir
put_flash(conn, :info, "Profile updated!")
put_flash(conn, :error, "Could not save changes.")
put_flash(conn, :warning, "Your subscription expires soon.")
```

## Displaying Flash Messages

### In Layouts

```heex
<%# File: lib/snippetbox_web/components/layouts/app.html.heex %>

<main class="px-4 py-8">
  <.flash_group flash={@flash} />
  <%= @inner_content %>
</main>
```

### Default Flash Component

Phoenix generates flash components in `core_components.ex`:

```elixir
# File: lib/snippetbox_web/components/core_components.ex

attr :id, :string, doc: "the optional id of flash container"
attr :flash, :map, default: %{}, doc: "the map of flash messages"
attr :title, :string, default: nil
attr :kind, :atom, values: [:info, :error], doc: "used for styling and aria attributes"
attr :rest, :global, doc: "the arbitrary HTML attributes to add to the flash container"

slot :inner_block, doc: "the optional inner block that renders the flash message"

def flash(assigns) do
  assigns = assign_new(assigns, :id, fn -> "flash-#{assigns.kind}" end)

  ~H"""
  <div
    :if={msg = render_slot(@inner_block) || Phoenix.Flash.get(@flash, @kind)}
    id={@id}
    phx-click={JS.push("lv:clear-flash", value: %{key: @kind}) |> hide("##{@id}")}
    role="alert"
    class={[
      "fixed top-2 right-2 mr-2 w-80 sm:w-96 z-50 rounded-lg p-3 ring-1",
      @kind == :info && "bg-emerald-50 text-emerald-800 ring-emerald-500 fill-cyan-900",
      @kind == :error && "bg-rose-50 text-rose-900 ring-rose-500 fill-rose-900"
    ]}
    {@rest}
  >
    <p :if={@title} class="flex items-center gap-1.5 text-sm font-semibold leading-6">
      <.icon :if={@kind == :info} name="hero-information-circle-mini" class="h-4 w-4" />
      <.icon :if={@kind == :error} name="hero-exclamation-circle-mini" class="h-4 w-4" />
      <%= @title %>
    </p>
    <p class="mt-2 text-sm leading-5"><%= msg %></p>
    <button type="button" class="group absolute top-1 right-1 p-2" aria-label="close">
      <.icon name="hero-x-mark-solid" class="h-5 w-5 opacity-40 group-hover:opacity-70" />
    </button>
  </div>
  """
end

attr :flash, :map, required: true, doc: "the map of flash messages"
attr :id, :string, default: "flash-group", doc: "the optional id of flash container"

def flash_group(assigns) do
  ~H"""
  <div id={@id}>
    <.flash kind={:info} title="Success!" flash={@flash} />
    <.flash kind={:error} title="Error!" flash={@flash} />
    <.flash
      id="client-error"
      kind={:error}
      title="We can't find the internet"
      phx-disconnected={show(".phx-client-error #client-error")}
      phx-connected={hide("#client-error")}
      hidden
    >
      Attempting to reconnect <.icon name="hero-arrow-path" class="ml-1 h-3 w-3 animate-spin" />
    </.flash>

    <.flash
      id="server-error"
      kind={:error}
      title="Something went wrong!"
      phx-disconnected={show(".phx-server-error #server-error")}
      phx-connected={hide("#server-error")}
      hidden
    >
      Hang in there while we get back on track
      <.icon name="hero-arrow-path" class="ml-1 h-3 w-3 animate-spin" />
    </.flash>
  </div>
  """
end
```

### Custom Flash Display

```heex
<%# Simple inline display %>
<div :if={info = Phoenix.Flash.get(@flash, :info)} class="alert alert-info">
  <%= info %>
</div>

<div :if={error = Phoenix.Flash.get(@flash, :error)} class="alert alert-error">
  <%= error %>
</div>
```

### Multiple Flash Messages

```elixir
# Setting multiple flashes
conn
|> put_flash(:info, "Profile updated!")
|> put_flash(:warning, "Don't forget to verify your email.")
|> redirect(to: ~p"/profile")
```

```heex
<%# Display in template %>
<div :for={{type, message} <- @flash} class={"alert alert-#{type}"}>
  <%= message %>
</div>
```

## Flash with Render vs Redirect

### With Redirect (Persists)

```elixir
def create(conn, params) do
  # Flash persists through redirect
  conn
  |> put_flash(:info, "Created!")
  |> redirect(to: ~p"/snippets")
end
```

### With Render (Immediate)

```elixir
def create(conn, params) do
  case Snippets.create_snippet(params) do
    {:ok, snippet} ->
      redirect(conn, to: ~p"/snippets/#{snippet}")

    {:error, changeset} ->
      # Flash shown on same request (no redirect)
      conn
      |> put_flash(:error, "Please fix the errors.")
      |> render(:new, changeset: changeset)
  end
end
```

## LiveView Flash

### In LiveView

```elixir
# File: lib/snippetbox_web/live/snippet_live/index.ex

def handle_event("delete", %{"id" => id}, socket) do
  snippet = Snippets.get_snippet!(id)
  {:ok, _} = Snippets.delete_snippet(snippet)

  {:noreply,
   socket
   |> put_flash(:info, "Snippet deleted.")
   |> stream_delete(:snippets, snippet)}
end
```

### Clearing Flash in LiveView

```elixir
# Automatically cleared on navigation
# Or manually clear:
def handle_event("dismiss-flash", %{"key" => key}, socket) do
  {:noreply, clear_flash(socket, String.to_existing_atom(key))}
end
```

## Flash Helper Functions

### Creating Flash Helpers

```elixir
# File: lib/snippetbox_web/controllers/helpers.ex

defmodule SnippetboxWeb.Helpers do
  import Phoenix.Controller

  def flash_success(conn, message) do
    put_flash(conn, :info, message)
  end

  def flash_error(conn, message) do
    put_flash(conn, :error, message)
  end

  def flash_warning(conn, message) do
    put_flash(conn, :warning, message)
  end
end
```

### Form Error Flash

```elixir
def create(conn, %{"snippet" => params}) do
  case Snippets.create_snippet(params) do
    {:ok, snippet} ->
      conn
      |> put_flash(:info, "Snippet created!")
      |> redirect(to: ~p"/snippets/#{snippet}")

    {:error, %Ecto.Changeset{} = changeset} ->
      error_count = length(changeset.errors)

      conn
      |> put_flash(:error, "Please fix #{error_count} error(s) below.")
      |> render(:new, changeset: changeset)
  end
end
```

## Styled Flash Components

### Toast-Style Flash

```elixir
# File: lib/snippetbox_web/components/core_components.ex

def toast(assigns) do
  ~H"""
  <div
    :if={msg = Phoenix.Flash.get(@flash, @kind)}
    id={"toast-#{@kind}"}
    class={[
      "fixed bottom-4 right-4 z-50 rounded-lg shadow-lg p-4 max-w-sm",
      "transform transition-all duration-300",
      @kind == :info && "bg-green-500 text-white",
      @kind == :error && "bg-red-500 text-white",
      @kind == :warning && "bg-yellow-500 text-black"
    ]}
    role="alert"
    phx-click={JS.hide(to: "#toast-#{@kind}")}
  >
    <div class="flex items-center gap-2">
      <.icon :if={@kind == :info} name="hero-check-circle" class="h-5 w-5" />
      <.icon :if={@kind == :error} name="hero-x-circle" class="h-5 w-5" />
      <.icon :if={@kind == :warning} name="hero-exclamation-triangle" class="h-5 w-5" />
      <span><%= msg %></span>
    </div>
  </div>
  """
end
```

### Auto-Dismissing Flash

```heex
<div
  :if={msg = Phoenix.Flash.get(@flash, :info)}
  id="flash-info"
  class="alert alert-info"
  phx-mounted={JS.hide(time: 5000, to: "#flash-info")}
>
  <%= msg %>
</div>
```

Or with JavaScript:

```javascript
// Auto-hide flash after 5 seconds
document.querySelectorAll('[data-flash-auto-hide]').forEach(el => {
  setTimeout(() => {
    el.style.transition = 'opacity 0.5s';
    el.style.opacity = '0';
    setTimeout(() => el.remove(), 500);
  }, 5000);
});
```

## Accessing Flash in Controllers

### Reading Flash

```elixir
def show(conn, _params) do
  # Read flash value
  info_message = Phoenix.Flash.get(conn.assigns.flash, :info)

  # Flash is also available in templates via @flash
  render(conn, :show)
end
```

### Clearing Flash

```elixir
def clear_notifications(conn, _params) do
  conn
  |> clear_flash()  # Clears all flash messages
  |> redirect(to: ~p"/")
end
```

> **FP Concept: Ephemeral State**
>
> Flash messages are ephemeral - they exist for one "hop":
>
> ```elixir
> # Request 1: Set flash
> put_flash(conn, :info, "Saved!")
> redirect(to: "/page")
>
> # Request 2: Flash available
> Phoenix.Flash.get(@flash, :info) # => "Saved!"
>
> # Request 3: Flash gone
> Phoenix.Flash.get(@flash, :info) # => nil
> ```
>
> This automatic cleanup is a functional pattern - state is explicitly managed rather than persisting indefinitely.

## Summary

In this chapter, we learned:

- How flash messages work
- Setting flash with `put_flash/3`
- Displaying flash in layouts and templates
- Custom flash components
- LiveView flash handling
- Auto-dismissing flash
- Flash helper functions

In the next chapter, we'll explore cookies.
