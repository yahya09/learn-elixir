# Chapter 4.8: Transactions and Ecto.Multi

When multiple database operations must succeed or fail together, you need transactions. In this chapter, we'll learn how to use transactions and the powerful Ecto.Multi module.

## Why Transactions?

Consider creating a snippet with tags:

```elixir
# Without transaction - DANGEROUS
{:ok, snippet} = Repo.insert(snippet_changeset)
{:ok, _} = Repo.insert_all(:snippet_tags, tag_entries)  # What if this fails?
```

If the second operation fails, you have a snippet without tags - inconsistent data.

## Basic Transactions

### Repo.transaction/1

```elixir
Repo.transaction(fn ->
  {:ok, snippet} = Repo.insert(snippet_changeset)
  {:ok, _} = create_tags(snippet, tags)
  snippet
end)
# Returns {:ok, snippet} or {:error, reason}
```

### Handling Errors

```elixir
Repo.transaction(fn ->
  case Repo.insert(snippet_changeset) do
    {:ok, snippet} ->
      case create_tags(snippet, tags) do
        {:ok, _} -> snippet
        {:error, reason} -> Repo.rollback(reason)
      end

    {:error, changeset} ->
      Repo.rollback(changeset)
  end
end)
```

### Raising in Transactions

```elixir
Repo.transaction(fn ->
  # Using bang functions - raises on failure, causing rollback
  snippet = Repo.insert!(snippet_changeset)
  Repo.insert_all!(SnippetTag, tag_entries)
  snippet
end)
```

## Ecto.Multi

Ecto.Multi provides a cleaner way to compose transactions:

### Basic Multi

```elixir
alias Ecto.Multi

def create_snippet_with_tags(attrs, tag_names) do
  Multi.new()
  |> Multi.insert(:snippet, Snippet.changeset(%Snippet{}, attrs))
  |> Multi.run(:tags, fn repo, %{snippet: snippet} ->
    create_tags(repo, snippet, tag_names)
  end)
  |> Repo.transaction()
end

defp create_tags(repo, snippet, tag_names) do
  now = DateTime.utc_now()
  entries = Enum.map(tag_names, fn name ->
    %{snippet_id: snippet.id, tag: name, inserted_at: now, updated_at: now}
  end)

  case repo.insert_all(SnippetTag, entries) do
    {count, _} when count > 0 -> {:ok, count}
    _ -> {:error, :no_tags_created}
  end
end
```

### Multi Operations

```elixir
Multi.new()
# Insert
|> Multi.insert(:user, User.changeset(%User{}, attrs))

# Update
|> Multi.update(:profile, fn %{user: user} ->
  Profile.changeset(user.profile, profile_attrs)
end)

# Delete
|> Multi.delete(:old_profile, old_profile)

# Insert all
|> Multi.insert_all(:logs, AuditLog, log_entries)

# Update all
|> Multi.update_all(:reset, from(s in Session, where: s.user_id == ^user_id),
  set: [active: false])

# Delete all
|> Multi.delete_all(:cleanup, from(t in Token, where: t.expires_at < ^now))

# Run arbitrary function
|> Multi.run(:notify, fn _repo, %{user: user} ->
  send_welcome_email(user)
  {:ok, :notified}
end)

# Execute transaction
|> Repo.transaction()
```

### Accessing Previous Results

Each step can access results from previous steps:

```elixir
Multi.new()
|> Multi.insert(:user, user_changeset)
|> Multi.insert(:profile, fn %{user: user} ->
  # Access user from previous step
  %Profile{}
  |> Profile.changeset(%{user_id: user.id, bio: "New user"})
end)
|> Multi.run(:welcome_email, fn _repo, %{user: user} ->
  # Access user in run function
  Mailer.send_welcome(user)
  {:ok, :sent}
end)
```

### Multi.merge

Combine multiple Multis:

```elixir
def register_user(attrs) do
  Multi.new()
  |> Multi.insert(:user, User.registration_changeset(%User{}, attrs))
  |> Multi.merge(&create_default_settings/1)
  |> Multi.merge(&send_welcome_email/1)
  |> Repo.transaction()
end

defp create_default_settings(%{user: user}) do
  Multi.new()
  |> Multi.insert(:settings, %Settings{user_id: user.id, theme: "light"})
end

defp send_welcome_email(%{user: user}) do
  Multi.new()
  |> Multi.run(:email, fn _, _ ->
    Mailer.welcome(user)
    {:ok, :sent}
  end)
end
```

### Conditional Operations

```elixir
def create_snippet(attrs, opts \\ []) do
  multi = Multi.new()
  |> Multi.insert(:snippet, Snippet.changeset(%Snippet{}, attrs))

  multi = if opts[:notify] do
    Multi.run(multi, :notification, fn _, %{snippet: snippet} ->
      notify_followers(snippet)
    end)
  else
    multi
  end

  Repo.transaction(multi)
end
```

### Error Handling with Multi

```elixir
case Repo.transaction(multi) do
  {:ok, %{user: user, profile: profile}} ->
    # All operations succeeded
    {:ok, user}

  {:error, :user, changeset, _changes_so_far} ->
    # User insert failed
    {:error, changeset}

  {:error, :profile, changeset, %{user: user}} ->
    # Profile failed, but user was created (then rolled back)
    {:error, changeset}

  {:error, :email, reason, _} ->
    # Email sending failed
    {:error, reason}
end
```

## Real-World Examples

### Transfer Money

```elixir
def transfer(from_account_id, to_account_id, amount) do
  Multi.new()
  |> Multi.run(:from_account, fn repo, _ ->
    case repo.get(Account, from_account_id) do
      nil -> {:error, :from_account_not_found}
      account -> {:ok, account}
    end
  end)
  |> Multi.run(:to_account, fn repo, _ ->
    case repo.get(Account, to_account_id) do
      nil -> {:error, :to_account_not_found}
      account -> {:ok, account}
    end
  end)
  |> Multi.run(:check_balance, fn _, %{from_account: from} ->
    if from.balance >= amount do
      {:ok, :sufficient}
    else
      {:error, :insufficient_funds}
    end
  end)
  |> Multi.update(:debit, fn %{from_account: from} ->
    Account.changeset(from, %{balance: from.balance - amount})
  end)
  |> Multi.update(:credit, fn %{to_account: to} ->
    Account.changeset(to, %{balance: to.balance + amount})
  end)
  |> Multi.insert(:transaction_log, fn %{from_account: from, to_account: to} ->
    TransactionLog.changeset(%TransactionLog{}, %{
      from_id: from.id,
      to_id: to.id,
      amount: amount
    })
  end)
  |> Repo.transaction()
end
```

### User Registration

```elixir
def register_user(attrs) do
  Multi.new()
  |> Multi.insert(:user, User.registration_changeset(%User{}, attrs))
  |> Multi.insert(:profile, fn %{user: user} ->
    Profile.changeset(%Profile{}, %{user_id: user.id})
  end)
  |> Multi.insert(:settings, fn %{user: user} ->
    Settings.changeset(%Settings{}, %{user_id: user.id})
  end)
  |> Multi.run(:verification_token, fn repo, %{user: user} ->
    token = generate_token()
    case repo.insert(%VerificationToken{user_id: user.id, token: token}) do
      {:ok, _} -> {:ok, token}
      error -> error
    end
  end)
  |> Multi.run(:send_email, fn _, %{user: user, verification_token: token} ->
    case Mailer.send_verification(user.email, token) do
      :ok -> {:ok, :sent}
      error -> {:error, error}
    end
  end)
  |> Repo.transaction()
end
```

### Bulk Import

```elixir
def import_snippets(user, snippets_data) do
  now = DateTime.utc_now()

  entries = Enum.map(snippets_data, fn data ->
    %{
      title: data["title"],
      content: data["content"],
      user_id: user.id,
      inserted_at: now,
      updated_at: now
    }
  end)

  Multi.new()
  |> Multi.insert_all(:snippets, Snippet, entries, returning: [:id])
  |> Multi.run(:audit, fn repo, %{snippets: {count, snippets}} ->
    audit_entry = %{
      user_id: user.id,
      action: "bulk_import",
      count: count,
      snippet_ids: Enum.map(snippets, & &1.id),
      inserted_at: now
    }
    repo.insert(AuditLog.changeset(%AuditLog{}, audit_entry))
  end)
  |> Repo.transaction()
end
```

## Transaction Isolation

### Isolation Levels

```elixir
# Read committed (default)
Repo.transaction(fn -> ... end)

# Serializable (strictest)
Repo.transaction(fn -> ... end, isolation: :serializable)

# Repeatable read
Repo.transaction(fn -> ... end, isolation: :repeatable_read)
```

### Locking

```elixir
# Pessimistic locking
from(a in Account, where: a.id == ^id, lock: "FOR UPDATE")
|> Repo.one()

# In transaction
Repo.transaction(fn ->
  account = Repo.one!(from a in Account, where: a.id == ^id, lock: "FOR UPDATE")
  # Account is locked until transaction completes
  Repo.update!(Account.changeset(account, %{balance: account.balance - 100}))
end)
```

> **FP Concept: Multi as Data Structure**
>
> Ecto.Multi is a data structure that describes operations:
>
> ```elixir
> multi = Multi.new()
> |> Multi.insert(:user, changeset)
> |> Multi.insert(:profile, profile_changeset)
>
> # multi is just data, nothing executed yet
> # Inspect it:
> IO.inspect(multi.operations)
>
> # Execute when ready:
> Repo.transaction(multi)
> ```
>
> Benefits:
> - **Composable**: Combine Multis with merge
> - **Testable**: Inspect operations without executing
> - **Declarative**: Describe what, not how
>
> **Further Reading**:
> - [Ecto.Multi](https://hexdocs.pm/ecto/Ecto.Multi.html)

## Summary

In this chapter, we learned:

- Basic transactions with `Repo.transaction/1`
- Ecto.Multi for composing complex transactions
- Multi operations (insert, update, delete, run)
- Accessing results from previous steps
- Error handling in transactions
- Real-world transaction patterns
- Isolation levels and locking

In the next chapter, we'll cover database best practices and optimization.

---

## Additional Information

### Transaction Timeouts

```elixir
# Default timeout is 15 seconds
Repo.transaction(fn -> ... end, timeout: 30_000)
```

### Nested Transactions

Ecto doesn't support true nested transactions. Inner transactions become savepoints:

```elixir
Repo.transaction(fn ->
  # Outer transaction
  Repo.transaction(fn ->
    # This is a savepoint, not a separate transaction
  end)
end)
```

### Testing Transactions

```elixir
# In test
test "transfer rolls back on insufficient funds" do
  {:error, :insufficient_funds} = Accounts.transfer(from.id, to.id, 1_000_000)

  # Verify no changes
  assert Repo.get!(Account, from.id).balance == original_balance
end
```
