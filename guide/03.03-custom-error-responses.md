# Chapter 3.3: Custom Error Responses

Errors happen. Users visit pages that don't exist, submit invalid data, or encounter server problems. In this chapter, we'll learn how Phoenix handles errors and how to customize error responses.

## How Phoenix Handles Errors

Phoenix converts exceptions to HTTP responses through the error handling pipeline:

```
Exception Raised
      ↓
Phoenix.Endpoint catches it
      ↓
Converts to appropriate status code
      ↓
Renders error view (ErrorHTML or ErrorJSON)
      ↓
Returns response to client
```

## Default Error Configuration

Error handling is configured in your endpoint:

```elixir
# File: lib/snippetbox_web/endpoint.ex

defmodule SnippetboxWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :snippetbox

  # ... other plugs ...

  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  # Error handling is configured here
  # (via render_errors in config)
end
```

```elixir
# File: config/config.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  render_errors: [
    formats: [html: SnippetboxWeb.ErrorHTML, json: SnippetboxWeb.ErrorJSON],
    layout: false
  ]
```

## Common HTTP Errors

Phoenix maps these exceptions to status codes:

| Exception | Status Code | Meaning |
|-----------|-------------|---------|
| `Ecto.NoResultsError` | 404 | Record not found |
| `Phoenix.Router.NoRouteError` | 404 | Route not found |
| `Phoenix.ActionClauseError` | 400 | Bad parameters |
| `Ecto.Query.CastError` | 400 | Invalid query value |
| `Plug.CSRFProtection.InvalidCSRFTokenError` | 403 | Invalid CSRF token |
| Any other exception | 500 | Server error |

## The Error HTML Module

Phoenix generates a basic error view:

```elixir
# File: lib/snippetbox_web/controllers/error_html.ex

defmodule SnippetboxWeb.ErrorHTML do
  use SnippetboxWeb, :html

  # If you want to customize error pages, create templates:
  # - error_html/404.html.heex
  # - error_html/500.html.heex

  embed_templates "error_html/*"

  # Default fallback for any status code
  def render(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end
```

The default `render/2` function returns status messages like "Not Found" or "Internal Server Error".

## Creating Custom Error Templates

### 404 Page (Not Found)

```heex
<%# File: lib/snippetbox_web/controllers/error_html/404.html.heex %>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Page Not Found - Snippetbox</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: #f9fafb;
    }
    .error-container {
      text-align: center;
      padding: 2rem;
    }
    h1 {
      font-size: 6rem;
      margin: 0;
      color: #4f46e5;
    }
    h2 {
      font-size: 1.5rem;
      color: #374151;
      margin: 1rem 0;
    }
    p {
      color: #6b7280;
      margin-bottom: 2rem;
    }
    a {
      color: #4f46e5;
      text-decoration: none;
      padding: 0.75rem 1.5rem;
      border: 2px solid #4f46e5;
      border-radius: 6px;
    }
    a:hover {
      background: #4f46e5;
      color: white;
    }
  </style>
</head>
<body>
  <div class="error-container">
    <h1>404</h1>
    <h2>Page Not Found</h2>
    <p>Sorry, the page you're looking for doesn't exist or has been moved.</p>
    <a href="/">Go Home</a>
  </div>
</body>
</html>
```

### 500 Page (Server Error)

```heex
<%# File: lib/snippetbox_web/controllers/error_html/500.html.heex %>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Server Error - Snippetbox</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: #f9fafb;
    }
    .error-container {
      text-align: center;
      padding: 2rem;
    }
    h1 {
      font-size: 6rem;
      margin: 0;
      color: #ef4444;
    }
    h2 {
      font-size: 1.5rem;
      color: #374151;
      margin: 1rem 0;
    }
    p {
      color: #6b7280;
      margin-bottom: 2rem;
    }
    a {
      color: #4f46e5;
      text-decoration: none;
      padding: 0.75rem 1.5rem;
      border: 2px solid #4f46e5;
      border-radius: 6px;
    }
    a:hover {
      background: #4f46e5;
      color: white;
    }
  </style>
</head>
<body>
  <div class="error-container">
    <h1>500</h1>
    <h2>Something Went Wrong</h2>
    <p>We're sorry, but something went wrong on our end. Please try again later.</p>
    <a href="/">Go Home</a>
  </div>
</body>
</html>
```

## Error JSON Module

For API responses:

```elixir
# File: lib/snippetbox_web/controllers/error_json.ex

defmodule SnippetboxWeb.ErrorJSON do
  @moduledoc """
  JSON error responses for API endpoints.
  """

  # Customize specific errors
  def render("404.json", _assigns) do
    %{
      error: %{
        status: 404,
        message: "Resource not found",
        code: "not_found"
      }
    }
  end

  def render("422.json", %{changeset: changeset}) do
    %{
      error: %{
        status: 422,
        message: "Validation failed",
        code: "validation_error",
        details: format_changeset_errors(changeset)
      }
    }
  end

  def render("500.json", _assigns) do
    %{
      error: %{
        status: 500,
        message: "Internal server error",
        code: "server_error"
      }
    }
  end

  # Fallback for any other status
  def render(template, _assigns) do
    status = status_from_template(template)
    %{
      error: %{
        status: status,
        message: Phoenix.Controller.status_message_from_template(template),
        code: code_from_status(status)
      }
    }
  end

  defp status_from_template(template) do
    template
    |> String.replace(".json", "")
    |> String.to_integer()
  end

  defp code_from_status(400), do: "bad_request"
  defp code_from_status(401), do: "unauthorized"
  defp code_from_status(403), do: "forbidden"
  defp code_from_status(404), do: "not_found"
  defp code_from_status(422), do: "unprocessable_entity"
  defp code_from_status(_), do: "error"

  defp format_changeset_errors(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
      Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
      end)
    end)
  end
end
```

## Returning Errors from Controllers

### Using put_status and render

```elixir
def show(conn, %{"id" => id}) do
  case Snippets.get_snippet(id) do
    nil ->
      conn
      |> put_status(:not_found)
      |> put_view(SnippetboxWeb.ErrorHTML)
      |> render(:"404")

    snippet ->
      render(conn, :show, snippet: snippet)
  end
end
```

### Using Exceptions

Let Phoenix handle the conversion:

```elixir
def show(conn, %{"id" => id}) do
  # Raises Ecto.NoResultsError → 404
  snippet = Snippets.get_snippet!(id)
  render(conn, :show, snippet: snippet)
end
```

### Custom Exceptions

Define your own exceptions:

```elixir
# File: lib/snippetbox_web/errors.ex

defmodule SnippetboxWeb.NotFoundError do
  defexception [:message, plug_status: 404]

  def exception(opts) do
    message = Keyword.get(opts, :message, "Resource not found")
    %__MODULE__{message: message}
  end
end

defmodule SnippetboxWeb.UnauthorizedError do
  defexception [:message, plug_status: 401]

  def exception(opts) do
    message = Keyword.get(opts, :message, "Authentication required")
    %__MODULE__{message: message}
  end
end

defmodule SnippetboxWeb.ForbiddenError do
  defexception [:message, plug_status: 403]

  def exception(opts) do
    message = Keyword.get(opts, :message, "Access denied")
    %__MODULE__{message: message}
  end
end
```

Use in controllers:

```elixir
def show(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)

  unless can_view?(conn.assigns.current_user, snippet) do
    raise SnippetboxWeb.ForbiddenError,
      message: "You don't have permission to view this snippet"
  end

  render(conn, :show, snippet: snippet)
end
```

## Error Handling with Fallback Controllers

For APIs, use a fallback controller to handle errors consistently:

```elixir
# File: lib/snippetbox_web/controllers/fallback_controller.ex

defmodule SnippetboxWeb.FallbackController do
  use SnippetboxWeb, :controller

  # Handle Ecto changeset errors
  def call(conn, {:error, %Ecto.Changeset{} = changeset}) do
    conn
    |> put_status(:unprocessable_entity)
    |> put_view(json: SnippetboxWeb.ErrorJSON)
    |> render("422.json", changeset: changeset)
  end

  # Handle not found
  def call(conn, {:error, :not_found}) do
    conn
    |> put_status(:not_found)
    |> put_view(json: SnippetboxWeb.ErrorJSON)
    |> render("404.json")
  end

  # Handle unauthorized
  def call(conn, {:error, :unauthorized}) do
    conn
    |> put_status(:unauthorized)
    |> put_view(json: SnippetboxWeb.ErrorJSON)
    |> render("401.json")
  end

  # Handle forbidden
  def call(conn, {:error, :forbidden}) do
    conn
    |> put_status(:forbidden)
    |> put_view(json: SnippetboxWeb.ErrorJSON)
    |> render("403.json")
  end
end
```

Use in API controllers:

```elixir
# File: lib/snippetbox_web/controllers/api/snippet_controller.ex

defmodule SnippetboxWeb.API.SnippetController do
  use SnippetboxWeb, :controller

  action_fallback SnippetboxWeb.FallbackController

  def show(conn, %{"id" => id}) do
    with {:ok, snippet} <- Snippets.fetch_snippet(id) do
      json(conn, %{data: snippet})
    end
  end

  def create(conn, %{"snippet" => params}) do
    with {:ok, snippet} <- Snippets.create_snippet(params) do
      conn
      |> put_status(:created)
      |> json(%{data: snippet})
    end
  end
end
```

The context returns tuples:

```elixir
# File: lib/snippetbox/snippets.ex

def fetch_snippet(id) do
  case Repo.get(Snippet, id) do
    nil -> {:error, :not_found}
    snippet -> {:ok, snippet}
  end
end

def create_snippet(attrs) do
  %Snippet{}
  |> Snippet.changeset(attrs)
  |> Repo.insert()
  # Returns {:ok, snippet} or {:error, changeset}
end
```

## Debug vs Production Errors

Phoenix shows detailed errors in development:

```elixir
# File: config/dev.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  debug_errors: true,  # Show detailed error page
  code_reloader: true
```

In production, errors are generic:

```elixir
# File: config/prod.exs

config :snippetbox, SnippetboxWeb.Endpoint,
  debug_errors: false  # Show custom error pages
```

## Handling Specific Exceptions

Customize handling for specific exceptions:

```elixir
# File: lib/snippetbox_web/controllers/error_html.ex

defmodule SnippetboxWeb.ErrorHTML do
  use SnippetboxWeb, :html

  embed_templates "error_html/*"

  # Custom template for specific errors
  def render("404.html", assigns) do
    render("404.html", assigns)
  end

  def render("500.html", assigns) do
    render("500.html", assigns)
  end

  # Access the reason in templates if needed
  def render(template, %{reason: reason} = assigns) do
    # Log the actual error
    require Logger
    Logger.error("Error: #{inspect(reason)}")

    # Render generic page
    render_generic(template, assigns)
  end

  def render(template, assigns) do
    render_generic(template, assigns)
  end

  defp render_generic(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end
```

> **FP Concept: Pattern Matching for Error Handling**
>
> Phoenix uses pattern matching to route errors to handlers:
>
> ```elixir
> def call(conn, {:error, :not_found}), do: render_404(conn)
> def call(conn, {:error, :unauthorized}), do: render_401(conn)
> def call(conn, {:error, %Ecto.Changeset{}}), do: render_422(conn)
> ```
>
> This is cleaner than imperative error checking:
>
> ```python
> # Imperative
> if isinstance(error, NotFoundError):
>     return render_404()
> elif isinstance(error, UnauthorizedError):
>     return render_401()
> ```
>
> Pattern matching:
> - **Declarative**: Express what to do for each case
> - **Exhaustive**: Compiler warns about unhandled cases
> - **Extensible**: Add new cases without changing existing code
>
> **Further Reading**:
> - [With Special Form](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1)
> - [Error Handling in Elixir](https://elixir-lang.org/getting-started/try-catch-and-rescue.html)

## Summary

In this chapter, we learned:

- How Phoenix handles errors
- Creating custom 404 and 500 pages
- Error JSON responses for APIs
- Using exceptions with custom status codes
- Fallback controllers for consistent API errors
- Debug vs production error display

In the next chapter, we'll create more sophisticated custom error pages.

---

## Additional Information

### Testing Error Pages

```elixir
# File: test/snippetbox_web/controllers/error_html_test.exs

defmodule SnippetboxWeb.ErrorHTMLTest do
  use SnippetboxWeb.ConnCase, async: true

  test "renders 404.html" do
    assert render_to_string(SnippetboxWeb.ErrorHTML, "404.html", []) =~
           "Page Not Found"
  end

  test "renders 500.html" do
    assert render_to_string(SnippetboxWeb.ErrorHTML, "500.html", []) =~
           "Something Went Wrong"
  end
end
```

### Comparing to Other Frameworks

**Rails**:
```ruby
# app/controllers/errors_controller.rb
class ErrorsController < ApplicationController
  def not_found
    render status: 404
  end
end
```

**Express**:
```javascript
app.use((err, req, res, next) => {
  res.status(err.status || 500).render('error', { error: err });
});
```

**Django**:
```python
# views.py
def handler404(request, exception):
    return render(request, '404.html', status=404)
```

**Phoenix**:
```elixir
# Automatic conversion of exceptions to HTTP responses
# Plus explicit ErrorHTML/ErrorJSON modules
```

Phoenix's approach is more structured, with clear separation between HTML and JSON errors.
