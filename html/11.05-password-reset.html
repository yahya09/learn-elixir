<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Password Reset &mdash; Let's Build with Elixir and Phoenix</title>
    <link rel="stylesheet" type="text/css" href="assets/css/main.css">
</head>
<body>
    <header>
        <div class="wrapper">
            <div>
                <a href="index.html">Let's Build with Elixir and Phoenix</a>
                <span class="crumbs">&rsaquo; Password Reset</span>
            </div>
            <div>
                &lsaquo; <a href="11.04-remember-me.html">Previous</a> &middot;
                <a href="00.01-contents.html">Contents</a>
                &middot; <a href="11.06-email-verification.html">Next</a> &rsaquo;
            </div>
        </div>
    </header>
    <main class="wrapper text">
        <div class="chapter">Chapter 11.5</div>
        <h1>Chapter 11.5: Password Reset</h1>

<p>Users forget passwords. In this chapter, we'll implement a secure password reset flow via email.</p>

<h2>Password Reset Flow</h2>

<figure class="code"><pre><code>1. User requests reset on /forgot-password
<ol>
<li>Server generates secure token</li>
<li>Token emailed to user</li>
<li>User clicks link with token</li>
<li>User sets new password</li>
<li>Token invalidated, user logged in</li>
</ol>
</code></pre></figure>

<h2>Token Generation</h2>

<figure class="code"><figcaption>File: lib/snippetbox/accounts/user_token.ex</figcaption><pre><code class="language-elixir">
<p>@reset_password_validity_in_days 1</p>

<p>@doc """</p>
<p>Builds a token with a hashed counter part.</p>

<p>The non-hashed token is sent to the user email while the</p>
<p>hashed part is stored in the database. The original token cannot</p>
<p>be reconstructed, making it safer for storage.</p>
<p>"""</p>
<p>def build_email_token(user, context) do</p>
<p>  build_hashed_token(user, context, user.email)</p>
<p>end</p>

<p>defp build_hashed_token(user, context, sent_to) do</p>
<p>  token = :crypto.strong_rand_bytes(@rand_size)</p>
<p>  hashed_token = :crypto.hash(@hash_algorithm, token)</p>

<p>  {Base.url_encode64(token, padding: false),</p>
<p>   %__MODULE__{</p>
<p>     token: hashed_token,</p>
<p>     context: context,</p>
<p>     sent_to: sent_to,</p>
<p>     user_id: user.id</p>
<p>   }}</p>
<p>end</p>

<p>@doc """</p>
<p>Checks if the token is valid and returns its underlying lookup query.</p>
<p>"""</p>
<p>def verify_email_token_query(token, context) do</p>
<p>  case Base.url_decode64(token, padding: false) do</p>
<p>    {:ok, decoded_token} -></p>
<p>      hashed_token = :crypto.hash(@hash_algorithm, decoded_token)</p>
<p>      days = days_for_context(context)</p>

<p>      query =</p>
<p>        from token in by_token_and_context_query(hashed_token, context),</p>
<p>          join: user in assoc(token, :user),</p>
<p>          where: token.inserted_at > ago(^days, "day") and token.sent_to == user.email,</p>
<p>          select: user</p>

<p>      {:ok, query}</p>

<p>    :error -></p>
<p>      :error</p>
<p>  end</p>
<p>end</p>

<p>defp days_for_context("reset_password"), do: @reset_password_validity_in_days</p>
<p>defp days_for_context("confirm"), do: @confirm_validity_in_days</p>
</code></pre></figure>

<h2>Context Functions</h2>

<figure class="code"><figcaption>File: lib/snippetbox/accounts.ex</figcaption><pre><code class="language-elixir">
<p>@doc """</p>
<p>Delivers the reset password email to the given user.</p>
<p>"""</p>
<p>def deliver_user_reset_password_instructions(user, reset_password_url_fun)</p>
<p>    when is_function(reset_password_url_fun, 1) do</p>
<p>  {encoded_token, user_token} = UserToken.build_email_token(user, "reset_password")</p>
<p>  Repo.insert!(user_token)</p>
<p>  UserNotifier.deliver_reset_password_instructions(user, reset_password_url_fun.(encoded_token))</p>
<p>end</p>

<p>@doc """</p>
<p>Gets the user by reset password token.</p>
<p>"""</p>
<p>def get_user_by_reset_password_token(token) do</p>
<p>  with {:ok, query} <- UserToken.verify_email_token_query(token, "reset_password"),</p>
<p>       %User{} = user <- Repo.one(query) do</p>
<p>    user</p>
<p>  else</p>
<p>    _ -> nil</p>
<p>  end</p>
<p>end</p>

<p>@doc """</p>
<p>Resets the user password.</p>
<p>"""</p>
<p>def reset_user_password(user, attrs) do</p>
<p>  Ecto.Multi.new()</p>
<p>  |> Ecto.Multi.update(:user, User.password_changeset(user, attrs))</p>
<p>  |> Ecto.Multi.delete_all(:tokens, UserToken.by_user_and_contexts_query(user, :all))</p>
<p>  |> Repo.transaction()</p>
<p>  |> case do</p>
<p>    {:ok, %{user: user}} -> {:ok, user}</p>
<p>    {:error, :user, changeset, _} -> {:error, changeset}</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Email Notifier</h2>

<figure class="code"><figcaption>File: lib/snippetbox/accounts/user_notifier.ex</figcaption><pre><code class="language-elixir">
<p>defmodule Snippetbox.Accounts.UserNotifier do</p>
<p>  import Swoosh.Email</p>

<p>  alias Snippetbox.Mailer</p>

<p>  defp deliver(recipient, subject, body) do</p>
<p>    email =</p>
<p>      new()</p>
<p>      |> to(recipient)</p>
<p>      |> from({"Snippetbox", "noreply@snippetbox.com"})</p>
<p>      |> subject(subject)</p>
<p>      |> text_body(body)</p>

<p>    with {:ok, _metadata} <- Mailer.deliver(email) do</p>
<p>      {:ok, email}</p>
<p>    end</p>
<p>  end</p>

<p>  @doc """</p>
<p>  Deliver instructions to reset a user password.</p>
<p>  """</p>
<p>  def deliver_reset_password_instructions(user, url) do</p>
<p>    deliver(user.email, "Reset your password", """</p>
<p>    Hi #{user.name},</p>

<p>    You can reset your password by visiting the URL below:</p>

<p>    #{url}</p>

<p>    If you didn't request this change, please ignore this email.</p>

<p>    This link will expire in 24 hours.</p>
<p>    """)</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Controllers</h2>

<h3>Forgot Password</h3>

<figure class="code"><figcaption>File: lib/snippetbox_web/controllers/user_reset_password_controller.ex</figcaption><pre><code class="language-elixir">
<p>defmodule SnippetboxWeb.UserResetPasswordController do</p>
<p>  use SnippetboxWeb, :controller</p>

<p>  alias Snippetbox.Accounts</p>

<p>  plug :get_user_by_reset_password_token when action in [:edit, :update]</p>

<p>  def new(conn, _params) do</p>
<p>    render(conn, :new)</p>
<p>  end</p>

<p>  def create(conn, %{"user" => %{"email" => email}}) do</p>
<p>    if user = Accounts.get_user_by_email(email) do</p>
<p>      Accounts.deliver_user_reset_password_instructions(</p>
<p>        user,</p>
<p>        &url(~p"/reset-password/#{&1}")</p>
<p>      )</p>
<p>    end</p>

<p>    # Always show same message to prevent email enumeration</p>
<p>    conn</p>
<p>    |> put_flash(:info, "If your email is in our system, you will receive password reset instructions shortly.")</p>
<p>    |> redirect(to: ~p"/")</p>
<p>  end</p>

<p>  def edit(conn, _params) do</p>
<p>    render(conn, :edit, changeset: Accounts.change_user_password(conn.assigns.user))</p>
<p>  end</p>

<p>  def update(conn, %{"user" => user_params}) do</p>
<p>    case Accounts.reset_user_password(conn.assigns.user, user_params) do</p>
<p>      {:ok, _} -></p>
<p>        conn</p>
<p>        |> put_flash(:info, "Password reset successfully.")</p>
<p>        |> redirect(to: ~p"/login")</p>

<p>      {:error, changeset} -></p>
<p>        render(conn, :edit, changeset: changeset)</p>
<p>    end</p>
<p>  end</p>

<p>  defp get_user_by_reset_password_token(conn, _opts) do</p>
<p>    %{"token" => token} = conn.params</p>

<p>    if user = Accounts.get_user_by_reset_password_token(token) do</p>
<p>      conn |> assign(:user, user) |> assign(:token, token)</p>
<p>    else</p>
<p>      conn</p>
<p>      |> put_flash(:error, "Reset password link is invalid or has expired.")</p>
<p>      |> redirect(to: ~p"/")</p>
<p>      |> halt()</p>
<p>    end</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h2>Templates</h2>

<h3>Request Reset Form</h3>

<figure class="code"><pre><code><%# File: lib/snippetbox_web/controllers/user_reset_password_html/new.html.heex %>

<div class="mx-auto max-w-md">
<p>  <.header class="text-center"></p>
<p>    Forgot your password?</p>
<p>    <:subtitle>We'll send you a link to reset it</:subtitle></p>
<p>  </.header></p>

<p>  <.form for={%{}} action={~p"/forgot-password"} as={:user} class="mt-8"></p>
<p>    <.input name="email" type="email" label="Email" required /></p>

<p>    <.button class="mt-6 w-full">Send reset instructions</.button></p>
<p>  </.form></p>

<p>  <p class="mt-4 text-center text-sm text-gray-600"></p>
<p>    <.link href={~p"/login"} class="text-brand hover:underline"></p>
<p>      Back to login</p>
<p>    </.link></p>
</p>
</div>
</code></pre></figure>

<h3>Reset Password Form</h3>

<figure class="code"><pre><code><%# File: lib/snippetbox_web/controllers/user_reset_password_html/edit.html.heex %>

<div class="mx-auto max-w-md">
<p>  <.header class="text-center"></p>
<p>    Reset Password</p>
<p>    <:subtitle>Enter your new password below</:subtitle></p>
<p>  </.header></p>

<p>  <.form for={@changeset} action={~p"/reset-password/#{@token}"} class="mt-8"></p>
<p>    <.error :if={@changeset.action}></p>
<p>      Oops, something went wrong! Please check the errors below.</p>
<p>    </.error></p>

<p>    <div class="space-y-4"></p>
<p>      <.input field={@form[:password]} type="password" label="New password" required /></p>
<p>      <.input</p>
<p>        field={@form[:password_confirmation]}</p>
<p>        type="password"</p>
<p>        label="Confirm new password"</p>
<p>        required</p>
<p>      /></p>
<p>    </div></p>

<p>    <.button class="mt-6 w-full">Reset password</.button></p>
<p>  </.form></p>
</div>
</code></pre></figure>

<h2>Router</h2>

<figure class="code"><figcaption>File: lib/snippetbox_web/router.ex</figcaption><pre><code class="language-elixir">
<p>scope "/", SnippetboxWeb do</p>
<p>  pipe_through [:browser, :redirect_if_user_is_authenticated]</p>

<p>  get "/forgot-password", UserResetPasswordController, :new</p>
<p>  post "/forgot-password", UserResetPasswordController, :create</p>
<p>  get "/reset-password/:token", UserResetPasswordController, :edit</p>
<p>  put "/reset-password/:token", UserResetPasswordController, :update</p>
<p>end</p>
</code></pre></figure>

<h2>Security Measures</h2>

<h3>Token Expiration</h3>

<figure class="code"><pre><code># Tokens expire after 24 hours
<p>@reset_password_validity_in_days 1</p>
</code></pre></figure>

<h3>One-Time Use</h3>

<figure class="code"><pre><code># Delete all tokens after password reset
<p>def reset_user_password(user, attrs) do</p>
<p>  Ecto.Multi.new()</p>
<p>  |> Ecto.Multi.update(:user, User.password_changeset(user, attrs))</p>
<p>  |> Ecto.Multi.delete_all(:tokens, UserToken.by_user_and_contexts_query(user, :all))</p>
<p>  |> Repo.transaction()</p>
<p>end</p>
</code></pre></figure>

<h3>Rate Limiting</h3>

<figure class="code"><pre><code>plug :rate_limit_reset_request when action == :create

<p>defp rate_limit_reset_request(conn, _opts) do</p>
<p>  email = conn.params["user"]["email"]</p>
<p>  key = "password_reset:#{email}"</p>

<p>  case Hammer.check_rate(key, 3600_000, 3) do  # 3 per hour</p>
<p>    {:allow, _} -> conn</p>
<p>    {:deny, _} -></p>
<p>      conn</p>
<p>      |> put_flash(:info, "If your email is in our system, you will receive instructions.")</p>
<p>      |> redirect(to: ~p"/")</p>
<p>      |> halt()</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<h3>Email Enumeration Prevention</h3>

<figure class="code"><pre><code>def create(conn, %{"user" => %{"email" => email}}) do
<p>  # Always do the lookup</p>
<p>  if user = Accounts.get_user_by_email(email) do</p>
<p>    Accounts.deliver_user_reset_password_instructions(user, &url(~p"/reset-password/#{&1}"))</p>
<p>  end</p>

<p>  # Always show same message - prevents email enumeration</p>
<p>  conn</p>
<p>  |> put_flash(:info, "If your email is in our system, you will receive instructions shortly.")</p>
<p>  |> redirect(to: ~p"/")</p>
<p>end</p>
</code></pre></figure>

<h2>Testing Password Reset</h2>

<figure class="code"><figcaption>File: test/snippetbox_web/controllers/user_reset_password_controller_test.exs</figcaption><pre><code class="language-elixir">
<p>defmodule SnippetboxWeb.UserResetPasswordControllerTest do</p>
<p>  use SnippetboxWeb.ConnCase</p>

<p>  alias Snippetbox.Accounts</p>
<p>  import Snippetbox.AccountsFixtures</p>

<p>  setup do</p>
<p>    %{user: user_fixture()}</p>
<p>  end</p>

<p>  describe "POST /forgot-password" do</p>
<p>    test "sends reset email for valid email", %{conn: conn, user: user} do</p>
<p>      conn =</p>
<p>        post(conn, ~p"/forgot-password", %{</p>
<p>          "user" => %{"email" => user.email}</p>
<p>        })</p>

<p>      assert redirected_to(conn) == ~p"/"</p>
<p>      assert Phoenix.Flash.get(conn.assigns.flash, :info) =~ "If your email"</p>
<p>      assert Repo.get_by!(UserToken, user_id: user.id)</p>
<p>    end</p>

<p>    test "does not reveal if email exists", %{conn: conn} do</p>
<p>      conn =</p>
<p>        post(conn, ~p"/forgot-password", %{</p>
<p>          "user" => %{"email" => "unknown@example.com"}</p>
<p>        })</p>

<p>      assert redirected_to(conn) == ~p"/"</p>
<p>      assert Phoenix.Flash.get(conn.assigns.flash, :info) =~ "If your email"</p>
<p>    end</p>
<p>  end</p>

<p>  describe "GET /reset-password/:token" do</p>
<p>    test "renders reset password page", %{conn: conn, user: user} do</p>
<p>      token = extract_reset_token(user)</p>
<p>      conn = get(conn, ~p"/reset-password/#{token}")</p>

<p>      assert html_response(conn, 200) =~ "Reset Password"</p>
<p>    end</p>

<p>    test "redirects for invalid token", %{conn: conn} do</p>
<p>      conn = get(conn, ~p"/reset-password/invalid")</p>

<p>      assert redirected_to(conn) == ~p"/"</p>
<p>      assert Phoenix.Flash.get(conn.assigns.flash, :error) =~ "invalid"</p>
<p>    end</p>
<p>  end</p>

<p>  describe "PUT /reset-password/:token" do</p>
<p>    test "resets password for valid token", %{conn: conn, user: user} do</p>
<p>      token = extract_reset_token(user)</p>

<p>      conn =</p>
<p>        put(conn, ~p"/reset-password/#{token}", %{</p>
<p>          "user" => %{</p>
<p>            "password" => "NewValidPass123!",</p>
<p>            "password_confirmation" => "NewValidPass123!"</p>
<p>          }</p>
<p>        })</p>

<p>      assert redirected_to(conn) == ~p"/login"</p>
<p>      assert Accounts.get_user_by_email_and_password(user.email, "NewValidPass123!")</p>
<p>    end</p>

<p>    test "invalidates token after use", %{conn: conn, user: user} do</p>
<p>      token = extract_reset_token(user)</p>

<p>      put(conn, ~p"/reset-password/#{token}", %{</p>
<p>        "user" => %{</p>
<p>          "password" => "NewValidPass123!",</p>
<p>          "password_confirmation" => "NewValidPass123!"</p>
<p>        }</p>
<p>      })</p>

<p>      # Token should no longer work</p>
<p>      conn = get(conn, ~p"/reset-password/#{token}")</p>
<p>      assert redirected_to(conn) == ~p"/"</p>
<p>    end</p>
<p>  end</p>

<p>  defp extract_reset_token(user) do</p>
<p>    {token, _} = Accounts.UserToken.build_email_token(user, "reset_password")</p>
<p>    token</p>
<p>  end</p>
<p>end</p>
</code></pre></figure>

<blockquote class="fp-concept">
<strong>FP Concept: Secure Token Design</strong>
</blockquote>
<p>></p>
<blockquote>
<p>Password reset uses a split-token pattern:</p>
</blockquote>
<p>></p>
<blockquote>
<figure class="code"><pre><code>> # Generate
<p>token = random_bytes()</p>
<p>hashed = hash(token)</p>
<p>store(hashed)</p>
<p>email(token)</p>
</blockquote>
<p>></p>
<blockquote>
<p># Verify</p>
<p>hashed = hash(submitted_token)</p>
<p>user = lookup(hashed)</p>
</code></pre></figure>
</blockquote>
<p>></p>
<blockquote>
<p>The plaintext token is never storedâ€”only the hash. Even database compromise doesn't expose valid tokens.</p>
</blockquote>

<h2>Summary</h2>

<p>In this chapter, we learned:</p>

<ul>
<li>Password reset flow architecture</li>
<li>Secure token generation and storage</li>
<li>Email delivery for reset instructions</li>
<li>Token validation and expiration</li>
<li>One-time use token enforcement</li>
<li>Rate limiting and enumeration prevention</li>
<li>Testing password reset</li>
</ul>

<p>In the next chapter, we'll implement email verification.</p>

    </main>
    <footer>
        <div class="wrapper">
            <div>
                &lsaquo; <a href="11.04-remember-me.html">Previous</a>
            </div>
            <div>
                <a href="00.01-contents.html">Contents</a>
            </div>
            <div>
                <a href="11.06-email-verification.html">Next</a> &rsaquo;
            </div>
        </div>
    </footer>
</body>
</html>
