# Chapter 2.9: The Controller Pattern

Controllers are the heart of request handling in Phoenix. In this chapter, we'll explore the controller pattern in depth, understanding how to organize controller code effectively.

## What is a Controller?

A controller is a module that receives HTTP requests, processes them, and returns responses. It acts as the coordinator between:

- **Router** - Determines which controller handles a request
- **Context** - Business logic and data access
- **View/Template** - Response rendering

```
Request → Router → Controller → Context → Controller → View → Response
```

## Anatomy of a Controller

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

defmodule SnippetboxWeb.SnippetController do
  use SnippetboxWeb, :controller

  alias Snippetbox.Snippets
  alias Snippetbox.Snippets.Snippet

  def index(conn, _params) do
    snippets = Snippets.list_snippets()
    render(conn, :index, snippets: snippets)
  end

  def show(conn, %{"id" => id}) do
    snippet = Snippets.get_snippet!(id)
    render(conn, :show, snippet: snippet)
  end

  def new(conn, _params) do
    changeset = Snippets.change_snippet(%Snippet{})
    render(conn, :new, changeset: changeset)
  end

  def create(conn, %{"snippet" => snippet_params}) do
    case Snippets.create_snippet(snippet_params) do
      {:ok, snippet} ->
        conn
        |> put_flash(:info, "Snippet created successfully.")
        |> redirect(to: ~p"/snippets/#{snippet}")

      {:error, %Ecto.Changeset{} = changeset} ->
        render(conn, :new, changeset: changeset)
    end
  end

  def edit(conn, %{"id" => id}) do
    snippet = Snippets.get_snippet!(id)
    changeset = Snippets.change_snippet(snippet)
    render(conn, :edit, snippet: snippet, changeset: changeset)
  end

  def update(conn, %{"id" => id, "snippet" => snippet_params}) do
    snippet = Snippets.get_snippet!(id)

    case Snippets.update_snippet(snippet, snippet_params) do
      {:ok, snippet} ->
        conn
        |> put_flash(:info, "Snippet updated successfully.")
        |> redirect(to: ~p"/snippets/#{snippet}")

      {:error, %Ecto.Changeset{} = changeset} ->
        render(conn, :edit, snippet: snippet, changeset: changeset)
    end
  end

  def delete(conn, %{"id" => id}) do
    snippet = Snippets.get_snippet!(id)
    {:ok, _snippet} = Snippets.delete_snippet(snippet)

    conn
    |> put_flash(:info, "Snippet deleted successfully.")
    |> redirect(to: ~p"/snippets")
  end
end
```

## The Connection Struct

Every controller action receives a `conn` (Plug.Conn) struct containing:

```elixir
%Plug.Conn{
  # Request information
  host: "localhost",
  port: 4000,
  method: "GET",
  path_info: ["snippets", "123"],
  query_string: "page=1",
  request_path: "/snippets/123",

  # Headers
  req_headers: [{"accept", "text/html"}, ...],
  resp_headers: [{"cache-control", "max-age=0"}, ...],

  # Parameters (merged from all sources)
  params: %{"id" => "123", "page" => "1"},
  path_params: %{"id" => "123"},
  query_params: %{"page" => "1"},
  body_params: %{},

  # Assigns (data you set)
  assigns: %{},

  # State
  state: :unset,  # :unset, :set, :chunked, :sent
  status: nil,
  resp_body: nil,

  # Phoenix-specific
  private: %{
    phoenix_controller: SnippetboxWeb.SnippetController,
    phoenix_action: :show,
    phoenix_format: "html",
    ...
  }
}
```

## Controller Actions

Actions are functions that:
1. Take `conn` and `params` as arguments
2. Return a modified `conn` (or raise an exception)

### Action Parameters

```elixir
# All params merged together
def show(conn, params) do
  IO.inspect(params)
  # %{"id" => "123", "page" => "1", "format" => "html"}
end

# Pattern match specific params
def show(conn, %{"id" => id}) do
  # id = "123"
end

# Ignore params you don't need
def index(conn, _params) do
  # ...
end
```

## Response Types

### Rendering HTML

```elixir
def show(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)
  render(conn, :show, snippet: snippet)
end
```

The `render/3` function:
1. Looks up the view module (`SnippetHTML`)
2. Calls the template function (`:show`)
3. Passes assigns (`snippet: snippet`)
4. Sets response body and content-type

### Rendering JSON

```elixir
def show(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)
  json(conn, %{
    id: snippet.id,
    title: snippet.title,
    content: snippet.content
  })
end
```

### Plain Text

```elixir
def health(conn, _params) do
  text(conn, "OK")
end
```

### Sending Raw Response

```elixir
def custom(conn, _params) do
  conn
  |> put_resp_content_type("text/csv")
  |> send_resp(200, "id,name\n1,Alice\n2,Bob")
end
```

### Redirects

```elixir
def create(conn, params) do
  # Internal redirect
  redirect(conn, to: ~p"/snippets/123")

  # External redirect
  redirect(conn, external: "https://example.com")
end
```

### No Content

```elixir
def delete(conn, %{"id" => id}) do
  Snippets.delete_snippet!(id)
  send_resp(conn, :no_content, "")
end
```

## Flash Messages

Flash messages persist across redirects:

```elixir
def create(conn, params) do
  case Snippets.create_snippet(params) do
    {:ok, snippet} ->
      conn
      |> put_flash(:info, "Snippet created!")
      |> redirect(to: ~p"/snippets/#{snippet}")

    {:error, changeset} ->
      conn
      |> put_flash(:error, "Failed to create snippet.")
      |> render(:new, changeset: changeset)
  end
end
```

Flash types:
- `:info` - Success/information messages
- `:error` - Error messages

Display in templates:

```heex
<%= if info = Phoenix.Flash.get(@flash, :info) do %>
  <div class="flash flash-info"><%= info %></div>
<% end %>

<%= if error = Phoenix.Flash.get(@flash, :error) do %>
  <div class="flash flash-error"><%= error %></div>
<% end %>
```

## Action Plugs

Run code before or around specific actions:

```elixir
defmodule SnippetboxWeb.SnippetController do
  use SnippetboxWeb, :controller

  # Run for all actions
  plug :set_layout

  # Run for specific actions
  plug :require_auth when action in [:new, :create, :edit, :update, :delete]

  # Run for all except some
  plug :track_view when action not in [:new, :create]

  def index(conn, _params) do
    # ...
  end

  # Plug implementations
  defp set_layout(conn, _opts) do
    put_layout(conn, html: :snippets)
  end

  defp require_auth(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
    else
      conn
      |> put_flash(:error, "You must be logged in.")
      |> redirect(to: ~p"/login")
      |> halt()  # Important! Stop the pipeline
    end
  end

  defp track_view(conn, _opts) do
    # Analytics tracking
    conn
  end
end
```

## Error Handling

### Using Bang Functions

Bang functions (`!`) raise exceptions on failure:

```elixir
def show(conn, %{"id" => id}) do
  # Raises Ecto.NoResultsError if not found
  snippet = Snippets.get_snippet!(id)
  render(conn, :show, snippet: snippet)
end
```

Phoenix converts `Ecto.NoResultsError` to a 404 response automatically.

### Explicit Error Handling

```elixir
def show(conn, %{"id" => id}) do
  case Snippets.get_snippet(id) do
    nil ->
      conn
      |> put_status(:not_found)
      |> put_view(SnippetboxWeb.ErrorHTML)
      |> render(:"404")

    snippet ->
      render(conn, :show, snippet: snippet)
  end
end
```

### With Pattern

```elixir
def create(conn, %{"snippet" => params}) do
  with {:ok, snippet} <- Snippets.create_snippet(params),
       {:ok, _} <- notify_subscribers(snippet) do
    conn
    |> put_flash(:info, "Created!")
    |> redirect(to: ~p"/snippets/#{snippet}")
  else
    {:error, %Ecto.Changeset{} = changeset} ->
      render(conn, :new, changeset: changeset)

    {:error, :notification_failed} ->
      conn
      |> put_flash(:warning, "Created but notification failed")
      |> redirect(to: ~p"/snippets/#{snippet}")
  end
end
```

## Organizing Large Controllers

### Extract Helper Functions

```elixir
defmodule SnippetboxWeb.SnippetController do
  use SnippetboxWeb, :controller

  def index(conn, params) do
    {snippets, pagination} = fetch_snippets(params)
    render(conn, :index, snippets: snippets, pagination: pagination)
  end

  # Private helpers
  defp fetch_snippets(params) do
    page = parse_page(params)
    per_page = parse_per_page(params)
    sort = parse_sort(params)

    Snippets.list_snippets(page: page, per_page: per_page, sort: sort)
  end

  defp parse_page(%{"page" => page}) when is_binary(page) do
    case Integer.parse(page) do
      {n, ""} when n > 0 -> n
      _ -> 1
    end
  end
  defp parse_page(_), do: 1

  defp parse_per_page(%{"per_page" => per_page}) when is_binary(per_page) do
    case Integer.parse(per_page) do
      {n, ""} when n in 1..100 -> n
      _ -> 20
    end
  end
  defp parse_per_page(_), do: 20

  defp parse_sort(%{"sort" => sort}) when sort in ~w(newest oldest popular) do
    String.to_existing_atom(sort)
  end
  defp parse_sort(_), do: :newest
end
```

### Separate Concerns into Contexts

Keep controllers thin, move logic to contexts:

```elixir
# Bad: Business logic in controller
def create(conn, %{"snippet" => params}) do
  params = Map.put(params, "user_id", conn.assigns.current_user.id)
  expires_at = DateTime.add(DateTime.utc_now(), params["duration"] * 86400)
  params = Map.put(params, "expires_at", expires_at)
  # ... more logic
end

# Good: Delegate to context
def create(conn, %{"snippet" => params}) do
  user = conn.assigns.current_user
  case Snippets.create_snippet(user, params) do
    {:ok, snippet} -> redirect(conn, to: ~p"/snippets/#{snippet}")
    {:error, changeset} -> render(conn, :new, changeset: changeset)
  end
end
```

### Split into Multiple Controllers

If a controller grows too large, split by resource or feature:

```
controllers/
├── snippet_controller.ex      # CRUD actions
├── snippet_export_controller.ex   # Export features
└── snippet_share_controller.ex    # Sharing features
```

## Controller Testing

```elixir
# File: test/snippetbox_web/controllers/snippet_controller_test.exs

defmodule SnippetboxWeb.SnippetControllerTest do
  use SnippetboxWeb.ConnCase

  alias Snippetbox.Snippets

  describe "index" do
    test "lists all snippets", %{conn: conn} do
      conn = get(conn, ~p"/snippets")
      assert html_response(conn, 200) =~ "Snippets"
    end
  end

  describe "show" do
    test "shows snippet", %{conn: conn} do
      snippet = snippet_fixture()
      conn = get(conn, ~p"/snippets/#{snippet}")
      assert html_response(conn, 200) =~ snippet.title
    end

    test "returns 404 for non-existent snippet", %{conn: conn} do
      assert_error_sent 404, fn ->
        get(conn, ~p"/snippets/999999")
      end
    end
  end

  describe "create" do
    test "creates snippet with valid data", %{conn: conn} do
      params = %{title: "Test", content: "Hello"}
      conn = post(conn, ~p"/snippets", snippet: params)

      assert %{id: id} = redirected_params(conn)
      assert redirected_to(conn) == ~p"/snippets/#{id}"
    end

    test "returns errors with invalid data", %{conn: conn} do
      params = %{title: "", content: ""}
      conn = post(conn, ~p"/snippets", snippet: params)
      assert html_response(conn, 200) =~ "can&#39;t be blank"
    end
  end
end
```

## Best Practices

### 1. Keep Actions Simple

Each action should do one thing:

```elixir
# Good: Simple, focused action
def show(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)
  render(conn, :show, snippet: snippet)
end

# Bad: Doing too much
def show(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)
  Snippets.increment_view_count(snippet)
  related = Snippets.find_related(snippet)
  comments = Comments.for_snippet(snippet)
  user = Accounts.get_user(snippet.user_id)
  render(conn, :show, snippet: snippet, related: related,
         comments: comments, author: user)
end
```

### 2. Use Pattern Matching

```elixir
# Pattern match in function heads
def show(conn, %{"id" => id, "format" => "json"}) do
  snippet = Snippets.get_snippet!(id)
  json(conn, snippet)
end

def show(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)
  render(conn, :show, snippet: snippet)
end
```

### 3. Handle Errors Gracefully

```elixir
def create(conn, %{"snippet" => params}) do
  case Snippets.create_snippet(params) do
    {:ok, snippet} ->
      conn
      |> put_flash(:info, "Created successfully!")
      |> redirect(to: ~p"/snippets/#{snippet}")

    {:error, changeset} ->
      conn
      |> put_status(:unprocessable_entity)
      |> render(:new, changeset: changeset)
  end
end
```

### 4. Validate Early

```elixir
plug :validate_id when action in [:show, :edit, :update, :delete]

defp validate_id(conn, _opts) do
  case Integer.parse(conn.params["id"]) do
    {id, ""} when id > 0 ->
      assign(conn, :snippet_id, id)
    _ ->
      conn
      |> put_status(:bad_request)
      |> text("Invalid ID")
      |> halt()
  end
end
```

> **FP Concept: The Conn Pipeline**
>
> Phoenix controllers embrace the pipeline pattern:
>
> ```elixir
> conn
> |> put_status(:created)
> |> put_resp_header("location", ~p"/snippets/#{snippet}")
> |> put_flash(:info, "Created!")
> |> redirect(to: ~p"/snippets/#{snippet}")
> ```
>
> Each function transforms `conn` and returns a new `conn`. This is:
> - **Composable**: Easy to add/remove/reorder steps
> - **Testable**: Each step is a pure function
> - **Traceable**: Data flow is explicit
>
> Compare to imperative style:
> ```python
> # Imperative (mutations)
> response.status = 201
> response.headers["Location"] = url
> flash["info"] = "Created!"
> return redirect(url)
> ```
>
> **Further Reading**:
> - [Plug.Conn Documentation](https://hexdocs.pm/plug/Plug.Conn.html)
> - [Phoenix Controller Guide](https://hexdocs.pm/phoenix/controllers.html)

## Summary

In this chapter, we learned:

- Controller structure and the Plug.Conn struct
- Different response types (HTML, JSON, text, redirects)
- Flash messages for user feedback
- Action plugs for cross-cutting concerns
- Error handling strategies
- Best practices for organizing controller code

This completes the Foundations chapter. In the next chapter, we'll explore Configuration and Error Handling.

---

## Additional Information

### RESTful Actions Convention

Phoenix follows RESTful conventions:

| Action | HTTP Method | Path | Purpose |
|--------|-------------|------|---------|
| index | GET | /snippets | List all |
| show | GET | /snippets/:id | Show one |
| new | GET | /snippets/new | New form |
| create | POST | /snippets | Create |
| edit | GET | /snippets/:id/edit | Edit form |
| update | PUT/PATCH | /snippets/:id | Update |
| delete | DELETE | /snippets/:id | Delete |

### Comparing to Other Frameworks

**Rails Controller**:
```ruby
class SnippetsController < ApplicationController
  def show
    @snippet = Snippet.find(params[:id])
  end
end
```

**Django View**:
```python
def show(request, id):
    snippet = get_object_or_404(Snippet, pk=id)
    return render(request, 'show.html', {'snippet': snippet})
```

**Express Handler**:
```javascript
app.get('/snippets/:id', (req, res) => {
  const snippet = Snippet.find(req.params.id);
  res.render('show', { snippet });
});
```

**Phoenix Controller**:
```elixir
def show(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)
  render(conn, :show, snippet: snippet)
end
```

Phoenix is explicit about both parameters and response - no magic instance variables or implicit rendering.
