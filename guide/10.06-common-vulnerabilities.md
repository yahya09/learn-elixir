# Chapter 10.6: Common Vulnerabilities

Beyond the specific attacks we've covered, there are many other vulnerabilities to be aware of. In this chapter, we'll explore common security issues and how to prevent them.

## OWASP Top 10

The Open Web Application Security Project maintains a list of critical vulnerabilities:

| Rank | Vulnerability | Phoenix Mitigation |
|------|--------------|-------------------|
| 1 | Broken Access Control | Authorization plugs |
| 2 | Cryptographic Failures | Phoenix secrets, Argon2 |
| 3 | Injection | Ecto parameterized queries |
| 4 | Insecure Design | Contexts, proper architecture |
| 5 | Security Misconfiguration | Config management |
| 6 | Vulnerable Components | Mix deps audit |
| 7 | Auth Failures | phx.gen.auth |
| 8 | Software/Data Integrity | Signed cookies, CSRF |
| 9 | Logging Failures | Logger, audit trails |
| 10 | SSRF | URL validation |

## Broken Access Control

### The Problem

Users accessing resources they shouldn't:

```elixir
# VULNERABLE - No authorization check
def show(conn, %{"id" => id}) do
  snippet = Repo.get!(Snippet, id)
  render(conn, :show, snippet: snippet)
end
```

### The Solution

```elixir
# SECURE - Check ownership
def show(conn, %{"id" => id}) do
  user = conn.assigns.current_user
  snippet = Snippets.get_user_snippet!(user, id)
  render(conn, :show, snippet: snippet)
end

# In context
def get_user_snippet!(user, id) do
  Snippet
  |> where([s], s.user_id == ^user.id)
  |> Repo.get!(id)
end
```

### Authorization Plug

```elixir
defmodule SnippetboxWeb.Plugs.Authorize do
  import Plug.Conn
  import Phoenix.Controller

  def authorize_snippet(conn, _opts) do
    snippet_id = conn.params["id"]
    user = conn.assigns.current_user

    case Snippets.get_snippet(snippet_id) do
      nil ->
        not_found(conn)

      %{user_id: user_id} when user_id == user.id ->
        conn

      %{public: true} when conn.method == "GET" ->
        conn

      _snippet ->
        forbidden(conn)
    end
  end

  defp not_found(conn) do
    conn
    |> put_status(:not_found)
    |> put_view(SnippetboxWeb.ErrorHTML)
    |> render("404.html")
    |> halt()
  end

  defp forbidden(conn) do
    conn
    |> put_status(:forbidden)
    |> put_view(SnippetboxWeb.ErrorHTML)
    |> render("403.html")
    |> halt()
  end
end
```

## Insecure Direct Object References (IDOR)

### The Problem

```elixir
# User can access any user's profile by changing ID
# GET /users/123/profile
def profile(conn, %{"id" => id}) do
  user = Accounts.get_user!(id)  # No auth check!
  render(conn, :profile, user: user)
end
```

### Solutions

```elixir
# Option 1: Only allow viewing own profile
def profile(conn, _params) do
  user = conn.assigns.current_user
  render(conn, :profile, user: user)
end

# Option 2: Check authorization
def profile(conn, %{"id" => id}) do
  current_user = conn.assigns.current_user

  if to_string(current_user.id) == id || current_user.admin? do
    user = Accounts.get_user!(id)
    render(conn, :profile, user: user)
  else
    forbidden(conn)
  end
end

# Option 3: Use UUIDs instead of sequential IDs
# Makes enumeration harder (but doesn't replace auth!)
```

## Mass Assignment

### The Problem

```elixir
# User can set any field
def update(conn, %{"user" => user_params}) do
  user = conn.assigns.current_user
  Accounts.update_user(user, user_params)
  # User could pass: %{"role" => "admin"}
end
```

### The Solution

```elixir
# Changeset only allows specific fields
def profile_changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :email, :bio])  # role not included
  |> validate_required([:name, :email])
end

# Different changesets for different contexts
def admin_changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :email, :role, :active])
  |> validate_inclusion(:role, [:user, :moderator, :admin])
end
```

## Open Redirects

### The Problem

```elixir
# VULNERABLE - Attacker can redirect to phishing site
def callback(conn, %{"return_to" => return_to}) do
  redirect(conn, external: return_to)
end
```

### The Solution

```elixir
def callback(conn, %{"return_to" => return_to}) do
  if safe_redirect?(return_to) do
    redirect(conn, to: return_to)
  else
    redirect(conn, to: ~p"/")
  end
end

defp safe_redirect?(nil), do: false
defp safe_redirect?(path) do
  # Only allow relative paths
  String.starts_with?(path, "/") &&
    not String.starts_with?(path, "//") &&
    not String.contains?(path, "://")
end

# Or use signed tokens
def login(conn, _params) do
  return_to = get_session(conn, :return_to) || ~p"/"
  token = Phoenix.Token.sign(conn, "return_to", return_to)
  render(conn, :new, return_token: token)
end

def create(conn, %{"return_token" => token}) do
  case Phoenix.Token.verify(conn, "return_to", token, max_age: 3600) do
    {:ok, return_to} -> redirect(conn, to: return_to)
    {:error, _} -> redirect(conn, to: ~p"/")
  end
end
```

## Server-Side Request Forgery (SSRF)

### The Problem

```elixir
# VULNERABLE - User controls URL
def fetch_url(conn, %{"url" => url}) do
  {:ok, response} = HTTPoison.get(url)
  render(conn, :preview, content: response.body)
end
# Attacker: url=http://169.254.169.254/latest/meta-data/
# Exposes AWS metadata!
```

### The Solution

```elixir
def fetch_url(conn, %{"url" => url}) do
  with {:ok, validated_url} <- validate_url(url),
       {:ok, response} <- HTTPoison.get(validated_url, [], timeout: 5000) do
    render(conn, :preview, content: response.body)
  else
    {:error, reason} ->
      render(conn, :error, message: "Could not fetch URL")
  end
end

defp validate_url(url) do
  uri = URI.parse(url)

  cond do
    uri.scheme not in ["http", "https"] ->
      {:error, :invalid_scheme}

    private_ip?(uri.host) ->
      {:error, :private_ip}

    blocked_host?(uri.host) ->
      {:error, :blocked_host}

    true ->
      {:ok, url}
  end
end

defp private_ip?(host) do
  case :inet.parse_address(to_charlist(host)) do
    {:ok, ip} -> private_ip_address?(ip)
    _ -> false  # Hostname, could resolve to private IP
  end
end

defp private_ip_address?({10, _, _, _}), do: true
defp private_ip_address?({172, b, _, _}) when b >= 16 and b <= 31, do: true
defp private_ip_address?({192, 168, _, _}), do: true
defp private_ip_address?({127, _, _, _}), do: true
defp private_ip_address?({169, 254, _, _}), do: true  # Link-local
defp private_ip_address?(_), do: false

defp blocked_host?(host) do
  host in ["localhost", "metadata.google.internal", "169.254.169.254"]
end
```

## Timing Attacks

### The Problem

```elixir
# VULNERABLE - Timing leak in comparison
def verify_token(submitted, actual) do
  submitted == actual  # Short-circuits on first difference
end
```

### The Solution

```elixir
# Constant-time comparison
def verify_token(submitted, actual) do
  Plug.Crypto.secure_compare(submitted, actual)
end

# For password verification, use library
def verify_password(password, hash) do
  Argon2.verify_pass(password, hash)
  # or Bcrypt.verify_pass/2
end
```

## Information Disclosure

### Error Messages

```elixir
# VULNERABLE - Leaks information
def login(conn, %{"email" => email, "password" => password}) do
  case Accounts.authenticate(email, password) do
    {:error, :user_not_found} ->
      put_flash(conn, :error, "No user with that email")
    {:error, :invalid_password} ->
      put_flash(conn, :error, "Wrong password")
  end
end

# SECURE - Generic message
def login(conn, %{"email" => email, "password" => password}) do
  case Accounts.authenticate(email, password) do
    {:ok, user} ->
      # Success
    {:error, _reason} ->
      put_flash(conn, :error, "Invalid email or password")
  end
end
```

### Debug Information

```elixir
# config/prod.exs
config :snippetbox, SnippetboxWeb.Endpoint,
  debug_errors: false  # Don't show stack traces

config :phoenix, :stacktrace_depth, 0
```

### Logs

```elixir
# Don't log sensitive data
Logger.info("User #{user.id} logged in")  # Good
Logger.info("User logged in with password #{password}")  # BAD!

# Filter sensitive params
# config/config.exs
config :phoenix, :filter_parameters, [
  "password",
  "password_confirmation",
  "credit_card",
  "ssn",
  "token"
]
```

## Denial of Service

### Resource Exhaustion

```elixir
# VULNERABLE - Unbounded query
def search(conn, %{"q" => query}) do
  results = Repo.all(from s in Snippet, where: ilike(s.content, ^"%#{query}%"))
  render(conn, :results, snippets: results)
end

# SECURE - Limit results
def search(conn, %{"q" => query, "page" => page}) do
  results =
    Snippet
    |> where([s], ilike(s.content, ^"%#{query}%"))
    |> limit(20)
    |> offset(^((page - 1) * 20))
    |> Repo.all()

  render(conn, :results, snippets: results)
end
```

### Rate Limiting

```elixir
# In router
plug SnippetboxWeb.Plugs.RateLimit, limit: 100, window: 60_000

# For specific actions
plug :rate_limit_login when action == :create
```

### Request Size Limits

```elixir
# File: lib/snippetbox_web/endpoint.ex

plug Plug.Parsers,
  parsers: [:urlencoded, :multipart, :json],
  pass: ["*/*"],
  json_decoder: Phoenix.json_library(),
  length: 8_000_000,  # 8MB max
  read_length: 1_000_000,  # 1MB chunks
  read_timeout: 15_000  # 15 seconds
```

## Dependency Vulnerabilities

### Audit Dependencies

```bash
# Check for known vulnerabilities
mix deps.audit

# Update dependencies
mix deps.update --all

# Check outdated packages
mix hex.outdated
```

### Lock File

```elixir
# Always commit mix.lock
# Ensures consistent versions across environments
```

## Security Testing

### Automated Scanning

```elixir
# mix.exs
defp deps do
  [
    {:sobelow, "~> 0.12", only: [:dev, :test], runtime: false}
  ]
end

# Run security scan
# mix sobelow
```

### Manual Testing Checklist

- [ ] Try accessing resources without authentication
- [ ] Try accessing other users' resources
- [ ] Submit malformed/malicious input
- [ ] Test all input fields for injection
- [ ] Check for sensitive data in responses
- [ ] Verify rate limiting works
- [ ] Test session handling (logout, expiry)
- [ ] Check error messages for info leaks

> **FP Concept: Defense Through Types**
>
> Elixir's type system and pattern matching help prevent vulnerabilities:
>
> ```elixir
> # Pattern matching ensures expected structure
> def process(%{"type" => "transfer", "amount" => amount})
>     when is_integer(amount) and amount > 0 do
>   # Only processes valid transfers
> end
>
> # Invalid data doesn't match
> def process(_invalid), do: {:error, :invalid_request}
> ```
>
> This "parse, don't validate" approach catches issues at the boundary.

## Summary

In this chapter, we learned:

- OWASP Top 10 vulnerabilities
- Broken access control prevention
- IDOR and mass assignment
- Open redirect protection
- SSRF prevention
- Timing attack mitigation
- Information disclosure prevention
- DoS protection
- Dependency security
- Security testing approaches

This completes the Security chapter. In the next chapter, we'll explore authentication in Phoenix.
