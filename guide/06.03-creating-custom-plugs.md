# Chapter 6.3: Creating Custom Plugs

Custom plugs let you implement reusable request processing logic. In this chapter, we'll create both function and module plugs for common scenarios.

## Function Plugs

Simple plugs can be functions:

```elixir
# In router or controller
plug :my_plug

def my_plug(conn, _opts) do
  # Transform conn
  conn
end
```

### When to Use Function Plugs

- Simple transformations
- Controller-specific logic
- No configuration needed
- Quick implementations

## Module Plugs

For more complex plugs, use a module:

```elixir
defmodule MyPlug do
  @behaviour Plug

  @impl true
  def init(opts) do
    # Called at compile time
    opts
  end

  @impl true
  def call(conn, opts) do
    # Called at runtime
    conn
  end
end
```

### When to Use Module Plugs

- Reusable across multiple routers/controllers
- Configuration options needed
- Complex logic
- State or caching required

## Creating Plugs: Examples

### Request Logger

```elixir
# File: lib/snippetbox_web/plugs/request_logger.ex

defmodule SnippetboxWeb.Plugs.RequestLogger do
  @behaviour Plug
  require Logger

  @impl true
  def init(opts) do
    level = Keyword.get(opts, :level, :info)
    %{level: level}
  end

  @impl true
  def call(conn, %{level: level}) do
    start = System.monotonic_time()

    Plug.Conn.register_before_send(conn, fn conn ->
      stop = System.monotonic_time()
      diff = System.convert_time_unit(stop - start, :native, :millisecond)

      Logger.log(level, fn ->
        "#{conn.method} #{conn.request_path} - #{conn.status} in #{diff}ms"
      end)

      conn
    end)
  end
end
```

Usage:

```elixir
plug SnippetboxWeb.Plugs.RequestLogger, level: :debug
```

### Locale Plug

```elixir
# File: lib/snippetbox_web/plugs/locale.ex

defmodule SnippetboxWeb.Plugs.Locale do
  @behaviour Plug
  import Plug.Conn

  @locales ~w(en es fr de ja)
  @default_locale "en"

  @impl true
  def init(opts) do
    Keyword.get(opts, :default, @default_locale)
  end

  @impl true
  def call(conn, default) do
    locale = fetch_locale(conn, default)
    Gettext.put_locale(SnippetboxWeb.Gettext, locale)
    assign(conn, :locale, locale)
  end

  defp fetch_locale(conn, default) do
    # Check query param first
    conn.params["locale"]
    # Then session
    |> check_or(&get_session(conn, :locale))
    # Then Accept-Language header
    |> check_or(&parse_accept_language(conn))
    # Default
    |> check_or(fn -> default end)
    # Validate
    |> validate_locale(default)
  end

  defp check_or(nil, func), do: func.()
  defp check_or(value, _), do: value

  defp parse_accept_language(conn) do
    case get_req_header(conn, "accept-language") do
      [header | _] -> header |> String.split(",") |> hd() |> String.slice(0, 2)
      _ -> nil
    end
  end

  defp validate_locale(locale, default) do
    if locale in @locales, do: locale, else: default
  end
end
```

### CORS Plug

```elixir
# File: lib/snippetbox_web/plugs/cors.ex

defmodule SnippetboxWeb.Plugs.CORS do
  @behaviour Plug
  import Plug.Conn

  @impl true
  def init(opts) do
    %{
      origins: Keyword.get(opts, :origins, ["*"]),
      methods: Keyword.get(opts, :methods, ["GET", "POST", "PUT", "DELETE"]),
      headers: Keyword.get(opts, :headers, ["content-type", "authorization"])
    }
  end

  @impl true
  def call(conn, opts) do
    origin = get_origin(conn)

    if allowed_origin?(origin, opts.origins) do
      conn
      |> put_resp_header("access-control-allow-origin", origin)
      |> put_resp_header("access-control-allow-methods", Enum.join(opts.methods, ", "))
      |> put_resp_header("access-control-allow-headers", Enum.join(opts.headers, ", "))
      |> handle_preflight()
    else
      conn
    end
  end

  defp get_origin(conn) do
    case get_req_header(conn, "origin") do
      [origin | _] -> origin
      _ -> "*"
    end
  end

  defp allowed_origin?(origin, ["*"]), do: true
  defp allowed_origin?(origin, origins), do: origin in origins

  defp handle_preflight(%{method: "OPTIONS"} = conn) do
    conn
    |> put_resp_header("access-control-max-age", "86400")
    |> send_resp(204, "")
    |> halt()
  end

  defp handle_preflight(conn), do: conn
end
```

### Rate Limiter Plug

```elixir
# File: lib/snippetbox_web/plugs/rate_limiter.ex

defmodule SnippetboxWeb.Plugs.RateLimiter do
  @behaviour Plug
  import Plug.Conn
  import Phoenix.Controller

  @impl true
  def init(opts) do
    %{
      max_requests: Keyword.get(opts, :max_requests, 100),
      window_ms: Keyword.get(opts, :window_ms, 60_000),
      by: Keyword.get(opts, :by, :ip)
    }
  end

  @impl true
  def call(conn, opts) do
    key = rate_limit_key(conn, opts.by)

    case check_rate_limit(key, opts.max_requests, opts.window_ms) do
      {:ok, count} ->
        conn
        |> put_resp_header("x-ratelimit-limit", to_string(opts.max_requests))
        |> put_resp_header("x-ratelimit-remaining", to_string(opts.max_requests - count))

      {:error, :rate_limited} ->
        conn
        |> put_status(:too_many_requests)
        |> put_resp_header("retry-after", to_string(div(opts.window_ms, 1000)))
        |> json(%{error: "Rate limit exceeded"})
        |> halt()
    end
  end

  defp rate_limit_key(conn, :ip), do: "rate_limit:#{:inet.ntoa(conn.remote_ip)}"
  defp rate_limit_key(conn, :user) do
    user_id = conn.assigns[:current_user]&.id || "anon"
    "rate_limit:user:#{user_id}"
  end

  defp check_rate_limit(key, max_requests, window_ms) do
    # Simple in-memory implementation (use Redis in production)
    count = :ets.update_counter(:rate_limits, key, {2, 1}, {key, 0, now()})

    if count > max_requests do
      {:error, :rate_limited}
    else
      {:ok, count}
    end
  end

  defp now, do: System.system_time(:millisecond)
end
```

### Maintenance Mode Plug

```elixir
# File: lib/snippetbox_web/plugs/maintenance.ex

defmodule SnippetboxWeb.Plugs.Maintenance do
  @behaviour Plug
  import Plug.Conn
  import Phoenix.Controller

  @impl true
  def init(opts) do
    %{
      enabled: Keyword.get(opts, :enabled, false),
      allowed_ips: Keyword.get(opts, :allowed_ips, []),
      message: Keyword.get(opts, :message, "We're performing maintenance. Please try again later.")
    }
  end

  @impl true
  def call(conn, %{enabled: false}), do: conn

  def call(conn, opts) do
    if allowed?(conn, opts) do
      conn
    else
      conn
      |> put_status(:service_unavailable)
      |> put_view(SnippetboxWeb.ErrorHTML)
      |> render("503.html", message: opts.message)
      |> halt()
    end
  end

  defp allowed?(conn, %{allowed_ips: ips}) do
    ip = to_string(:inet.ntoa(conn.remote_ip))
    ip in ips
  end
end
```

### Response Timer Header

```elixir
# File: lib/snippetbox_web/plugs/response_time.ex

defmodule SnippetboxWeb.Plugs.ResponseTime do
  @behaviour Plug
  import Plug.Conn

  @impl true
  def init(opts), do: Keyword.get(opts, :header, "x-response-time")

  @impl true
  def call(conn, header) do
    start = System.monotonic_time()

    register_before_send(conn, fn conn ->
      stop = System.monotonic_time()
      diff = System.convert_time_unit(stop - start, :native, :millisecond)
      put_resp_header(conn, header, "#{diff}ms")
    end)
  end
end
```

## Controller Plugs

Add plugs to specific controllers:

```elixir
defmodule SnippetboxWeb.SnippetController do
  use SnippetboxWeb, :controller

  # Run for all actions
  plug :set_snippet when action in [:show, :edit, :update, :delete]

  # Run before specific actions
  plug :require_owner when action in [:edit, :update, :delete]

  def show(conn, _params) do
    # @snippet already set by plug
    render(conn, :show, snippet: conn.assigns.snippet)
  end

  def edit(conn, _params) do
    changeset = Snippets.change_snippet(conn.assigns.snippet)
    render(conn, :edit, changeset: changeset)
  end

  # Plug implementations
  defp set_snippet(conn, _opts) do
    snippet = Snippets.get_snippet!(conn.params["id"])
    assign(conn, :snippet, snippet)
  end

  defp require_owner(conn, _opts) do
    if conn.assigns.snippet.user_id == conn.assigns.current_user.id do
      conn
    else
      conn
      |> put_flash(:error, "You can only edit your own snippets.")
      |> redirect(to: ~p"/snippets")
      |> halt()
    end
  end
end
```

> **FP Concept: Plugs as Middleware**
>
> Plugs follow the middleware pattern in functional style:
>
> ```
> request → plug₁ → plug₂ → plug₃ → handler → response
> ```
>
> Each plug is a pure transformation:
> ```elixir
> plug(conn, opts) → conn'
> ```
>
> This creates a pipeline of transformations, where each step:
> - Has no side effects (except the conn transformation)
> - Is independently testable
> - Can be reordered or removed easily
>
> **Further Reading**:
> - [Plug Documentation](https://hexdocs.pm/plug/readme.html)

## Summary

In this chapter, we created:

- Request logger plug
- Locale plug
- CORS plug
- Rate limiter plug
- Maintenance mode plug
- Response timer plug
- Controller-specific plugs

In the next chapter, we'll explore more common plug patterns.
