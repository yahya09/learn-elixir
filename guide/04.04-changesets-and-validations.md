# Chapter 4.4: Changesets and Validations

Changesets are Ecto's mechanism for tracking and validating changes to data. In this chapter, we'll learn how to use changesets to ensure data integrity before it reaches the database.

## What is a Changeset?

A changeset:

1. **Tracks** changes to a schema struct
2. **Casts** external data to proper types
3. **Validates** data against rules
4. **Accumulates** errors for display
5. **Prepares** data for database operations

```elixir
changeset = Snippet.changeset(%Snippet{}, %{title: "Hello", content: "World"})
# => %Ecto.Changeset{
#      valid?: true,
#      changes: %{title: "Hello", content: "World"},
#      errors: []
#    }
```

## Creating Changesets

### Basic Changeset

```elixir
defmodule Snippetbox.Snippets.Snippet do
  use Ecto.Schema
  import Ecto.Changeset

  schema "snippets" do
    field :title, :string
    field :content, :string
    timestamps()
  end

  def changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content])
    |> validate_required([:title, :content])
  end
end
```

### Using Changesets

```elixir
alias Snippetbox.Snippets.Snippet

# Create changeset from empty struct
changeset = Snippet.changeset(%Snippet{}, %{title: "Hello", content: "World"})
changeset.valid?  # => true

# Create changeset from existing struct
snippet = %Snippet{id: 1, title: "Old", content: "Content"}
changeset = Snippet.changeset(snippet, %{title: "New Title"})
changeset.changes  # => %{title: "New Title"}

# Invalid changeset
changeset = Snippet.changeset(%Snippet{}, %{title: ""})
changeset.valid?  # => false
changeset.errors  # => [title: {"can't be blank", [validation: :required]}]
```

## Cast and Validate

### cast/4

Cast converts external parameters to schema types:

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :views_count])
  # Converts %{"views_count" => "42"} to %{views_count: 42}
end
```

Cast behavior:
- String keys converted to atoms
- Values coerced to field types
- Unknown fields ignored (whitelist approach)
- Invalid types marked as errors

### validate_required/3

Ensures fields are present:

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :language])
  |> validate_required([:title, :content])
  # language is optional
end
```

## Built-in Validations

### Length Validations

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content])
  |> validate_length(:title, min: 1, max: 100)
  |> validate_length(:content, min: 1, max: 100_000)
  |> validate_length(:tags, min: 1, max: 5)  # For arrays
end
```

Options: `:min`, `:max`, `:is` (exact), `:count` (`:codepoints` or `:graphemes`)

### Format Validations

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:email, :username, :website])
  |> validate_format(:email, ~r/@/)
  |> validate_format(:username, ~r/^[a-z0-9_]+$/i,
       message: "only letters, numbers, and underscores")
  |> validate_format(:website, ~r/^https?:\/\//,
       message: "must start with http:// or https://")
end
```

### Inclusion/Exclusion

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:language, :status])
  |> validate_inclusion(:language, ~w(elixir ruby python javascript))
  |> validate_exclusion(:status, ["banned", "spam"])
end
```

### Number Validations

```elixir
def changeset(product, attrs) do
  product
  |> cast(attrs, [:price, :quantity, :rating])
  |> validate_number(:price, greater_than: 0)
  |> validate_number(:quantity, greater_than_or_equal_to: 0)
  |> validate_number(:rating, greater_than_or_equal_to: 1, less_than_or_equal_to: 5)
end
```

### Acceptance Validation

For checkboxes like "I agree to terms":

```elixir
schema "users" do
  field :terms_accepted, :boolean, virtual: true
end

def registration_changeset(user, attrs) do
  user
  |> cast(attrs, [:email, :terms_accepted])
  |> validate_acceptance(:terms_accepted)
end
```

### Confirmation Validation

For password confirmation:

```elixir
schema "users" do
  field :password, :string, virtual: true
  field :password_confirmation, :string, virtual: true
  field :password_hash, :string
end

def changeset(user, attrs) do
  user
  |> cast(attrs, [:password, :password_confirmation])
  |> validate_required([:password])
  |> validate_confirmation(:password, required: true)
end
```

## Uniqueness Validation

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:email, :username])
  |> validate_required([:email, :username])
  |> unique_constraint(:email)
  |> unique_constraint(:username)
end
```

**Important**: `unique_constraint` requires a database unique index:

```elixir
# In migration
create unique_index(:users, [:email])
create unique_index(:users, [:username])
```

The validation only triggers when inserting/updating in the database.

### Composite Uniqueness

```elixir
# Unique title per user
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :user_id])
  |> unique_constraint([:user_id, :title],
       name: :snippets_user_id_title_index,
       message: "you already have a snippet with this title")
end

# In migration
create unique_index(:snippets, [:user_id, :title])
```

## Custom Validations

### Simple Custom Validation

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :expires_at])
  |> validate_future_date(:expires_at)
end

defp validate_future_date(changeset, field) do
  validate_change(changeset, field, fn _, value ->
    if DateTime.compare(value, DateTime.utc_now()) == :gt do
      []  # No errors
    else
      [{field, "must be in the future"}]
    end
  end)
end
```

### Validation with Multiple Fields

```elixir
def changeset(event, attrs) do
  event
  |> cast(attrs, [:starts_at, :ends_at])
  |> validate_required([:starts_at, :ends_at])
  |> validate_end_after_start()
end

defp validate_end_after_start(changeset) do
  starts_at = get_field(changeset, :starts_at)
  ends_at = get_field(changeset, :ends_at)

  if starts_at && ends_at && DateTime.compare(ends_at, starts_at) != :gt do
    add_error(changeset, :ends_at, "must be after start time")
  else
    changeset
  end
end
```

### Complex Business Rules

```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:content, :language])
  |> validate_required([:content])
  |> validate_syntax()
end

defp validate_syntax(changeset) do
  language = get_field(changeset, :language)
  content = get_field(changeset, :content)

  case validate_code_syntax(language, content) do
    :ok -> changeset
    {:error, line, message} ->
      add_error(changeset, :content, "syntax error on line #{line}: #{message}")
  end
end

defp validate_code_syntax("elixir", content) do
  case Code.string_to_quoted(content) do
    {:ok, _} -> :ok
    {:error, {line, message, _}} -> {:error, line, message}
  end
end

defp validate_code_syntax(_, _), do: :ok
```

## Multiple Changesets

### Different Changesets for Different Operations

```elixir
defmodule Snippetbox.Snippets.Snippet do
  # For creating new snippets
  def create_changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :language])
    |> validate_required([:title, :content])
    |> validate_length(:title, max: 100)
  end

  # For updating existing snippets
  def update_changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :language])
    |> validate_length(:title, max: 100)
    # title and content not required - can update just one field
  end

  # For admin operations
  def admin_changeset(snippet, attrs) do
    snippet
    |> cast(attrs, [:title, :content, :language, :is_featured, :is_public])
    |> validate_required([:title, :content])
  end
end
```

### Context-Specific Changesets

```elixir
defmodule Snippetbox.Accounts.User do
  def registration_changeset(user, attrs) do
    user
    |> cast(attrs, [:email, :password])
    |> validate_required([:email, :password])
    |> validate_format(:email, ~r/@/)
    |> validate_length(:password, min: 8)
    |> unique_constraint(:email)
    |> hash_password()
  end

  def profile_changeset(user, attrs) do
    user
    |> cast(attrs, [:name, :bio, :website])
    |> validate_length(:bio, max: 500)
    |> validate_format(:website, ~r/^https?:\/\//)
  end

  def password_changeset(user, attrs) do
    user
    |> cast(attrs, [:password])
    |> validate_required([:password])
    |> validate_length(:password, min: 8)
    |> hash_password()
  end
end
```

## Working with Changeset Data

### Getting Values

```elixir
changeset = Snippet.changeset(%Snippet{title: "Old"}, %{title: "New"})

# Get changed value (or original if not changed)
get_field(changeset, :title)  # => "New"

# Get only the change (nil if not changed)
get_change(changeset, :title)  # => "New"
get_change(changeset, :content)  # => nil

# Fetch with default
fetch_field(changeset, :title)  # => {:changes, "New"}
fetch_field(changeset, :content)  # => {:data, nil}
```

### Setting Values

```elixir
changeset
|> put_change(:updated_by, user.id)
|> put_change(:slug, generate_slug(title))
|> force_change(:version, snippet.version + 1)
```

### Deleting Changes

```elixir
changeset
|> delete_change(:password)  # Remove sensitive data
```

## Error Messages

### Accessing Errors

```elixir
changeset = Snippet.changeset(%Snippet{}, %{title: "", content: ""})

changeset.errors
# => [
#   title: {"can't be blank", [validation: :required]},
#   content: {"can't be blank", [validation: :required]}
# ]

# Traverse errors for display
Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
  Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
    opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
  end)
end)
# => %{title: ["can't be blank"], content: ["can't be blank"]}
```

### Custom Error Messages

```elixir
|> validate_required([:title], message: "please enter a title")
|> validate_length(:title, min: 3, message: "must be at least 3 characters")
|> validate_format(:email, ~r/@/, message: "must be a valid email address")
```

> **FP Concept: Changeset as Data Pipeline**
>
> Changesets are built using the pipe operator as a transformation pipeline:
>
> ```elixir
> snippet
> |> cast(attrs, [:title, :content])      # Transform 1
> |> validate_required([:title])           # Transform 2
> |> validate_length(:title, max: 100)     # Transform 3
> |> unique_constraint(:slug)              # Transform 4
> ```
>
> Each function takes a changeset and returns a changeset, allowing composition:
> - Functions are pure (same input â†’ same output)
> - Order matters (validations run in sequence)
> - Errors accumulate (all validations run, not just until first failure)
>
> This is the "railway-oriented programming" pattern - data flows through transformations, accumulating results.
>
> **Further Reading**:
> - [Ecto.Changeset](https://hexdocs.pm/ecto/Ecto.Changeset.html)
> - [Railway Oriented Programming](https://fsharpforfunandprofit.com/rop/)

## Summary

In this chapter, we learned:

- Creating changesets with `cast` and `validate_required`
- Built-in validations (length, format, inclusion, number)
- Unique constraints with database indexes
- Custom validation functions
- Multiple changesets for different operations
- Accessing and displaying errors

In the next chapter, we'll use changesets with the Repo to insert, update, and delete data.

---

## Additional Information

### Changeset Inspection

```elixir
# In IEx
changeset = Snippet.changeset(%Snippet{}, %{title: "Hi"})

changeset.valid?     # => false
changeset.changes    # => %{title: "Hi"}
changeset.errors     # => [content: {...}]
changeset.data       # => %Snippet{...}
changeset.params     # => %{"title" => "Hi"}
```

### Comparing to Other Frameworks

**Rails Validations**:
```ruby
class Snippet < ApplicationRecord
  validates :title, presence: true, length: { maximum: 100 }
  validates :email, uniqueness: true
end
```

**Django**:
```python
class Snippet(models.Model):
    title = models.CharField(max_length=100)

    def clean(self):
        if not self.title:
            raise ValidationError("Title required")
```

**Ecto**:
```elixir
def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title])
  |> validate_required([:title])
  |> validate_length(:title, max: 100)
end
```

Ecto's approach is more explicit and functional - validations are data transformations, not class methods.
