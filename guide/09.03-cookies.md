# Chapter 9.3: Cookies

Cookies store small pieces of data in the user's browser. In this chapter, we'll explore cookie handling in Phoenix.

## Cookie Basics

### How Cookies Work

```
Browser                          Server
   │                               │
   │  Request                      │
   │──────────────────────────────>│
   │                               │
   │  Response                     │
   │  Set-Cookie: theme=dark       │
   │<──────────────────────────────│
   │                               │
   │  Cookie stored in browser     │
   │                               │
   │  Subsequent Request           │
   │  Cookie: theme=dark           │
   │──────────────────────────────>│
   │                               │
```

### Cookie Characteristics

| Property | Description |
|----------|-------------|
| Size | Max ~4KB per cookie |
| Quantity | ~50 cookies per domain |
| Sent | With every request to domain |
| Storage | Client-side (browser) |
| Visibility | User can see/modify |

## Reading Cookies

### Basic Reading

```elixir
# File: lib/snippetbox_web/controllers/page_controller.ex

def home(conn, _params) do
  # Read a specific cookie
  theme = conn.cookies["theme"] || "light"

  # Read all cookies
  all_cookies = conn.cookies

  render(conn, :home, theme: theme)
end
```

### In Plugs

```elixir
# File: lib/snippetbox_web/plugs/theme.ex

defmodule SnippetboxWeb.Plugs.Theme do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    theme = conn.cookies["theme"] || "light"
    assign(conn, :theme, theme)
  end
end
```

## Writing Cookies

### Basic Cookie

```elixir
def set_theme(conn, %{"theme" => theme}) do
  conn
  |> put_resp_cookie("theme", theme)
  |> redirect(to: ~p"/")
end
```

### Cookie with Options

```elixir
def set_preferences(conn, %{"language" => lang}) do
  conn
  |> put_resp_cookie("language", lang,
       max_age: 60 * 60 * 24 * 365,  # 1 year
       http_only: true,
       secure: true,
       same_site: "Lax"
     )
  |> redirect(to: ~p"/settings")
end
```

### Cookie Options

| Option | Description | Default |
|--------|-------------|---------|
| `:max_age` | Lifetime in seconds | Session |
| `:expires` | Specific expiry datetime | None |
| `:path` | URL path scope | `"/"` |
| `:domain` | Domain scope | Current |
| `:secure` | HTTPS only | `false` |
| `:http_only` | Not accessible via JS | `true` |
| `:same_site` | CSRF protection | `"Lax"` |

## Deleting Cookies

```elixir
def clear_preferences(conn, _params) do
  conn
  |> delete_resp_cookie("theme")
  |> delete_resp_cookie("language")
  |> redirect(to: ~p"/settings")
end

# With path option (must match set path)
|> delete_resp_cookie("theme", path: "/app")
```

## Signed Cookies

Signed cookies prevent tampering:

```elixir
# File: lib/snippetbox_web/controllers/preferences_controller.ex

@cookie_signing_salt "preferences_salt"

def set_user_preferences(conn, %{"prefs" => prefs}) do
  # Encode and sign
  signed_value = sign_cookie(conn, prefs)

  conn
  |> put_resp_cookie("user_prefs", signed_value, max_age: 60 * 60 * 24 * 30)
  |> redirect(to: ~p"/")
end

def get_user_preferences(conn) do
  case conn.cookies["user_prefs"] do
    nil -> %{}
    signed_value -> verify_cookie(conn, signed_value)
  end
end

defp sign_cookie(conn, data) do
  data
  |> Jason.encode!()
  |> Phoenix.Token.sign(conn, @cookie_signing_salt)
end

defp verify_cookie(conn, signed_value) do
  case Phoenix.Token.verify(conn, @cookie_signing_salt, signed_value, max_age: 60 * 60 * 24 * 30) do
    {:ok, json} -> Jason.decode!(json)
    {:error, _} -> %{}
  end
end
```

## Encrypted Cookies

For sensitive data, use encryption:

```elixir
defmodule SnippetboxWeb.EncryptedCookie do
  @secret_key_base Application.compile_env(:snippetbox, SnippetboxWeb.Endpoint)[:secret_key_base]

  def encrypt(data) do
    :crypto.strong_rand_bytes(16)
    |> then(fn iv ->
      key = :crypto.hash(:sha256, @secret_key_base)
      plaintext = Jason.encode!(data)
      ciphertext = :crypto.crypto_one_time(:aes_256_gcm, key, iv, plaintext, true)
      Base.url_encode64(iv <> ciphertext)
    end)
  end

  def decrypt(encrypted) do
    with {:ok, binary} <- Base.url_decode64(encrypted),
         <<iv::binary-16, ciphertext::binary>> <- binary do
      key = :crypto.hash(:sha256, @secret_key_base)
      plaintext = :crypto.crypto_one_time(:aes_256_gcm, key, iv, ciphertext, false)
      Jason.decode!(plaintext)
    else
      _ -> nil
    end
  end
end
```

## Cookie Patterns

### Remember Me

```elixir
# File: lib/snippetbox_web/controllers/session_controller.ex

def create(conn, %{"email" => email, "password" => password, "remember_me" => remember}) do
  case Accounts.authenticate(email, password) do
    {:ok, user} ->
      conn = put_session(conn, :user_id, user.id)

      conn =
        if remember == "true" do
          token = Accounts.generate_remember_token(user)
          put_resp_cookie(conn, "remember_token", token,
            max_age: 60 * 60 * 24 * 30,  # 30 days
            http_only: true,
            secure: Mix.env() == :prod
          )
        else
          conn
        end

      redirect(conn, to: ~p"/")

    {:error, _} ->
      render(conn, :new, error: "Invalid credentials")
  end
end

# Plug to restore session from remember token
def restore_session(conn, _opts) do
  if get_session(conn, :user_id) do
    conn
  else
    case conn.cookies["remember_token"] do
      nil -> conn
      token ->
        case Accounts.get_user_by_remember_token(token) do
          nil ->
            delete_resp_cookie(conn, "remember_token")

          user ->
            conn
            |> put_session(:user_id, user.id)
            |> assign(:current_user, user)
        end
    end
  end
end
```

### User Preferences

```elixir
# File: lib/snippetbox_web/plugs/preferences.ex

defmodule SnippetboxWeb.Plugs.Preferences do
  import Plug.Conn

  @defaults %{
    "theme" => "light",
    "language" => "en",
    "timezone" => "UTC",
    "items_per_page" => "20"
  }

  def init(opts), do: opts

  def call(conn, _opts) do
    preferences =
      @defaults
      |> Enum.map(fn {key, default} ->
        {key, conn.cookies["pref_#{key}"] || default}
      end)
      |> Map.new()

    assign(conn, :preferences, preferences)
  end
end

# Controller to update preferences
defmodule SnippetboxWeb.PreferencesController do
  use SnippetboxWeb, :controller

  def update(conn, %{"preferences" => prefs}) do
    conn =
      Enum.reduce(prefs, conn, fn {key, value}, conn ->
        put_resp_cookie(conn, "pref_#{key}", value,
          max_age: 60 * 60 * 24 * 365,
          http_only: true
        )
      end)

    conn
    |> put_flash(:info, "Preferences saved!")
    |> redirect(to: ~p"/settings")
  end
end
```

### Consent Cookie

```elixir
# File: lib/snippetbox_web/controllers/consent_controller.ex

defmodule SnippetboxWeb.ConsentController do
  use SnippetboxWeb, :controller

  def accept(conn, _params) do
    conn
    |> put_resp_cookie("cookie_consent", "accepted",
         max_age: 60 * 60 * 24 * 365,
         http_only: false  # Allow JS to read
       )
    |> json(%{status: "ok"})
  end
end

# Plug to check consent
defmodule SnippetboxWeb.Plugs.CookieConsent do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    consent = conn.cookies["cookie_consent"] == "accepted"
    assign(conn, :cookie_consent, consent)
  end
end
```

### Tracking Cookies (with Consent)

```elixir
# Only set tracking if consent given
def maybe_track(conn, _opts) do
  if conn.assigns[:cookie_consent] do
    visitor_id = conn.cookies["visitor_id"] || generate_visitor_id()

    conn
    |> put_resp_cookie("visitor_id", visitor_id,
         max_age: 60 * 60 * 24 * 365
       )
    |> assign(:visitor_id, visitor_id)
  else
    conn
  end
end

defp generate_visitor_id do
  :crypto.strong_rand_bytes(16) |> Base.url_encode64()
end
```

## Cookie Security

### Secure Defaults

```elixir
defp secure_cookie(conn, name, value, opts \\ []) do
  defaults = [
    http_only: true,
    secure: Mix.env() == :prod,
    same_site: "Lax"
  ]

  put_resp_cookie(conn, name, value, Keyword.merge(defaults, opts))
end
```

### SameSite Attribute

| Value | Behavior |
|-------|----------|
| `"Strict"` | Only sent on same-site requests |
| `"Lax"` | Sent on same-site + top-level navigation |
| `"None"` | Sent on all requests (requires `secure: true`) |

```elixir
# For authentication cookies
put_resp_cookie(conn, "session", value, same_site: "Lax")

# For cross-site cookies (e.g., embedded widgets)
put_resp_cookie(conn, "widget_pref", value,
  same_site: "None",
  secure: true
)
```

> **FP Concept: Explicit Data Flow**
>
> Phoenix makes cookie handling explicit:
>
> ```elixir
> # Read: explicit access
> value = conn.cookies["key"]
>
> # Write: returns new conn
> conn = put_resp_cookie(conn, "key", "value")
>
> # Delete: returns new conn
> conn = delete_resp_cookie(conn, "key")
> ```
>
> Unlike frameworks with implicit cookie access, Phoenix requires explicit read/write operations, making data flow clear and predictable.

## Summary

In this chapter, we learned:

- How cookies work in HTTP
- Reading cookies from requests
- Writing cookies with various options
- Deleting cookies
- Signed and encrypted cookies
- Common patterns (remember me, preferences)
- Cookie security best practices

In the next chapter, we'll explore ETS and caching.
