# Chapter 9.4: ETS and Caching

ETS (Erlang Term Storage) provides fast in-memory storage. In this chapter, we'll explore how to use ETS for caching and state management.

## Understanding ETS

### What is ETS?

ETS is a built-in Erlang/Elixir key-value store:

- **Fast**: In-memory, constant-time lookups
- **Concurrent**: Multiple processes can read/write
- **Large**: Can store millions of entries
- **Volatile**: Data lost on restart

### When to Use ETS

| Use Case | ETS | Alternative |
|----------|-----|-------------|
| Rate limiting | ✅ | Redis |
| Cache expensive queries | ✅ | Redis, Cachex |
| Session storage | ✅ | Database |
| Configuration cache | ✅ | Application env |
| Temporary counters | ✅ | Agent |
| Persistent data | ❌ | Database |
| Distributed state | ❌ | Redis, Mnesia |

## Creating ETS Tables

### In Application Start

```elixir
# File: lib/snippetbox/application.ex

defmodule Snippetbox.Application do
  use Application

  def start(_type, _args) do
    # Create ETS tables before starting supervision tree
    create_ets_tables()

    children = [
      SnippetboxWeb.Telemetry,
      Snippetbox.Repo,
      {Phoenix.PubSub, name: Snippetbox.PubSub},
      SnippetboxWeb.Endpoint
    ]

    opts = [strategy: :one_for_one, name: Snippetbox.Supervisor]
    Supervisor.start_link(children, opts)
  end

  defp create_ets_tables do
    :ets.new(:cache, [:set, :public, :named_table, read_concurrency: true])
    :ets.new(:rate_limits, [:set, :public, :named_table, write_concurrency: true])
    :ets.new(:sessions, [:set, :public, :named_table, read_concurrency: true])
  end
end
```

### Table Types

```elixir
# Set: unique keys (default)
:ets.new(:cache, [:set, :named_table])

# Ordered set: keys sorted
:ets.new(:leaderboard, [:ordered_set, :named_table])

# Bag: multiple values per key
:ets.new(:tags, [:bag, :named_table])

# Duplicate bag: allows duplicate key-value pairs
:ets.new(:events, [:duplicate_bag, :named_table])
```

### Access Options

```elixir
# Public: any process can read/write
:ets.new(:cache, [:public, :named_table])

# Protected: any process can read, owner writes (default)
:ets.new(:config, [:protected, :named_table])

# Private: only owner process
:ets.new(:internal, [:private, :named_table])
```

### Concurrency Options

```elixir
# Optimized for concurrent reads
:ets.new(:cache, [:named_table, read_concurrency: true])

# Optimized for concurrent writes
:ets.new(:counters, [:named_table, write_concurrency: true])

# Both
:ets.new(:sessions, [:named_table, read_concurrency: true, write_concurrency: true])
```

## Basic Operations

### Insert

```elixir
# Single insert
:ets.insert(:cache, {"key", "value"})

# Multiple insert
:ets.insert(:cache, [{"key1", "value1"}, {"key2", "value2"}])

# Insert with timestamp
:ets.insert(:cache, {"key", "value", System.system_time(:second)})
```

### Lookup

```elixir
# Returns list of tuples
case :ets.lookup(:cache, "key") do
  [{_key, value}] -> {:ok, value}
  [] -> :not_found
end

# Or with match
case :ets.lookup(:cache, "key") do
  [{_, value, _timestamp}] -> {:ok, value}
  [] -> :not_found
end
```

### Delete

```elixir
# Delete single key
:ets.delete(:cache, "key")

# Delete all entries
:ets.delete_all_objects(:cache)

# Delete entire table
:ets.delete(:cache)
```

### Update Counter

```elixir
# Atomic increment
:ets.update_counter(:rate_limits, "user:123", {2, 1})

# With default if key doesn't exist
:ets.update_counter(:rate_limits, "user:123", {2, 1}, {"user:123", 0})
```

## Caching Module

```elixir
# File: lib/snippetbox/cache.ex

defmodule Snippetbox.Cache do
  @table :cache
  @default_ttl 60 * 5  # 5 minutes

  def get(key) do
    case :ets.lookup(@table, key) do
      [{^key, value, expires_at}] ->
        if System.system_time(:second) < expires_at do
          {:ok, value}
        else
          delete(key)
          :miss
        end

      [] ->
        :miss
    end
  end

  def put(key, value, ttl \\ @default_ttl) do
    expires_at = System.system_time(:second) + ttl
    :ets.insert(@table, {key, value, expires_at})
    :ok
  end

  def delete(key) do
    :ets.delete(@table, key)
    :ok
  end

  def fetch(key, ttl \\ @default_ttl, fun) do
    case get(key) do
      {:ok, value} ->
        value

      :miss ->
        value = fun.()
        put(key, value, ttl)
        value
    end
  end

  def clear do
    :ets.delete_all_objects(@table)
    :ok
  end
end
```

### Usage

```elixir
# Simple get/put
Snippetbox.Cache.put("user:123", user)
{:ok, user} = Snippetbox.Cache.get("user:123")

# Fetch with fallback
user = Snippetbox.Cache.fetch("user:123", 300, fn ->
  Accounts.get_user!(123)
end)

# In context
defmodule Snippetbox.Snippets do
  alias Snippetbox.Cache

  def get_popular_snippets do
    Cache.fetch("popular_snippets", 60 * 15, fn ->
      Snippet
      |> order_by([s], desc: s.view_count)
      |> limit(10)
      |> Repo.all()
    end)
  end
end
```

## Rate Limiting with ETS

```elixir
# File: lib/snippetbox/rate_limiter.ex

defmodule Snippetbox.RateLimiter do
  @table :rate_limits

  def check(key, limit, window_seconds) do
    now = System.system_time(:second)
    window_start = now - window_seconds

    # Clean old entries and count current
    case :ets.lookup(@table, key) do
      [{^key, count, timestamp}] when timestamp >= window_start ->
        if count >= limit do
          {:deny, limit - count}
        else
          :ets.update_counter(@table, key, {2, 1})
          {:allow, limit - count - 1}
        end

      _ ->
        # Start new window
        :ets.insert(@table, {key, 1, now})
        {:allow, limit - 1}
    end
  end

  def reset(key) do
    :ets.delete(@table, key)
    :ok
  end
end
```

### Usage in Plug

```elixir
# File: lib/snippetbox_web/plugs/rate_limit.ex

defmodule SnippetboxWeb.Plugs.RateLimit do
  import Plug.Conn
  import Phoenix.Controller
  alias Snippetbox.RateLimiter

  def init(opts), do: opts

  def call(conn, opts) do
    limit = Keyword.get(opts, :limit, 100)
    window = Keyword.get(opts, :window, 60)
    key = rate_limit_key(conn, opts)

    case RateLimiter.check(key, limit, window) do
      {:allow, remaining} ->
        conn
        |> put_resp_header("x-ratelimit-limit", to_string(limit))
        |> put_resp_header("x-ratelimit-remaining", to_string(remaining))

      {:deny, _} ->
        conn
        |> put_status(:too_many_requests)
        |> json(%{error: "Rate limit exceeded"})
        |> halt()
    end
  end

  defp rate_limit_key(conn, opts) do
    case Keyword.get(opts, :by, :ip) do
      :ip -> "rate:#{:inet.ntoa(conn.remote_ip)}"
      :user -> "rate:user:#{conn.assigns[:current_user]&.id || "anon"}"
      fun when is_function(fun, 1) -> fun.(conn)
    end
  end
end
```

## Query Cache

```elixir
# File: lib/snippetbox/snippets.ex

defmodule Snippetbox.Snippets do
  alias Snippetbox.{Repo, Cache}
  alias Snippetbox.Snippets.Snippet

  def get_snippet!(id) do
    Cache.fetch("snippet:#{id}", 60, fn ->
      Repo.get!(Snippet, id)
    end)
  end

  def list_snippets(opts \\ []) do
    page = Keyword.get(opts, :page, 1)
    per_page = Keyword.get(opts, :per_page, 20)

    cache_key = "snippets:list:#{page}:#{per_page}"

    Cache.fetch(cache_key, 30, fn ->
      Snippet
      |> order_by([s], desc: s.inserted_at)
      |> offset(^((page - 1) * per_page))
      |> limit(^per_page)
      |> Repo.all()
    end)
  end

  def update_snippet(snippet, attrs) do
    result = snippet
    |> Snippet.changeset(attrs)
    |> Repo.update()

    # Invalidate cache on update
    case result do
      {:ok, updated} ->
        Cache.delete("snippet:#{snippet.id}")
        invalidate_list_caches()
        {:ok, updated}

      error ->
        error
    end
  end

  defp invalidate_list_caches do
    # Clear all list caches (simple approach)
    # In production, use more targeted invalidation
    :ets.match_delete(:cache, {:"$1", :_, :_})
  end
end
```

## Counter Cache

```elixir
# File: lib/snippetbox/counters.ex

defmodule Snippetbox.Counters do
  @table :counters

  def setup do
    :ets.new(@table, [:set, :public, :named_table, write_concurrency: true])
  end

  def increment(key, amount \\ 1) do
    :ets.update_counter(@table, key, {2, amount}, {key, 0})
  end

  def get(key) do
    case :ets.lookup(@table, key) do
      [{^key, count}] -> count
      [] -> 0
    end
  end

  def reset(key) do
    :ets.insert(@table, {key, 0})
  end
end
```

### View Counter Example

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def show(conn, %{"id" => id}) do
  snippet = Snippets.get_snippet!(id)

  # Increment view counter (non-blocking)
  Task.start(fn ->
    Counters.increment("snippet:#{id}:views")
  end)

  render(conn, :show, snippet: snippet)
end

# Periodic sync to database
defmodule Snippetbox.CounterSync do
  use GenServer

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def init(state) do
    schedule_sync()
    {:ok, state}
  end

  def handle_info(:sync, state) do
    sync_counters_to_database()
    schedule_sync()
    {:noreply, state}
  end

  defp schedule_sync do
    Process.send_after(self(), :sync, 60_000)  # Every minute
  end

  defp sync_counters_to_database do
    # Get all counters and update database
    :ets.tab2list(:counters)
    |> Enum.each(fn {key, count} ->
      case String.split(key, ":") do
        ["snippet", id, "views"] ->
          Snippets.increment_views(id, count)
          Counters.reset(key)

        _ ->
          :ok
      end
    end)
  end
end
```

## Cache Warming

```elixir
# File: lib/snippetbox/cache_warmer.ex

defmodule Snippetbox.CacheWarmer do
  use GenServer
  require Logger

  alias Snippetbox.{Cache, Snippets}

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def init(state) do
    warm_cache()
    schedule_refresh()
    {:ok, state}
  end

  def handle_info(:refresh, state) do
    warm_cache()
    schedule_refresh()
    {:noreply, state}
  end

  defp schedule_refresh do
    Process.send_after(self(), :refresh, 60_000 * 5)  # Every 5 minutes
  end

  defp warm_cache do
    Logger.info("Warming cache...")

    # Pre-load popular snippets
    popular = Snippets.list_popular_snippets()
    Cache.put("popular_snippets", popular, 60 * 10)

    # Pre-load recent snippets
    recent = Snippets.list_recent_snippets()
    Cache.put("recent_snippets", recent, 60 * 5)

    Logger.info("Cache warmed successfully")
  end
end
```

## ETS Cleanup

```elixir
# File: lib/snippetbox/cache_cleaner.ex

defmodule Snippetbox.CacheCleaner do
  use GenServer

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def init(state) do
    schedule_cleanup()
    {:ok, state}
  end

  def handle_info(:cleanup, state) do
    cleanup_expired()
    schedule_cleanup()
    {:noreply, state}
  end

  defp schedule_cleanup do
    Process.send_after(self(), :cleanup, 60_000)  # Every minute
  end

  defp cleanup_expired do
    now = System.system_time(:second)

    # Delete expired entries
    :ets.select_delete(:cache, [
      {{:_, :_, :"$1"}, [{:<, :"$1", now}], [true]}
    ])
  end
end
```

> **FP Concept: ETS as External State**
>
> ETS is one of the few places in Elixir where state lives outside process memory:
>
> ```elixir
> # State is external to any process
> :ets.insert(:cache, {key, value})
> :ets.lookup(:cache, key)
>
> # But operations are still explicit
> # No hidden state, no surprises
> ```
>
> This makes ETS powerful for sharing state across processes while maintaining the explicit data flow that functional programming encourages.
>
> **Further Reading**:
> - [ETS Documentation](https://www.erlang.org/doc/man/ets.html)
> - [Elixir ETS Guide](https://elixir-lang.org/getting-started/mix-otp/ets.html)

## Summary

In this chapter, we learned:

- What ETS is and when to use it
- Creating and configuring ETS tables
- Basic CRUD operations
- Building a caching module
- Rate limiting with ETS
- Query caching patterns
- Counter caching with database sync
- Cache warming and cleanup

This completes the Sessions and State chapter. In the next chapter, we'll explore security in Phoenix applications.
