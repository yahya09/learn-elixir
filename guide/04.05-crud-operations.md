# Chapter 4.5: CRUD Operations

With our schema and changesets defined, we can now perform Create, Read, Update, and Delete operations. In this chapter, we'll learn how to use the Repo module to interact with the database.

## The Repo Module

All database operations go through the Repo:

```elixir
alias Snippetbox.Repo
alias Snippetbox.Snippets.Snippet

# Repo is the interface to the database
Repo.insert(changeset)
Repo.get(Snippet, id)
Repo.update(changeset)
Repo.delete(snippet)
```

## Create Operations

### Inserting Records

```elixir
alias Snippetbox.Repo
alias Snippetbox.Snippets.Snippet

# Create changeset
changeset = Snippet.changeset(%Snippet{}, %{
  title: "Hello World",
  content: "puts 'Hello, World!'"
})

# Insert into database
case Repo.insert(changeset) do
  {:ok, snippet} ->
    IO.puts("Created snippet ##{snippet.id}")

  {:error, changeset} ->
    IO.inspect(changeset.errors)
end
```

### Insert!

Raises on failure (useful when you expect success):

```elixir
# Raises Ecto.InvalidChangesetError if invalid
snippet = Repo.insert!(%Snippet{
  title: "Example",
  content: "Content here"
})
```

### Insert with Returning

Get specific fields back:

```elixir
{:ok, snippet} = Repo.insert(changeset, returning: [:id, :inserted_at])
```

### Insert All

Bulk insert multiple records:

```elixir
entries = [
  %{title: "Snippet 1", content: "Content 1", inserted_at: now, updated_at: now},
  %{title: "Snippet 2", content: "Content 2", inserted_at: now, updated_at: now},
  %{title: "Snippet 3", content: "Content 3", inserted_at: now, updated_at: now}
]

{count, nil} = Repo.insert_all(Snippet, entries)
# count = 3
```

With returning:

```elixir
{count, snippets} = Repo.insert_all(Snippet, entries, returning: true)
# snippets = [%Snippet{...}, %Snippet{...}, %Snippet{...}]
```

## Read Operations

### Get by ID

```elixir
# Returns nil if not found
snippet = Repo.get(Snippet, 1)

# Raises Ecto.NoResultsError if not found
snippet = Repo.get!(Snippet, 1)
```

### Get by Attributes

```elixir
# Get first matching record
snippet = Repo.get_by(Snippet, title: "Hello World")
snippet = Repo.get_by(Snippet, title: "Hello", language: "elixir")

# Raises if not found
snippet = Repo.get_by!(Snippet, slug: "hello-world")
```

### Get All

```elixir
# Get all records
snippets = Repo.all(Snippet)

# With query
import Ecto.Query

snippets = Repo.all(from s in Snippet, where: s.is_public == true)
```

### Get One

```elixir
import Ecto.Query

# Returns single record or nil
snippet = Repo.one(from s in Snippet, where: s.id == ^id)

# Raises if not exactly one result
snippet = Repo.one!(from s in Snippet, where: s.slug == ^slug)
```

### Check Existence

```elixir
import Ecto.Query

exists? = Repo.exists?(from s in Snippet, where: s.slug == ^slug)
# => true or false
```

### Aggregate Functions

```elixir
import Ecto.Query

# Count
count = Repo.aggregate(Snippet, :count)
count = Repo.aggregate(from(s in Snippet, where: s.is_public), :count)

# Other aggregates
total_views = Repo.aggregate(Snippet, :sum, :views_count)
avg_length = Repo.aggregate(Snippet, :avg, :content_length)
max_views = Repo.aggregate(Snippet, :max, :views_count)
```

## Update Operations

### Updating Records

```elixir
# Fetch the record
snippet = Repo.get!(Snippet, 1)

# Create update changeset
changeset = Snippet.changeset(snippet, %{title: "New Title"})

# Update in database
case Repo.update(changeset) do
  {:ok, updated_snippet} ->
    IO.puts("Updated: #{updated_snippet.title}")

  {:error, changeset} ->
    IO.inspect(changeset.errors)
end
```

### Update!

Raises on failure:

```elixir
snippet = Repo.get!(Snippet, 1)
changeset = Snippet.changeset(snippet, %{title: "New Title"})
updated = Repo.update!(changeset)
```

### Update All

Bulk update matching records:

```elixir
import Ecto.Query

# Increment all view counts
{count, nil} = Repo.update_all(Snippet, inc: [views_count: 1])

# Update with conditions
{count, nil} = Repo.update_all(
  from(s in Snippet, where: s.expires_at < ^DateTime.utc_now()),
  set: [is_expired: true]
)

# Update and return records
{count, snippets} = Repo.update_all(
  from(s in Snippet, where: s.id == ^id),
  [set: [views_count: 100]],
  returning: true
)
```

## Delete Operations

### Deleting Records

```elixir
snippet = Repo.get!(Snippet, 1)

case Repo.delete(snippet) do
  {:ok, deleted_snippet} ->
    IO.puts("Deleted snippet ##{deleted_snippet.id}")

  {:error, changeset} ->
    IO.inspect(changeset.errors)
end
```

### Delete!

Raises on failure:

```elixir
snippet = Repo.get!(Snippet, 1)
Repo.delete!(snippet)
```

### Delete All

Bulk delete matching records:

```elixir
import Ecto.Query

# Delete all expired snippets
{count, nil} = Repo.delete_all(
  from s in Snippet, where: s.expires_at < ^DateTime.utc_now()
)

# Delete all
{count, nil} = Repo.delete_all(Snippet)
```

## The Context Pattern

Phoenix organizes database operations in context modules:

```elixir
# File: lib/snippetbox/snippets.ex

defmodule Snippetbox.Snippets do
  @moduledoc """
  The Snippets context - public API for snippet operations.
  """

  import Ecto.Query
  alias Snippetbox.Repo
  alias Snippetbox.Snippets.Snippet

  @doc """
  Returns all snippets.
  """
  def list_snippets do
    Repo.all(Snippet)
  end

  @doc """
  Returns all public snippets.
  """
  def list_public_snippets do
    Snippet
    |> where([s], s.is_public == true)
    |> order_by([s], desc: s.inserted_at)
    |> Repo.all()
  end

  @doc """
  Gets a single snippet.
  Raises Ecto.NoResultsError if not found.
  """
  def get_snippet!(id) do
    Repo.get!(Snippet, id)
  end

  @doc """
  Gets a snippet by ID, returns nil if not found.
  """
  def get_snippet(id) do
    Repo.get(Snippet, id)
  end

  @doc """
  Creates a snippet.
  """
  def create_snippet(attrs \\ %{}) do
    %Snippet{}
    |> Snippet.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Updates a snippet.
  """
  def update_snippet(%Snippet{} = snippet, attrs) do
    snippet
    |> Snippet.changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Deletes a snippet.
  """
  def delete_snippet(%Snippet{} = snippet) do
    Repo.delete(snippet)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking snippet changes.
  """
  def change_snippet(%Snippet{} = snippet, attrs \\ %{}) do
    Snippet.changeset(snippet, attrs)
  end
end
```

### Using the Context

```elixir
alias Snippetbox.Snippets

# List
snippets = Snippets.list_snippets()

# Get
snippet = Snippets.get_snippet!(1)

# Create
{:ok, snippet} = Snippets.create_snippet(%{
  title: "Hello",
  content: "World"
})

# Update
{:ok, updated} = Snippets.update_snippet(snippet, %{title: "New Title"})

# Delete
{:ok, _} = Snippets.delete_snippet(snippet)
```

## Transactions

For operations that must succeed or fail together:

```elixir
alias Ecto.Multi

def create_snippet_with_tags(attrs, tags) do
  Multi.new()
  |> Multi.insert(:snippet, Snippet.changeset(%Snippet{}, attrs))
  |> Multi.insert_all(:tags, Tag, fn %{snippet: snippet} ->
    Enum.map(tags, fn tag ->
      %{snippet_id: snippet.id, name: tag, inserted_at: now(), updated_at: now()}
    end)
  end)
  |> Repo.transaction()
end

# Returns
# {:ok, %{snippet: %Snippet{}, tags: {3, nil}}}
# or
# {:error, :snippet, changeset, %{}}
```

### Simple Transactions

```elixir
Repo.transaction(fn ->
  snippet = Repo.insert!(%Snippet{title: "A", content: "B"})
  Repo.insert!(%Tag{snippet_id: snippet.id, name: "elixir"})
  snippet
end)
```

### Rollback

```elixir
Repo.transaction(fn ->
  case Repo.insert(changeset) do
    {:ok, record} -> record
    {:error, changeset} -> Repo.rollback(changeset)
  end
end)
```

## Preloading Associations

```elixir
# Preload when fetching
snippet = Repo.get!(Snippet, 1) |> Repo.preload(:user)
snippet.user  # => %User{...}

# Preload in query
snippets = Repo.all(from s in Snippet, preload: [:user, :tags])

# Preload multiple
snippet = Repo.preload(snippet, [:user, :tags, comments: :author])
```

> **FP Concept: Result Tuples**
>
> Ecto uses tagged tuples for operation results:
>
> ```elixir
> {:ok, snippet}      # Success
> {:error, changeset} # Failure with reason
> ```
>
> This forces explicit error handling:
>
> ```elixir
> case Repo.insert(changeset) do
>   {:ok, snippet} -> handle_success(snippet)
>   {:error, changeset} -> handle_error(changeset)
> end
> ```
>
> Benefits:
> - **No exceptions** for expected failures
> - **Pattern matching** for control flow
> - **Composable** with `with` and `case`
> - **Explicit** error paths
>
> **Further Reading**:
> - [Ecto.Repo](https://hexdocs.pm/ecto/Ecto.Repo.html)

## Summary

In this chapter, we learned:

- Insert operations (`insert`, `insert!`, `insert_all`)
- Read operations (`get`, `get!`, `get_by`, `all`, `one`)
- Update operations (`update`, `update!`, `update_all`)
- Delete operations (`delete`, `delete!`, `delete_all`)
- The Context pattern for organizing database operations
- Transactions for atomic operations
- Preloading associations

In the next chapter, we'll learn how to build complex queries with Ecto.Query.

---

## Additional Information

### Conflict Handling

Handle unique constraint violations:

```elixir
Repo.insert(changeset, on_conflict: :nothing)
Repo.insert(changeset, on_conflict: :replace_all)
Repo.insert(changeset,
  on_conflict: [set: [updated_at: DateTime.utc_now()]],
  conflict_target: :email
)
```

### Comparing to Other ORMs

**ActiveRecord (Rails)**:
```ruby
Snippet.create(title: "Hi", content: "World")
Snippet.find(1)
snippet.update(title: "New")
snippet.destroy
```

**Django**:
```python
Snippet.objects.create(title="Hi", content="World")
Snippet.objects.get(pk=1)
snippet.title = "New"
snippet.save()
snippet.delete()
```

**Ecto**:
```elixir
Repo.insert(changeset)
Repo.get!(Snippet, 1)
Repo.update(changeset)
Repo.delete(snippet)
```

Ecto separates the struct from database operations, making the data flow explicit.
