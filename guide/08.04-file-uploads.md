# Chapter 8.4: File Uploads

Phoenix provides robust file upload handling. In this chapter, we'll explore both traditional form uploads and LiveView's advanced upload features.

## Basic File Upload

### Form Setup

```heex
<%# File: lib/snippetbox_web/controllers/snippet_html/new.html.heex %>

<.form for={@changeset} action={~p"/snippets"} multipart={true}>
  <.input field={@form[:title]} label="Title" />
  <.input field={@form[:content]} type="textarea" label="Content" />

  <div class="mt-4">
    <label class="block text-sm font-medium">Attachment</label>
    <input type="file" name="snippet[attachment]" class="mt-1" />
  </div>

  <.button>Create Snippet</.button>
</.form>
```

### Controller Handling

```elixir
# File: lib/snippetbox_web/controllers/snippet_controller.ex

def create(conn, %{"snippet" => snippet_params}) do
  # Handle file upload
  snippet_params = process_upload(snippet_params)

  case Snippets.create_snippet(snippet_params) do
    {:ok, snippet} ->
      conn
      |> put_flash(:info, "Snippet created successfully.")
      |> redirect(to: ~p"/snippets/#{snippet}")

    {:error, changeset} ->
      render(conn, :new, changeset: changeset)
  end
end

defp process_upload(%{"attachment" => %Plug.Upload{} = upload} = params) do
  # Generate unique filename
  extension = Path.extname(upload.filename)
  filename = "#{Ecto.UUID.generate()}#{extension}"

  # Define upload directory
  upload_dir = Path.join(["priv", "static", "uploads"])
  File.mkdir_p!(upload_dir)

  # Copy file to destination
  dest_path = Path.join(upload_dir, filename)
  File.cp!(upload.path, dest_path)

  # Update params with file path
  Map.put(params, "attachment_path", "/uploads/#{filename}")
end

defp process_upload(params), do: params
```

### Plug.Upload Structure

When a file is uploaded, Phoenix provides a `Plug.Upload` struct:

```elixir
%Plug.Upload{
  path: "/tmp/plug-1234/multipart-12345",  # Temporary file path
  filename: "myfile.pdf",                   # Original filename
  content_type: "application/pdf"           # MIME type
}
```

## File Validation

### Validating in Controller

```elixir
defp process_upload(%{"attachment" => %Plug.Upload{} = upload} = params) do
  with :ok <- validate_file_size(upload),
       :ok <- validate_file_type(upload) do
    # Process the upload
    save_upload(upload, params)
  else
    {:error, reason} ->
      # Return params unchanged, add error to changeset later
      Map.put(params, "attachment_error", reason)
  end
end

defp validate_file_size(%Plug.Upload{path: path}) do
  case File.stat(path) do
    {:ok, %{size: size}} when size <= 10_000_000 -> :ok  # 10MB limit
    {:ok, _} -> {:error, "File too large (max 10MB)"}
    {:error, _} -> {:error, "Could not read file"}
  end
end

defp validate_file_type(%Plug.Upload{content_type: type}) do
  allowed_types = ~w(image/jpeg image/png image/gif application/pdf text/plain)

  if type in allowed_types do
    :ok
  else
    {:error, "File type not allowed"}
  end
end
```

### Validating in Changeset

```elixir
# File: lib/snippetbox/snippets/snippet.ex

def changeset(snippet, attrs) do
  snippet
  |> cast(attrs, [:title, :content, :attachment_path])
  |> validate_required([:title, :content])
  |> validate_attachment(attrs)
end

defp validate_attachment(changeset, %{"attachment_error" => error}) do
  add_error(changeset, :attachment, error)
end

defp validate_attachment(changeset, _attrs), do: changeset
```

## Multiple File Uploads

### Form

```heex
<.form for={@changeset} action={~p"/gallery"} multipart={true}>
  <.input field={@form[:title]} label="Gallery Title" />

  <div class="mt-4">
    <label class="block text-sm font-medium">Images</label>
    <input type="file" name="gallery[images][]" multiple class="mt-1" />
    <p class="text-sm text-gray-500">Select up to 10 images</p>
  </div>

  <.button>Create Gallery</.button>
</.form>
```

### Controller

```elixir
def create(conn, %{"gallery" => %{"images" => uploads} = gallery_params}) when is_list(uploads) do
  # Process each upload
  image_paths =
    uploads
    |> Enum.take(10)  # Limit to 10 files
    |> Enum.map(&save_image/1)
    |> Enum.reject(&is_nil/1)

  gallery_params = Map.put(gallery_params, "image_paths", image_paths)

  case Galleries.create_gallery(gallery_params) do
    {:ok, gallery} ->
      redirect(conn, to: ~p"/galleries/#{gallery}")

    {:error, changeset} ->
      render(conn, :new, changeset: changeset)
  end
end

defp save_image(%Plug.Upload{} = upload) do
  if valid_image?(upload) do
    filename = "#{Ecto.UUID.generate()}#{Path.extname(upload.filename)}"
    dest = Path.join(["priv", "static", "uploads", "images", filename])
    File.cp!(upload.path, dest)
    "/uploads/images/#{filename}"
  end
end

defp valid_image?(%Plug.Upload{content_type: type}) do
  type in ~w(image/jpeg image/png image/gif image/webp)
end
```

## Image Processing

### Using Image Libraries

Add to `mix.exs`:

```elixir
defp deps do
  [
    {:image, "~> 0.37"}  # or {:mogrify, "~> 0.9"}
  ]
end
```

### Resizing Images

```elixir
defmodule Snippetbox.ImageProcessor do
  @moduledoc """
  Image processing utilities.
  """

  @upload_dir "priv/static/uploads"

  def process_avatar(upload) do
    with {:ok, image} <- Image.open(upload.path),
         {:ok, resized} <- Image.thumbnail(image, 200, height: 200, crop: :center),
         filename <- generate_filename(upload.filename),
         dest_path <- Path.join(@upload_dir, filename),
         :ok <- Image.write(resized, dest_path) do
      {:ok, "/uploads/#{filename}"}
    else
      {:error, reason} -> {:error, reason}
    end
  end

  def process_snippet_image(upload) do
    with {:ok, image} <- Image.open(upload.path),
         {:ok, resized} <- Image.thumbnail(image, 800),
         filename <- generate_filename(upload.filename),
         dest_path <- Path.join(@upload_dir, filename),
         :ok <- Image.write(resized, dest_path) do
      {:ok, "/uploads/#{filename}"}
    end
  end

  defp generate_filename(original) do
    ext = Path.extname(original)
    "#{Ecto.UUID.generate()}#{ext}"
  end
end
```

## Cloud Storage

### S3 Upload Example

Add to `mix.exs`:

```elixir
defp deps do
  [
    {:ex_aws, "~> 2.4"},
    {:ex_aws_s3, "~> 2.4"},
    {:hackney, "~> 1.18"},
    {:sweet_xml, "~> 0.7"}
  ]
end
```

Configuration:

```elixir
# File: config/config.exs

config :ex_aws,
  access_key_id: [{:system, "AWS_ACCESS_KEY_ID"}, :instance_role],
  secret_access_key: [{:system, "AWS_SECRET_ACCESS_KEY"}, :instance_role],
  region: "us-east-1"

config :snippetbox, :uploads,
  bucket: "my-snippetbox-uploads"
```

Upload module:

```elixir
defmodule Snippetbox.Uploads do
  @bucket Application.compile_env(:snippetbox, [:uploads, :bucket])

  def upload_to_s3(%Plug.Upload{} = upload) do
    filename = generate_filename(upload.filename)
    content = File.read!(upload.path)

    case ExAws.S3.put_object(@bucket, filename, content, content_type: upload.content_type)
         |> ExAws.request() do
      {:ok, _} ->
        {:ok, "https://#{@bucket}.s3.amazonaws.com/#{filename}"}

      {:error, reason} ->
        {:error, reason}
    end
  end

  defp generate_filename(original) do
    ext = Path.extname(original)
    "uploads/#{Date.utc_today()}/#{Ecto.UUID.generate()}#{ext}"
  end
end
```

## Serving Uploaded Files

### Static Plug Configuration

```elixir
# File: lib/snippetbox_web/endpoint.ex

plug Plug.Static,
  at: "/uploads",
  from: {:snippetbox, "priv/static/uploads"},
  gzip: false
```

### Secure File Downloads

```elixir
# File: lib/snippetbox_web/controllers/download_controller.ex

defmodule SnippetboxWeb.DownloadController do
  use SnippetboxWeb, :controller

  def show(conn, %{"id" => id}) do
    attachment = Attachments.get_attachment!(id)

    # Check authorization
    if authorized?(conn.assigns.current_user, attachment) do
      send_download(conn, {:file, attachment.path},
        filename: attachment.original_filename,
        content_type: attachment.content_type
      )
    else
      conn
      |> put_status(:forbidden)
      |> text("Access denied")
    end
  end

  defp authorized?(user, attachment) do
    attachment.user_id == user.id
  end
end
```

## LiveView Uploads (Preview)

LiveView provides advanced upload features with progress tracking:

```elixir
# File: lib/snippetbox_web/live/snippet_live/form.ex

defmodule SnippetboxWeb.SnippetLive.Form do
  use SnippetboxWeb, :live_view

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |> assign(:changeset, Snippets.change_snippet(%Snippet{}))
     |> allow_upload(:attachment,
       accept: ~w(.jpg .jpeg .png .pdf),
       max_entries: 3,
       max_file_size: 10_000_000
     )}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <.form for={@changeset} phx-submit="save" phx-change="validate">
      <.input field={@form[:title]} label="Title" />

      <div class="mt-4" phx-drop-target={@uploads.attachment.ref}>
        <.live_file_input upload={@uploads.attachment} />

        <%# Show upload progress %>
        <div :for={entry <- @uploads.attachment.entries} class="mt-2">
          <div class="flex items-center gap-2">
            <span><%= entry.client_name %></span>
            <progress value={entry.progress} max="100"><%= entry.progress %>%</progress>
            <button type="button" phx-click="cancel-upload" phx-value-ref={entry.ref}>
              Cancel
            </button>
          </div>

          <%# Show errors %>
          <p :for={err <- upload_errors(@uploads.attachment, entry)} class="text-red-600">
            <%= error_to_string(err) %>
          </p>
        </div>
      </div>

      <.button>Save</.button>
    </.form>
    """
  end

  @impl true
  def handle_event("save", %{"snippet" => params}, socket) do
    uploaded_files =
      consume_uploaded_entries(socket, :attachment, fn %{path: path}, entry ->
        dest = Path.join(["priv", "static", "uploads", entry.client_name])
        File.cp!(path, dest)
        {:ok, "/uploads/#{entry.client_name}"}
      end)

    params = Map.put(params, "attachments", uploaded_files)

    case Snippets.create_snippet(params) do
      {:ok, snippet} ->
        {:noreply,
         socket
         |> put_flash(:info, "Created!")
         |> push_navigate(to: ~p"/snippets/#{snippet}")}

      {:error, changeset} ->
        {:noreply, assign(socket, :changeset, changeset)}
    end
  end

  def handle_event("cancel-upload", %{"ref" => ref}, socket) do
    {:noreply, cancel_upload(socket, :attachment, ref)}
  end

  defp error_to_string(:too_large), do: "File too large"
  defp error_to_string(:not_accepted), do: "File type not accepted"
  defp error_to_string(:too_many_files), do: "Too many files"
end
```

> **FP Concept: Pipeline Processing**
>
> File uploads naturally fit the pipeline pattern:
>
> ```elixir
> upload
> |> validate_size()
> |> validate_type()
> |> generate_filename()
> |> save_to_storage()
> |> update_database()
> ```
>
> Each step transforms the data, making the flow clear and each step testable independently.

## Summary

In this chapter, we learned:

- Basic file upload handling
- File validation (size, type)
- Multiple file uploads
- Image processing and resizing
- Cloud storage with S3
- Serving and downloading files
- LiveView upload preview with progress

In the next chapter, we'll explore form validation in depth.
