# Chapter 1.1: Prerequisites

Before we start building our SnippetBox application, we need to set up our development environment. This chapter will guide you through installing Elixir, Phoenix, PostgreSQL, and related tools.

## Required Software

To follow along with this book, you'll need:

1. **Elixir** (1.16 or later)
2. **Erlang/OTP** (26 or later) - installed automatically with Elixir
3. **Phoenix Framework** (1.7 or later)
4. **PostgreSQL** (14 or later)
5. **Node.js** (16 or later) - for asset compilation
6. **A code editor** - VS Code, IntelliJ, Emacs, or Vim

## Installing Elixir

Elixir runs on the Erlang VM (BEAM). When you install Elixir, Erlang is typically installed as a dependency.

### macOS

Using Homebrew:

```bash
$ brew update
$ brew install elixir
```

### Ubuntu/Debian

```bash
$ wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb
$ sudo dpkg -i erlang-solutions_2.0_all.deb
$ sudo apt-get update
$ sudo apt-get install elixir
```

### Windows

1. Download the installer from https://elixir-lang.org/install.html
2. Run the installer
3. Verify installation from PowerShell or Command Prompt

### Using asdf (Recommended for Version Management)

The most flexible approach is using `asdf`, a version manager for multiple languages:

```bash
# Install asdf (macOS/Linux)
$ git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.13.1

# Add to your shell rc file (~/.bashrc, ~/.zshrc, etc.)
$ echo '. "$HOME/.asdf/asdf.sh"' >> ~/.zshrc
$ source ~/.zshrc

# Install Erlang and Elixir plugins
$ asdf plugin add erlang
$ asdf plugin add elixir

# Install specific versions
$ asdf install erlang 26.2.1
$ asdf install elixir 1.16.0-otp-26

# Set global versions
$ asdf global erlang 26.2.1
$ asdf global elixir 1.16.0-otp-26
```

### Verifying Installation

After installation, verify Elixir is working:

```bash
$ elixir --version
Erlang/OTP 26 [erts-14.2.1] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1]

Elixir 1.16.0 (compiled with Erlang/OTP 26)
```

## Installing PostgreSQL

Phoenix works with multiple databases, but we'll use PostgreSQL in this book.

### macOS

```bash
$ brew install postgresql@16
$ brew services start postgresql@16
```

### Ubuntu/Debian

```bash
$ sudo apt-get install postgresql postgresql-contrib
$ sudo service postgresql start
```

### Windows

1. Download from https://www.postgresql.org/download/windows/
2. Run the installer
3. Remember the password you set for the postgres user

### Verifying PostgreSQL

```bash
$ psql --version
psql (PostgreSQL) 16.1
```

Create a test database to ensure it's working:

```bash
$ psql -U postgres
postgres=# CREATE DATABASE test_db;
CREATE DATABASE
postgres=# \q
```

## Installing Phoenix

Phoenix is installed as a Mix archive. Mix is Elixir's build tool (similar to npm, pip, or bundler).

```bash
$ mix local.hex
$ mix archive.install hex phx_new
```

Verify Phoenix installation:

```bash
$ mix phx.new --version
Phoenix installer v1.7.10
```

## Installing Node.js

Phoenix uses esbuild for asset management, but some features still need Node.js.

### macOS

```bash
$ brew install node
```

### Ubuntu/Debian

```bash
$ curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
$ sudo apt-get install -y nodejs
```

### Windows

Download from https://nodejs.org/

### Verifying Node.js

```bash
$ node --version
v20.10.0

$ npm --version
10.2.3
```

## Code Editor Setup

While any text editor works, here are recommended setups for Elixir development:

### Visual Studio Code

Install these extensions:

```bash
# ElixirLS - Language Server
# Elixir Test
# Phoenix Framework
```

Settings for VS Code (`settings.json`):

```json
{
  "elixirLS.dialyzerEnabled": true,
  "elixirLS.suggestSpecs": true,
  "[elixir]": {
    "editor.formatOnSave": true
  }
}
```

### IntelliJ IDEA / JetBrains

Install the **Elixir plugin** from the marketplace.

### Emacs

Use `alchemist.el` or `elixir-mode`:

```elisp
(use-package elixir-mode
  :ensure t)

(use-package alchemist
  :ensure t)
```

### Vim/Neovim

Install `vim-elixir` and consider using CoC with ElixirLS:

```vim
Plug 'elixir-editors/vim-elixir'
Plug 'neoclide/coc.nvim', {'branch': 'release'}
```

## Testing Your Setup

Let's verify everything is working by creating a tiny test application:

```bash
$ mix phx.new test_app --no-install
$ cd test_app
$ mix deps.get
```

If everything is installed correctly, you should see:

```bash
* creating test_app/config/config.exs
* creating test_app/config/dev.exs
...
Resolving Hex dependencies...
Resolution completed in 0.1s
...
```

You can delete this test application:

```bash
$ cd ..
$ rm -rf test_app
```

## Understanding the Elixir Ecosystem

Before we proceed, let's understand the key tools you'll use:

### Mix

Mix is Elixir's build tool (think: make, rake, npm, cargo). It handles:

- Creating new projects
- Managing dependencies
- Running tests
- Compiling code
- Running custom tasks

Common commands:

```bash
$ mix new my_app          # Create new project
$ mix deps.get            # Install dependencies
$ mix test                # Run tests
$ mix compile             # Compile project
$ mix phx.server          # Start Phoenix server
```

### IEx

IEx is Elixir's interactive shell (like Python's REPL, Node's console, or irb for Ruby):

```bash
$ iex
Erlang/OTP 26 [erts-14.2.1]

Interactive Elixir (1.16.0)
iex(1)> 1 + 1
2
iex(2)> String.upcase("hello")
"HELLO"
```

You can also run IEx with your application loaded:

```bash
$ iex -S mix
```

### Hex

Hex is Elixir's package manager (like npm, pip, or RubyGems):

- Browse packages at https://hex.pm/
- Add dependencies in `mix.exs`
- Install with `mix deps.get`

### ExUnit

ExUnit is Elixir's built-in testing framework:

```elixir
defmodule MyAppTest do
  use ExUnit.Case

  test "the truth" do
    assert 1 + 1 == 2
  end
end
```

Run tests with `mix test`.

## Quick Elixir Primer

If you want a head start before Chapter 2, try these resources:

**Interactive Learning**:
- Elixir's official getting started guide: https://elixir-lang.org/getting-started/introduction.html
- Exercism Elixir track: https://exercism.org/tracks/elixir

**Quick Reference**:
- Elixir School: https://elixirschool.com/
- Elixir cheatsheet: https://devhints.io/elixir

**Books**:
- "Programming Elixir" by Dave Thomas
- "Elixir in Action" by Saša Jurić

However, you don't need to complete these before continuing - we'll teach Elixir as we build the application.

## Troubleshooting Common Issues

### Elixir won't install

- Ensure you have the correct Erlang version
- Check your system's package manager is up to date
- Try using asdf for version management

### PostgreSQL connection errors

```bash
# Reset PostgreSQL password
$ sudo -u postgres psql
postgres=# ALTER USER postgres PASSWORD 'postgres';
postgres=# \q
```

### Port already in use

Phoenix defaults to port 4000. If it's in use:

```bash
# Find what's using the port
$ lsof -i :4000

# Kill the process or use a different port
$ mix phx.server --port 4001
```

### Mix or Hex issues

```bash
# Update Mix and Hex
$ mix local.hex --force
$ mix local.rebar --force
```

## System Requirements

Minimum system requirements:

- **RAM**: 4GB (8GB recommended)
- **Disk**: 2GB free space
- **OS**: macOS 10.14+, Ubuntu 20.04+, Windows 10+

## Ready to Start

With your environment set up, you're ready to start building! In the next chapter, we'll create our SnippetBox application and write our first web server.

---

## Additional Information

### Why These Specific Versions?

We specify minimum versions because:

- **Elixir 1.16**: Includes better compilation diagnostics
- **Erlang/OTP 26**: Performance improvements and new features
- **Phoenix 1.7**: Verified routes, improved generators, better LiveView
- **PostgreSQL 14**: Better performance, improved JSON support

### Understanding Erlang/OTP

Elixir runs on the Erlang VM (BEAM). Some key points:

- **OTP**: "Open Telecom Platform" - set of libraries and design principles
- **BEAM**: The Erlang virtual machine - highly optimized for concurrency
- **Erlang heritage**: 30+ years of battle-testing in telecom systems

You don't need to learn Erlang, but understanding its foundation helps:

> **FP Concept: The Erlang VM**
>
> The BEAM (Erlang VM) is different from the JVM or Python's interpreter:
> - Ultra-lightweight processes (not OS threads)
> - Pre-emptive scheduling
> - Per-process garbage collection
> - Built-in distribution support
> - "Let it crash" philosophy with supervisors
>
> **Further Reading**:
> - [The Erlang Runtime System](https://beam-wisdoms.clau.se/en/latest/)
> - [How the BEAM Works](https://www.erlang.org/doc/apps/erts/absform.html)

### Development Workflow

A typical Elixir/Phoenix development workflow:

1. **Write code** in your editor
2. **Save file** - Phoenix auto-reloads
3. **Check browser** - changes appear automatically
4. **Run tests** - `mix test` in terminal
5. **Interactive debugging** - Use `IEx.pry` breakpoints
6. **Commit** - Use git for version control

This tight feedback loop makes development fast and productive.
