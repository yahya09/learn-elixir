# Chapter 14: Deployment

Deploying Phoenix applications requires understanding releases, configuration, and production environments. In this chapter, we'll explore deployment strategies.

## What You'll Learn

- Building Elixir releases
- Docker containerization
- Deploying to Fly.io
- Production configuration
- Monitoring and observability

## Chapter Structure

This chapter covers:

- **14.1 Releases** - Building self-contained releases
- **14.2 Docker** - Containerizing Phoenix apps
- **14.3 Fly.io** - Cloud deployment
- **14.4 Production Config** - Environment configuration
- **14.5 Monitoring** - Observability and debugging

## Deployment Options

### Platform Options

| Platform | Pros | Cons |
|----------|------|------|
| Fly.io | Easy, built for Elixir | Limited regions |
| Render | Simple, auto-deploy | No clustering |
| Gigalixir | Elixir-native | Smaller community |
| AWS/GCP | Full control | More complex |
| Docker anywhere | Portable | Self-managed |

### Deployment Strategies

```
Development → Staging → Production

Option 1: Platform-as-a-Service (PaaS)
├── Push to Git
├── Auto-deploy triggers
└── Platform manages infrastructure

Option 2: Container-based
├── Build Docker image
├── Push to registry
└── Deploy to orchestrator (K8s, ECS, etc.)

Option 3: Release-based
├── Build release locally/CI
├── Copy to server
└── Run with systemd/supervisor
```

## Quick Deployment Preview

### Fly.io (Recommended for Beginners)

```bash
# Install Fly CLI
curl -L https://fly.io/install.sh | sh

# Login
fly auth login

# Launch app (auto-detects Phoenix)
fly launch

# Deploy
fly deploy

# Open in browser
fly open
```

### Docker

```dockerfile
# Dockerfile
FROM elixir:1.16-alpine AS build

WORKDIR /app
ENV MIX_ENV=prod

COPY mix.exs mix.lock ./
RUN mix deps.get --only prod

COPY . .
RUN mix assets.deploy && mix release

FROM alpine:3.18
COPY --from=build /app/_build/prod/rel/snippetbox ./
CMD ["bin/snippetbox", "start"]
```

### Release

```bash
# Build release
MIX_ENV=prod mix release

# Run
_build/prod/rel/snippetbox/bin/snippetbox start
```

## Pre-Deployment Checklist

```markdown
□ Environment variables configured
□ Database migrations ready
□ Assets compiled and digested
□ Secret key base set
□ Database URL configured
□ HTTPS/TLS configured
□ Error tracking set up
□ Logging configured
□ Health check endpoint
□ Backup strategy
```

## Production vs Development

| Aspect | Development | Production |
|--------|-------------|------------|
| Code reloading | Enabled | Disabled |
| Debug info | Verbose | Minimal |
| Assets | Uncompiled | Compiled, cached |
| Database | Local | Managed service |
| Errors | Detailed | Generic |
| Secrets | .env files | Environment variables |
| SSL | Optional | Required |

## Phoenix Release Architecture

```
Release Package
├── bin/
│   └── snippetbox           # Start script
├── lib/
│   ├── snippetbox-0.1.0/    # App code
│   └── phoenix-1.7.x/       # Dependencies
├── releases/
│   └── 0.1.0/
│       ├── env.sh           # Environment
│       ├── remote.sh        # Remote console
│       └── vm.args          # BEAM args
└── erts-14.x/               # Erlang runtime
```

## Key Concepts

### Runtime Configuration

```elixir
# config/runtime.exs
# Runs at application startup, not compile time

import Config

config :snippetbox, SnippetboxWeb.Endpoint,
  url: [host: System.get_env("PHX_HOST")],
  secret_key_base: System.fetch_env!("SECRET_KEY_BASE")

config :snippetbox, Snippetbox.Repo,
  url: System.fetch_env!("DATABASE_URL")
```

### Release Commands

```bash
# Start the application
bin/snippetbox start

# Start with interactive shell
bin/snippetbox start_iex

# Run migrations
bin/snippetbox eval "Snippetbox.Release.migrate()"

# Open remote console to running app
bin/snippetbox remote
```

### Health Checks

```elixir
# lib/snippetbox_web/controllers/health_controller.ex

defmodule SnippetboxWeb.HealthController do
  use SnippetboxWeb, :controller

  def check(conn, _params) do
    case health_status() do
      :ok ->
        json(conn, %{status: "ok", timestamp: DateTime.utc_now()})

      {:error, reason} ->
        conn
        |> put_status(:service_unavailable)
        |> json(%{status: "error", reason: reason})
    end
  end

  defp health_status do
    with :ok <- check_database(),
         :ok <- check_external_services() do
      :ok
    end
  end

  defp check_database do
    case Ecto.Adapters.SQL.query(Snippetbox.Repo, "SELECT 1") do
      {:ok, _} -> :ok
      {:error, _} -> {:error, "database unavailable"}
    end
  end

  defp check_external_services, do: :ok
end
```

Let's explore each deployment strategy in detail.
