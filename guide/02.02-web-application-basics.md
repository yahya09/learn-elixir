# Chapter 2.2: Web Application Basics

Now that we have our Phoenix application set up, let's understand how Phoenix handles web requests. We'll build the three essential components of any web application:

1. **Controllers** - Handle requests and generate responses
2. **Router** - Map URLs to controllers
3. **Templates** - Generate HTML

## The Phoenix Request Flow

When a request comes in:

```
1. Browser → http://localhost:4000/snippets
2. Endpoint → Receives connection
3. Router → Matches URL pattern
4. Controller → Processes request
5. View → Prepares data
6. Template → Renders HTML
7. Browser ← Receives HTML response
```

Let's build each piece step by step.

## Creating a Simple Controller Action

Open `lib/snippetbox_web/controllers/page_controller.ex` and replace its contents:

```elixir
# File: lib/snippetbox_web/controllers/page_controller.ex

defmodule SnippetboxWeb.PageController do
  use SnippetboxWeb, :controller

  def home(conn, _params) do
    text(conn, "Hello from SnippetBox!")
  end
end
```

Let's break this down:

```elixir
defmodule SnippetboxWeb.PageController do
```
Defines a module (similar to a class in OOP, but without state). Phoenix convention is `AppNameWeb.ControllerName`.

```elixir
  use SnippetboxWeb, :controller
```
Imports Phoenix controller functionality (like `text/2`, `render/3`, etc.).

```elixir
  def home(conn, _params) do
```
Defines a controller action (function). It takes:
- `conn` - The connection struct (like `request` in other frameworks)
- `_params` - Request parameters (underscore means we're not using it yet)

```elixir
    text(conn, "Hello from SnippetBox!")
```
Sends a plain text response.

> **FP Concept: The Connection Struct**
>
> In Phoenix, the `conn` struct represents the entire HTTP request/response cycle. Instead of mutating a global request/response object, we pass `conn` through a pipeline of functions, each returning a new `conn` with modifications.
>
> ```elixir
> # Each function returns a NEW conn
> conn
> |> put_status(200)              # New conn with status 200
> |> put_resp_header("x-custom", "value")  # New conn with header
> |> text("Hello")                # New conn with response body
> ```
>
> This immutability means:
> - No accidental state mutations
> - Easy to test (pure functions)
> - Composable transformations
>
> **Further Reading**:
> - [Phoenix Guides - Plug Conn](https://hexdocs.pm/plug/Plug.Conn.html)
> - [Understanding Plug](https://elixirschool.com/en/lessons/misc/plug)

## Routing Requests

Now let's wire this controller to a URL. Open `lib/snippetbox_web/router.ex`:

```elixir
# File: lib/snippetbox_web/router.ex

defmodule SnippetboxWeb.Router do
  use SnippetboxWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {SnippetboxWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/", SnippetboxWeb do
    pipe_through :browser

    get "/", PageController, :home
  end
end
```

Focus on this part:

```elixir
scope "/", SnippetboxWeb do
  pipe_through :browser

  get "/", PageController, :home
end
```

This means:
- `get "/"` - Match GET requests to the root path
- `PageController` - Use this controller
- `:home` - Call the `home` function

Phoenix will call `PageController.home(conn, params)` for requests to `GET /`.

## Testing It Out

Start your server:

```bash
$ mix phx.server
```

Visit `http://localhost:4000/`. You should see:

```
Hello from SnippetBox!
```

## Adding More Routes

Let's add routes for viewing and creating snippets. Update your router:

```elixir
# File: lib/snippetbox_web/router.ex

scope "/", SnippetboxWeb do
  pipe_through :browser

  get "/", PageController, :home
  get "/snippet/:id", PageController, :show
  get "/snippet/create", PageController, :create
end
```

Now add these actions to your controller:

```elixir
# File: lib/snippetbox_web/controllers/page_controller.ex

defmodule SnippetboxWeb.PageController do
  use SnippetboxWeb, :controller

  def home(conn, _params) do
    text(conn, "Home page - Latest snippets")
  end

  def show(conn, %{"id" => id}) do
    text(conn, "Displaying snippet ##{id}")
  end

  def create(conn, _params) do
    text(conn, "Form for creating a new snippet")
  end
end
```

Note the `show` function:

```elixir
def show(conn, %{"id" => id}) do
```

This uses **pattern matching** to extract the `id` parameter. When someone visits `/snippet/123`, Phoenix calls `show(conn, %{"id" => "123"})`.

> **FP Concept: Pattern Matching**
>
> Pattern matching is a powerful feature in Elixir that lets you destructure data in function arguments:
>
> ```elixir
> # Match on specific keys in a map
> def show(conn, %{"id" => id}) do
>   # id variable now contains the value
> end
>
> # Match on multiple keys
> def create(conn, %{"title" => title, "content" => content}) do
>   # ...
> end
>
> # Provide default values
> def index(conn, %{"page" => page}) do
>   # ...
> end
> def index(conn, _params) do
>   # This clause matches when page is not provided
> end
> ```
>
> This is more concise and type-safe than:
> ```python
> # Python equivalent
> def show(request):
>     id = request.params.get('id')
>     if id is None:
>         raise ValueError("Missing id parameter")
> ```
>
> **Further Reading**:
> - [Elixir School - Pattern Matching](https://elixirschool.com/en/lessons/basics/pattern_matching)
> - [Pattern Matching in Function Clauses](https://elixir-lang.org/getting-started/pattern-matching.html)

## Testing the New Routes

Test your routes:

```bash
# Home page
$ curl http://localhost:4000/
Home page - Latest snippets

# View snippet
$ curl http://localhost:4000/snippet/5
Displaying snippet #5

# Create form
$ curl http://localhost:4000/snippet/create
Form for creating a new snippet
```

## Sending JSON Responses

Phoenix makes it easy to send JSON for API endpoints. Add a new action:

```elixir
# File: lib/snippetbox_web/controllers/page_controller.ex

def api_snippet(conn, %{"id" => id}) do
  snippet = %{
    id: id,
    title: "Example Snippet",
    content: "This is the content",
    created: "2024-01-08"
  }

  json(conn, snippet)
end
```

Add the route:

```elixir
# File: lib/snippetbox_web/router.ex

scope "/api", SnippetboxWeb do
  pipe_through :api

  get "/snippet/:id", PageController, :api_snippet
end
```

Test it:

```bash
$ curl http://localhost:4000/api/snippet/5
{"id":"5","title":"Example Snippet","content":"This is the content","created":"2024-01-08"}
```

## Understanding the Conn Struct

The `conn` (connection) struct contains everything about the request and response:

```elixir
# In IEx (iex -S mix phx.server)
iex> conn = %Plug.Conn{}
iex> conn.method
"GET"
iex> conn.request_path
"/snippet/5"
iex> conn.params
%{"id" => "5"}
iex> conn.status
nil  # Not set yet
```

Common operations on `conn`:

```elixir
# Set status code
conn = put_status(conn, 404)

# Set response headers
conn = put_resp_header(conn, "content-type", "application/json")

# Set response body
conn = send_resp(conn, 200, "Response body")

# Redirect
conn = redirect(conn, to: "/other-page")

# Send file
conn = send_file(conn, 200, "path/to/file.pdf")
```

## The Plug Pipeline

Notice we're building up the response by transforming `conn`:

```elixir
conn
|> put_status(200)
|> put_resp_header("x-version", "1.0")
|> text("Hello")
```

This is the **plug pipeline** in action. Each function:
1. Takes a `conn`
2. Transforms it
3. Returns a new `conn`

The `|>` (pipe operator) passes the result of one function to the next:

```elixir
# These are equivalent:

# With pipe
result = value
|> function1()
|> function2()
|> function3()

# Without pipe
result = function3(function2(function1(value)))
```

> **FP Concept: The Pipe Operator**
>
> The pipe operator `|>` makes data transformations readable:
>
> ```elixir
> # Reading left-to-right (natural for humans)
> users
> |> Enum.filter(&(&1.active))
> |> Enum.map(&(&1.email))
> |> Enum.join(", ")
>
> # vs nested functions (harder to read)
> Enum.join(Enum.map(Enum.filter(users, &(&1.active)), &(&1.email)), ", ")
> ```
>
> The pipe operator in Elixir is similar to:
> - Unix pipes: `cat file.txt | grep "error" | wc -l`
> - Method chaining: `users.filter(...).map(...).join(", ")`
> - F# pipe operator: `|>`
>
> But in Elixir, it's part of the language and works with any function.
>
> **Further Reading**:
> - [Elixir School - Pipe Operator](https://elixirschool.com/en/lessons/basics/pipe_operator)

## Comparing to Other Frameworks

Here's how Phoenix controllers compare to other frameworks:

### Django (Python)
```python
# Django view
def show_snippet(request, id):
    return HttpResponse(f"Snippet {id}")
```

### Express (Node.js)
```javascript
// Express route handler
app.get('/snippet/:id', (req, res) => {
  res.send(`Snippet ${req.params.id}`);
});
```

### Laravel (PHP)
```php
// Laravel controller method
public function show($id) {
    return "Snippet " . $id;
}
```

### Phoenix (Elixir)
```elixir
# Phoenix controller action
def show(conn, %{"id" => id}) do
  text(conn, "Snippet #{id}")
end
```

The main difference: Phoenix passes the connection through a pipeline of transformations rather than mutating a request/response object.

## Summary

In this chapter, we learned:

- How to create controller actions (functions)
- How to define routes in the router
- How to match URL parameters with pattern matching
- How to send text and JSON responses
- How the `conn` struct works
- How to use the pipe operator for transformations

In the next chapter, we'll explore routing in more detail and learn about different HTTP methods.

---

## Additional Information

### Controller Naming Conventions

Phoenix follows these conventions:

- Controller module: `AppWeb.ThingController`
- Controller file: `lib/app_web/controllers/thing_controller.ex`
- Action names: `index`, `show`, `new`, `create`, `edit`, `update`, `delete`

These map to RESTful resources:

| Action | HTTP Method | Path | Purpose |
|--------|-------------|------|---------|
| `index` | GET | `/things` | List all |
| `show` | GET | `/things/:id` | Show one |
| `new` | GET | `/things/new` | New form |
| `create` | POST | `/things` | Create |
| `edit` | GET | `/things/:id/edit` | Edit form |
| `update` | PATCH/PUT | `/things/:id` | Update |
| `delete` | DELETE | `/things/:id` | Delete |

We'll use these conventions as we build our application.

### Why "conn" Instead of "req" and "res"?

In frameworks like Express, you have separate `request` and `response` objects:

```javascript
app.get('/', (req, res) => {
  // req for request data
  // res for response methods
});
```

Phoenix uses a single `conn` struct that represents the entire HTTP connection. This is because:

1. **Immutability**: We don't mutate; we transform and return new values
2. **Pipeline**: Easier to pass through a series of transformations
3. **Testability**: Single data structure to inspect and assert on

The conn struct contains both request information (method, headers, params) and response information (status, headers, body).
